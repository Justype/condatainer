#!/usr/bin/env python3
import os
import sys
import subprocess
import re
import shutil
import argparse
import json
import urllib.request
import platform
import stat
import shlex
from typing import Dict, List, Optional, Tuple

os.umask(0o002)

class Config:
    VERSION = "1.0.2"
    # Remote settings
    debug = False
    use_sbatch = True
    GITHUB_REPO = "Justype/condatainer"
    REMOTE_METADATA_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/metadata/build-scripts.json.gz"
    MODGEN_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/bin/modgen"
    CONDATAINER_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/bin/condatainer"
    GIT_RAW_URL_PREFIX = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/"

    # Folder paths
    SCRIPT_PATH = os.path.abspath(__file__)
    SCRIPT_NAME = os.path.basename(SCRIPT_PATH)
    PROGRAM_DIR = os.path.dirname(SCRIPT_PATH)
    CONDATINER_DIR = os.path.abspath(os.path.join(PROGRAM_DIR, ".."))

    BUILD_SCRIPTS_DIR = os.path.join(CONDATINER_DIR, "build-scripts")
    APPS_DIR = os.path.join(CONDATINER_DIR, "apps")
    APPS_MODULEFILES_DIR = os.path.join(CONDATINER_DIR, "apps-modules")
    REF_DIR = os.path.join(CONDATINER_DIR, "ref")
    REF_MODULEFILES_DIR = os.path.join(CONDATINER_DIR, "ref-modules")
    TMP_DIR = os.path.join(CONDATINER_DIR, "tmp")
    LOGS_DIR = os.path.join(CONDATINER_DIR, "logs")

    # Local apptainer
    MICROMAMBA_BIN = os.path.join(CONDATINER_DIR, "bin", "micromamba")
    CONDA_ROOT_DIR = os.path.join(CONDATINER_DIR, "conda")

    # File paths
    APPS_EM_TEMPLATE = os.path.join(CONDATINER_DIR, "build-scripts", "apps-template")
    REF_EM_TEMPLATE = os.path.join(CONDATINER_DIR, "build-scripts", "ref-template")
    APPS_LMOD_TEMPLATE = os.path.join(CONDATINER_DIR, "build-scripts", "apps-template.lua")
    REF_LMOD_TEMPLATE = os.path.join(CONDATINER_DIR, "build-scripts", "ref-template.lua")

    # Utils
    NCPUS = os.environ.get("SLURM_CPUS_PER_TASK", 4)
    IS_LMOD = os.environ.get("LMOD_DIR") is not None

def main():
    parser = argparse.ArgumentParser(
        description="ModGen: Use conda and build scripts to create environment-modules or Lmod modules.",
        epilog=f"For full manual, see https://github.com/{Config.GITHUB_REPO}/blob/main/assets/MANUAL_MG.md")
    parser.add_argument("-v", "--version", action="version", version=Config.VERSION, help="Show the version of ModGen", default=argparse.SUPPRESS)
    parser.add_argument("--debug", action="store_true", help="Enable debug mode with verbose output")
    parser.add_argument("-n", "--no-sbatch", "--local", dest="no_sbatch", action="store_true", help="Run all operations locally without using sbatch")
    subparsers = parser.add_subparsers(dest="action", metavar="COMMAND", required=True, help="Available actions")

    ModGen_Init.add_parser_arguments(subparsers)
    ModGen_Create.add_parser_arguments(subparsers)
    ModGen_Avail.add_parser_arguments(subparsers)
    ModGen_List.add_parser_arguments(subparsers)
    ModGen_Remove.add_parser_arguments(subparsers)
    ModGen_Exec.add_parser_arguments(subparsers)
    ModGen_Check.add_parser_arguments(subparsers)
    ModGen_Run.add_parser_arguments(subparsers)
    ModGen_Update.add_parser_arguments(subparsers)
    ModGen_CondaTainer.add_parser_arguments(subparsers)

    args = parser.parse_args()
    ModGen.ensure_env_modules_or_lmod()
    if not ModGen_Create.ensure_templates():
        Utils.print_error("Failed to ensure modulefile templates are available.")
        sys.exit(1)

    if args.debug:
        Config.debug = True
        Utils.print_debug("Debug mode enabled")
        Utils.print_debug(f"ModGen Version: {Config.VERSION}")
        Utils.print_debug(f"MODULE SYSTEM: {'Lmod' if Config.IS_LMOD else 'Environment-Modules'}")
    if args.no_sbatch:
        Config.use_sbatch = False
        Utils.print_debug("No sbatch mode enabled")

    if args.action in ("create", "install", "i"):
        ModGen_Create.parse_create_args(args)
    elif args.action in ("exec", "e"):
        ModGen_Exec.parse_exec_args(args)
    elif args.action in ("check", "c"):
        ModGen_Check.parse_check_args(args)
    elif args.action in ("run", "r"):
        ModGen_Run.parse_run_args(args)
    elif args.action in ("avail", "av"):
        ModGen_Avail.parse_avail_args(args)
    elif args.action in ("list", "ls"):
        ModGen_List.parse_list_args(args)
    elif args.action in ("remove", "delete", "uninstall", "rm", "del"):
        ModGen_Remove.parse_remove_args(args)
    elif args.action == "init":
        ModGen_Init.parse_init_args(args)
    elif args.action == "update":
        ModGen_Update.parse_update_args(args)
    elif args.action == "condatainer":
        ModGen_CondaTainer.parse_condatainer_args(args)

class Utils:
    remote_build_scripts_links: Optional[Dict[str, str]] = None
    local_build_scripts_paths: Optional[Dict[str, str]] = None

    @staticmethod
    def blue_text(text):
        return f"\033[94m{text}\033[0m"

    @staticmethod
    def red_text(text):
        return f"\033[91m{text}\033[0m"

    @staticmethod
    def yellow_text(text):
        return f"\033[93m{text}\033[0m"

    @staticmethod
    def green_text(text):
        return f"\033[92m{text}\033[0m"

    @staticmethod
    def print_message(message, end="\n", flush=True):
        print(f"[ModGen] {message}", end=end, flush=flush)

    @staticmethod
    def print_debug(debug_object, end="\n", flush=True):
        if Config.debug:
            print(f"[ModGen][{Utils.yellow_text('DEBUG')}]", end=" ", flush=True)
            print(debug_object, end=end, flush=flush)

    @staticmethod
    def print_note(message, end="\n", flush=True):
        print(f"[ModGen][{Utils.blue_text('NOTE')}] {message}", end=end, flush=flush)

    @staticmethod
    def print_warning(message, end="\n", flush=True):
        print(f"[ModGen][{Utils.yellow_text('WARNING')}] {message}", file=sys.stderr, end=end, flush=flush)
    @staticmethod
    def print_error(message, end="\n", flush=True):
        print(f"[ModGen][{Utils.red_text('ERROR')}] {message}", file=sys.stderr, end=end, flush=flush)

    @staticmethod
    def print_success(message, end="\n", flush=True):
        print(f"[ModGen][{Utils.green_text('SUCCESS')}] {message}", end=end, flush=flush)

    @staticmethod
    def normalize_name_version(name_version: str) -> str:
        """
        Normalize package spec formats so that `name/version`, `name=version`, `name@version`
        are treated the same. This converts slashes to equal signs and strips
        surrounding whitespace.
        """
        if not isinstance(name_version, str):
            return name_version
        return name_version.strip().replace('=', '/').replace('@', '/').replace('--', '/')

    @staticmethod
    def fetch_remote_build_scripts() -> dict:
        """
        Fetch JSON metadata from a remote http(s) URL

        Returns a name-version to link mapping dictionary.
        """
        url = Config.REMOTE_METADATA_URL
        if not url:
            return {}

        if Utils.remote_build_scripts_links is not None:
            return Utils.remote_build_scripts_links

        normalized = {}

        try:
            with urllib.request.urlopen(url) as resp:
                if url.endswith('.gz'):
                    import gzip
                    with gzip.GzipFile(fileobj=resp) as gz:
                        data = gz.read()
                    metadata = json.loads(data)
                else:
                    data = resp.read()
                    metadata = json.loads(data)

                for k in metadata:
                    rel = Utils.normalize_name_version(k)
                    link = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/{rel}"
                    normalized[rel] = link

        except Exception as e:
            Utils.print_warning(f"Failed to fetch remote metadata from {url}: {e}")
            return {}

        if normalized:
            Utils.remote_build_scripts_links = normalized

        return normalized

    @staticmethod
    def get_local_build_scripts():
        """
        Get a name-version to local script path mapping dictionary.
        """
        if Utils.local_build_scripts_paths is not None:
            return Utils.local_build_scripts_paths

        packages = {}
        if not os.path.isdir(Config.BUILD_SCRIPTS_DIR):
            return packages

        # os.walk mimics 'find' by visiting every subdirectory recursively
        for root, _, files in os.walk(Config.BUILD_SCRIPTS_DIR):
            for filename in files:
                # 1. skip non-build-script files
                if filename.endswith(('.py', '.sh', ".def")):
                    continue

                full_path = os.path.join(root, filename)

                # 2. skip template files
                if "template" in full_path:
                    continue

                # 3. generate key (relative path like 'apps/tool/v1')
                relative_key = os.path.relpath(full_path, Config.BUILD_SCRIPTS_DIR)

                packages[relative_key] = full_path

        Utils.local_build_scripts_paths = packages
        return packages

    @staticmethod
    def download_file(url: str, dest_path: str) -> bool:
        """
        Download a remote file to `dest_path`. Creates parent dirs. Returns True on success.
        """
        try:
            os.makedirs(os.path.dirname(dest_path), mode=0o775, exist_ok=True)
            with urllib.request.urlopen(url) as resp, open(dest_path, 'wb') as out_f:
                out_f.write(resp.read())
            return True
        except Exception as e:
            Utils.print_error(f"Failed to download file from {url}: {e}")
            return False

    @staticmethod
    def download_executable(url: str, dest_path: str) -> bool:
        """
        Download a remote build script to `dest_path`. Creates parent dirs and
        marks the file executable. Returns True on success.
        """
        try:
            return Utils.download_file(url, dest_path) and os.chmod(dest_path, 0o775) is None
        except Exception as e:
            Utils.print_error(f"Failed to download build script from {url}: {e}")
            return False

    @staticmethod
    def get_dependencies_from_script(script_path: str, raise_when_finding_overlay: bool = True) -> List[str]:
        """
        Get dependencies from a build script by parsing #DEP: lines.

        :param script_path: Description
        :type script_path: str
        :return: Description
        :rtype: List[str]
        """
        dependencies = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}")
            return dependencies

        module_load_regex = re.compile(r'^\s*(module\s+load)\s+(.+)$')

        with open(script_path, 'r') as f:
            for line in f:
                if line.startswith("#DEP:"):
                    dep_line = line[len("#DEP:"):].strip()
                    if dep_line.endswith((".sqf", ".img", ".squashfs")):
                        if raise_when_finding_overlay:
                            raise ValueError(f"Overlay dependency {dep_line} is not supported.")
                        Utils.print_warning(f"Overlay dependency {Utils.yellow_text(dep_line)} is not supported. Skipping.")
                        continue
                    else:
                        dependencies.append(Utils.normalize_name_version(dep_line))
                else:
                    line = line.strip()
                    if module_load_regex.match(line):
                        parts = line.split()
                        if len(parts) >= 3:
                            for mod in parts[2:]:
                                dependencies.append(Utils.normalize_name_version(mod))
                    elif line.startswith("ml"):
                        parts = line.split()
                        if len(parts) >= 2:
                            for mod in parts[1:]:
                                if mod in ("purge", "list", "avail", "av"):
                                    break
                                elif mod == "load":
                                    continue
                                dependencies.append(Utils.normalize_name_version(mod))

        dependencies = list(dict.fromkeys(dependencies))  # Remove duplicates while preserving order

        return dependencies

    @staticmethod
    def get_whatis_url_from_build_script(script_path: str, normalized_name_version: str) -> Tuple[str, str]:
        """
        Parse #WHATIS and #URL lines from a build script.

        Example lines in script:
            #WHATIS:Cell Ranger GRCh38 2024-A index
            #URL:https://www.10xgenomics.com/support/software/cell-ranger/downloads#reference-downloads

        Returns:
            (whatis_text, url_text)
            If not found, empty strings are returned.
        """
        package_name, version = normalized_name_version.split('/', 1)
        whatis = f"Load module {package_name} version {version}"
        url = "Not available"

        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}.")
            return whatis, url

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#WHATIS:"):
                    whatis = line[len("#WHATIS:"):].strip()
                elif line.startswith("#URL:"):
                    url = line[len("#URL:"):].strip()

                if whatis and url:
                    break

        return whatis, url

    @staticmethod
    def get_env_dict_from_build_script(script_path) -> Dict[str, Dict[str, str]]:
        """
        Parse #ENV:KEY=VALUE and #ENVNOTE:KEY description lines from build script.
        Returns a dict:
            {
                "KEY": {"value": "VALUE", "note": "description"},
                ...
            }
        Example lines in script:
            #ENV:STAR_INDEX_DIR=$app_root/star
            #ENVNOTE:STAR_INDEX_DIR STAR index dir
        """
        env_dict: Dict[str, Dict[str, str]] = {}

        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}.")
            return env_dict

        with open(script_path, "r") as f:
            lines = f.readlines()
            env_indices = [i for i, line in enumerate(lines) if line.strip().startswith("#ENV:")]

            for env_index in env_indices:
                line = lines[env_index].strip()
                if line.startswith("#ENV:"):
                    # Parse KEY=VALUE
                    content = line[len("#ENV:"):].strip()
                    if "=" not in content:
                        continue
                    key, value = content.split("=", 1)
                    env_dict[key] = {"value": value, "note": ""}

                if env_index + 1 < len(lines):
                    next_line = lines[env_index + 1].strip()
                    if next_line.startswith("#ENVNOTE:"):
                        note = next_line[len("#ENVNOTE:"):].strip()
                        env_dict[key]["note"] = note

        return env_dict

    @staticmethod
    def get_sbatch_args_from_build_script(script_path) -> List[str]:
        """
        Parse #SBATCH: lines from build script.
        Returns a list of sbatch arguments.
        Example line in script:
            #SBATCH --cpus-per-task=4
        """
        sbatch_args = []

        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}.")
            return sbatch_args

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#SBATCH"):
                    arg = line[len("#SBATCH"):].strip()
                    sbatch_args.append(arg)

        return sbatch_args

    @staticmethod
    def get_interactive_prompts(script_path: str) -> List[str]:
        """
        Parse #INTERACTIVE: lines from build script.
        Returns a list of interactive prompt descriptions.
        Example line in script:
            #INTERACTIVE:Please enter the license key
        """
        prompts = []

        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}.")
            return prompts

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#INTERACTIVE:"):
                    prompt = line[len("#INTERACTIVE:"):].strip()
                    prompts.append(prompt)

        return prompts

    @staticmethod
    def share_to_ugo_recursive(path: str):
        """
        Recursively set permissions:
            - Files: ug+rw,o+r
            - Folders: ug+rwx,o+rx
        """
        for root, dirs, files in os.walk(path):
            # Set directories
            for d in dirs:
                dir_path = os.path.join(root, d)
                current_mode = os.stat(dir_path).st_mode
                # Add read/write/execute for user & group
                os.chmod(dir_path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                                            stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                                            stat.S_IROTH | stat.S_IXOTH) 

            # Set files
            for f in files:
                file_path = os.path.join(root, f)
                current_mode = os.stat(file_path).st_mode
                # Add read/write for user & group
                os.chmod(file_path, current_mode | stat.S_IRUSR | stat.S_IWUSR |
                                            stat.S_IRGRP | stat.S_IWGRP| stat.S_IROTH)

        # Finally, handle the top-level directory itself
        current_mode = os.stat(path).st_mode
        os.chmod(path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                                stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                                stat.S_IROTH | stat.S_IXOTH)

    @staticmethod
    def is_in_interactive_shell() -> bool:
        return sys.stdin.isatty() and sys.stdout.isatty()

    @staticmethod
    def is_sbatch_available() -> bool:
        """sbatch is available and we are not inside a SLURM job."""
        return (shutil.which("sbatch") is not None) and ("SLURM_JOB_ID" not in os.environ)

class ModGen:
    @staticmethod
    def ensure_env_modules_or_lmod():
        if (os.environ.get("MODULESHOME") is not None) or Config.IS_LMOD:
            os.makedirs(Config.APPS_MODULEFILES_DIR, mode=0o775, exist_ok=True)
            os.makedirs(Config.REF_MODULEFILES_DIR, mode=0o775, exist_ok=True)
            return
        Utils.print_error("Neither Environment-Modules nor Lmod detected in the environment.")
        Utils.print_message("Please contact your system administrator to install Lmod.")
        exit(1)

    @staticmethod
    def ensure_micromamba():
        if os.path.isfile(Config.MICROMAMBA_BIN):
            return

        os.makedirs(os.path.dirname(Config.MICROMAMBA_BIN), mode=0o775, exist_ok=True)

        system = platform.system()
        if system == "Linux":
            PLATFORM = "linux"
        elif system == "Darwin":
            PLATFORM = "osx"
        elif "NT" in system:
            PLATFORM = "win"
        else:
            raise RuntimeError(f"Unsupported OS: {system}")

        # Detect architecture
        machine = platform.machine()
        if machine in ("aarch64", "ppc64le", "arm64"):
            ARCH = machine
        else:
            ARCH = "64"

        # Supported combinations
        supported = { "linux-aarch64", "linux-ppc64le", "linux-64", "osx-arm64", "osx-64", "win-64" }
        combo = f"{PLATFORM}-{ARCH}"
        if combo not in supported:
            Utils.print_error(f"Unsupported platform-arch combination: {combo}")
            exit(1)

        release_url = f"https://github.com/mamba-org/micromamba-releases/releases/latest/download/micromamba-{combo}"

        Utils.print_message(f"Downloading micromamba for {combo} from {release_url}...")
        if not Utils.download_executable(release_url, Config.MICROMAMBA_BIN):
            Utils.print_error("Failed to download micromamba.")
            exit(1)

        os.chmod(Config.MICROMAMBA_BIN, 0o775)
        Utils.print_success("micromamba installed at " + Config.MICROMAMBA_BIN)

    @staticmethod
    def get_tmp_dir(normalized_name_version: str) -> str:
        relative_path = normalized_name_version.replace('=', "/")
        return os.path.join(Config.TMP_DIR, relative_path)

    @staticmethod
    def get_target_dir(normalized_name_version: str) -> str:
        relative_path = normalized_name_version.replace('=', "/")
        n = relative_path.count('/')
        if n == 0:
            raise ValueError("No / found in normalized name_version.")
        elif n == 1:
            return os.path.join(Config.APPS_DIR, relative_path)
        else:
            return os.path.join(Config.REF_DIR, relative_path)

    @staticmethod
    def get_modulefile_path(normalized_name_version: str) -> str:
        relative_path = normalized_name_version.replace('=', "/")
        n = relative_path.count('/')
        if n == 0:
            raise ValueError("No / found in normalized name_version.")
        elif n == 1:
            return os.path.join(Config.APPS_MODULEFILES_DIR, f"{relative_path}" + ".lua" if Config.IS_LMOD else f"{relative_path}")
        else:
            return os.path.join(Config.REF_MODULEFILES_DIR, f"{relative_path}" + ".lua" if Config.IS_LMOD else f"{relative_path}")

    @staticmethod
    def is_module_available(normalized_name_version: str) -> bool:
        """
        Check if a module is available in the current environment.
        """
        module_name = normalized_name_version.replace('=', '/')
        try:
            result = subprocess.run(["bash", "-c", f"module avail {module_name}"], capture_output=True, text=True)
            output = result.stdout + result.stderr
            return module_name in output
        except Exception:
            return False

    @staticmethod
    def remove_path_and_parents(path: str):
        if os.path.isdir(path):
            shutil.rmtree(path, ignore_errors=True)
        elif os.path.isfile(path):
            os.remove(path)
        base_dir = os.path.dirname(path)
        while base_dir and base_dir != Config.CONDATINER_DIR:
            try:
                os.rmdir(base_dir)
            except OSError:
                break
            base_dir = os.path.dirname(base_dir)

    @staticmethod
    def get_installed_modules(*includes: str) -> Dict[str, str]:
        """
        Get name-version -> file path mapping of installed modules.
        """
        installed_modules = {}
        search_paths = []
        if includes:
            for include in includes:
                if include == "apps":
                    search_paths.append(Config.APPS_MODULEFILES_DIR)
                elif include == "ref":
                    search_paths.append(Config.REF_MODULEFILES_DIR)
        else:
            search_paths = [Config.APPS_MODULEFILES_DIR, Config.REF_MODULEFILES_DIR]
        for modulefiles_dir in search_paths:
            if not os.path.isdir(modulefiles_dir):
                continue
            for root, dirs, files in os.walk(modulefiles_dir):
                for file in files:
                    if Config.IS_LMOD and file.endswith('.lua'):
                        rel_path = os.path.relpath(os.path.join(root, file), modulefiles_dir)
                        name_version = rel_path[:-4]
                        installed_modules[name_version] = os.path.join(root, file)
                    elif not Config.IS_LMOD:
                        rel_path = os.path.relpath(os.path.join(root, file), modulefiles_dir)
                        name_version = rel_path
                        installed_modules[name_version] = os.path.join(root, file)
        return installed_modules

    @staticmethod
    def is_module_installed(normalized_name_version: str) -> bool:
        installed_modules = ModGen.get_installed_modules()
        return normalized_name_version in installed_modules

    @staticmethod
    def get_missing_modules(required_modules: List[str]) -> List[str]:
        installed_modules = ModGen.get_installed_modules()
        missing_modules = [mod for mod in required_modules if mod not in installed_modules and not ModGen.is_module_available(mod)]
        return missing_modules

    @staticmethod
    def remove_module(normalized_name_version: str):
        target_path = ModGen.get_target_dir(normalized_name_version)
        target_modulefile_path = ModGen.get_modulefile_path(normalized_name_version)

        if os.path.isdir(target_path):
            ModGen.remove_path_and_parents(target_path)
            Utils.print_message(f"Removed module directory {Utils.blue_text(target_path)}.")
        if os.path.isfile(target_modulefile_path):
            ModGen.remove_path_and_parents(target_modulefile_path)
            Utils.print_message(f"Removed modulefile {Utils.blue_text(target_modulefile_path)}.")

class BuildObject:
    def __init__(self, name_version: str):
        self.name_version = Utils.normalize_name_version(name_version)
        slash_count = self.name_version.count('/')
        if slash_count == 0:
            raise ValueError(f"Invalid spec '{name_version}'. At least one '/' is required.")
        self.build_script_path = ""
        self.dependencies = []
        self.is_conda = False
        self.is_remote = False
        self.sbatch = False
        self.sbatch_flags = []
        self.is_ref = slash_count > 1
        self.ncpus = Config.NCPUS
        self.interactive_inputs = []

        # related paths
        self.target_path = ModGen.get_target_dir(self.name_version)
        self.target_modulefile_path = ModGen.get_modulefile_path(self.name_version)
        self.tmp_dir_path = ModGen.get_tmp_dir(self.name_version)

        local_scripts = Utils.get_local_build_scripts()
        remote_scripts = Utils.fetch_remote_build_scripts()
        if self.name_version in local_scripts:
            self.build_script_path = local_scripts[self.name_version]
            self.is_remote = False
        elif self.name_version in remote_scripts:
            self.build_script_path = os.path.join(Config.TMP_DIR, self.name_version.replace('/', '--') + ".sh")
            link = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/{self.name_version}"
            if not Utils.download_executable(link, self.build_script_path):
                raise RuntimeError(f"Failed to download remote build script for {self.name_version}.")
            self.is_remote = True
        else:
            self.is_conda = True

        if not self.is_conda:
            self.dependencies = Utils.get_dependencies_from_script(self.build_script_path)
            self.sbatch_flags = Utils.get_sbatch_args_from_build_script(self.build_script_path)
            interactive_prompts = Utils.get_interactive_prompts(self.build_script_path)
            if interactive_prompts and not Utils.is_in_interactive_shell():
                raise RuntimeError(f"Build script for {self.name_version} requires interactive input, but no TTY is available.")
            for prompt in interactive_prompts:
                Utils.print_note("Build script requires input: " +prompt.replace('\\n', '\n'))
                user_input = input("Enter here: ")
                if "\n" in user_input or "\r" in user_input:
                    Utils.print_warning("Multiline input detected. Only the first line will be used.")
                    user_input = user_input.splitlines()[0]
                self.interactive_inputs.append(user_input)
            for flag in self.sbatch_flags:
                if flag.startswith("--cpus-per-task="):
                    try:
                        self.ncpus = int(flag.split("=")[1])
                    except ValueError:
                        pass
            self.sbatch = len(self.sbatch_flags) > 0

    def __str__(self) -> str:
        return f"""BuildObject:
    name_version: {self.name_version}
    is_conda: {self.is_conda}
    build_script_path: {self.build_script_path}
    dependencies: {self.dependencies}
    sbatch_flags: {self.sbatch_flags}
    target_path: {self.target_path}
    target_modulefile_path: {self.target_modulefile_path}
    tmp_dir_path: {self.tmp_dir_path}"""

    @property
    def relative_path(self) -> str:
        return self.name_version

    def is_installed(self) -> bool:
        return ModGen.is_module_installed(self.name_version)

    def create_cleanup(self, failed: bool = False):
        if self.is_remote and os.path.isfile(self.build_script_path):
            os.remove(self.build_script_path)
        if os.path.isdir(self.tmp_dir_path):
            ModGen.remove_path_and_parents(self.tmp_dir_path)
        if failed:
            ModGen.remove_module(self.name_version)

    def get_missing_dependencies(self) -> List[str]:
        return ModGen.get_missing_modules(self.dependencies)

    def _build_conda(self) -> bool:
        if self.is_installed():
            Utils.print_warning(f"Module {Utils.yellow_text(self.name_version)} is already installed. Skipping creation.")
            return True
        if os.path.exists(self.tmp_dir_path):
            Utils.print_error(f"Temporary directory for {Utils.yellow_text(self.name_version)} already exists. Maybe a build is still running?")
            Utils.print_note(f"If you are sure no build is running, please remove the temporary directory at {Utils.blue_text(self.tmp_dir_path)} and try again.")
            return False

        Utils.print_message(f"Building {self.name_version} with packages: {Utils.yellow_text(self.name_version)}" )

        cmd_create = [
            Config.MICROMAMBA_BIN,
            "--root-prefix", Config.CONDA_ROOT_DIR,
            "create", "-y",
            "--channel", "conda-forge", "--channel", "bioconda",
            "--prefix", self.target_path,
            self.name_version.replace('/', '=')
        ]

        Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_create}")
        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating module {self.name_version} failed during conda environment creation.")
            self.create_cleanup(failed=True)
            return False

        whatis_url = ModGen_Create.fetch_whatis_url_from_anaconda(self.name_version)
        os.makedirs(os.path.dirname(self.target_modulefile_path), mode=0o775, exist_ok=True)
        if not ModGen_Create.create_target_modulefile(self.name_version, whatis_url):
            Utils.print_error(f"Failed to generate modulefile for {Utils.yellow_text(self.name_version)}.")
            self.create_cleanup(failed=True)
            return False

        self.create_cleanup(failed=False)
        Utils.print_success(f"Module {Utils.yellow_text(self.name_version)} created.")
        return True

    def _build_script(self, build_deps = False) -> bool:
        if self.is_installed():
            Utils.print_warning(f"Module {Utils.yellow_text(self.name_version)} is already installed. Skipping creation.")
            return True
        if os.path.exists(self.tmp_dir_path):
            Utils.print_error(f"Temporary directory for {Utils.yellow_text(self.name_version)} already exists. Maybe a build is still running?")
            Utils.print_note(f"If you are sure no build is running, please remove the temporary directory at {Utils.blue_text(self.tmp_dir_path)} and try again.")
            return False

        try:
            deps = Utils.get_dependencies_from_script(self.build_script_path, raise_when_finding_overlay=True)
            missing_deps = ModGen.get_missing_modules(deps)
            if missing_deps:
                if build_deps:
                    Utils.print_message(f"Building missing dependencies for {Utils.yellow_text(self.name_version)}: {', '.join(missing_deps)}")
                    for dep in missing_deps:
                        dep_obj = BuildObject(dep)
                        if not dep_obj.build():
                            Utils.print_error(f"Failed to build dependency {Utils.yellow_text(dep)} for {Utils.yellow_text(self.name_version)}.")
                            return False
                    Utils.print_success(f"All dependencies for {Utils.yellow_text(self.name_version)} built successfully.")
                else:
                    Utils.print_error(f"Missing dependencies for {Utils.yellow_text(self.name_version)}: {', '.join(missing_deps)}. Please install them first.")
                return False
        except ValueError as ve:
            Utils.print_error(f"Error parsing dependencies: {ve}")
            return False

        running_env = os.environ.copy()
        running_env["app_name"] = self.name_version.split('/')[0]
        running_env["version"] = self.name_version.split('/')[1]
        running_env["app_name_version"] = self.name_version
        running_env["target_dir"] = self.target_path
        running_env["tmp_dir"] = self.tmp_dir_path
        running_env["SLURM_CPUS_PER_TASK"] = str(self.ncpus)

        if deps:
            ml_commands = "module purge && module load " + " ".join(deps)
            cmd_create = ["bash", "-c", f"{ml_commands} && bash {self.build_script_path}"]
        else:
            cmd_create = ["bash", self.build_script_path]
        
        Utils.print_debug(f"[BUILD] Running build script with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True, env=running_env, input=("\n".join(self.interactive_inputs)+"\n").encode())
        except subprocess.CalledProcessError:
            Utils.print_error(f"Building module {Utils.yellow_text(self.name_version)} failed during build script execution.")
            Utils.print_note(f"Make sure you have run {Utils.blue_text(os.path.basename(Config.SCRIPT_PATH)+' init')} and source the shell configuration file.")
            self.create_cleanup(failed=True)
            return False
        
        whatis_url = Utils.get_whatis_url_from_build_script(self.build_script_path, self.name_version)
        env_dict = Utils.get_env_dict_from_build_script(self.build_script_path)

        Utils.print_debug(f"Creating modulefile at {self.target_modulefile_path}...")
        os.makedirs(os.path.dirname(self.target_modulefile_path), mode=0o775, exist_ok=True)
        if not ModGen_Create.create_target_modulefile(self.name_version, whatis_url, self.is_ref, env_dict):
            Utils.print_error(f"Failed to generate modulefile for {Utils.yellow_text(self.name_version)}.")
            self.create_cleanup(failed=True)
            return False
        
        self.create_cleanup(failed=False)
        Utils.print_success(f"Module {Utils.yellow_text(self.name_version)} created.")
        return True

    def build(self, build_deps = False) -> bool:
        try:
            if self.is_conda:
                return self._build_conda()
            else:
                return self._build_script(build_deps=build_deps)
        except KeyboardInterrupt:
            Utils.print_message(f"Build for {Utils.yellow_text(self.name_version)} interrupted by user.")
            self.create_cleanup(failed=True)
            return False

    def _create_sbatch_script(self) -> bool:
        sbatch_script_path = os.path.join(Config.TMP_DIR, f"sbatch_build_{self.name_version.replace('/', '--')}.sh")
        os.makedirs(Config.LOGS_DIR, mode=0o775, exist_ok=True)
        try:
            with open(sbatch_script_path, 'w') as f:
                f.write("#!/bin/bash\n")
                for flag in self.sbatch_flags:
                    if flag.startswith("--output"):
                        flag = "--output=" + os.path.join(Config.LOGS_DIR, f"CondaTainer_{self.name_version.replace('/', '--')}.out")
                    f.write(f"#SBATCH {flag}\n")
                f.write("\n")
                if Config.debug:
                    f.write(f"/usr/bin/time -v {Config.SCRIPT_PATH} create {self.name_version}\n")
                else:
                    f.write(f"{Config.SCRIPT_PATH} create {self.name_version}\n")
                f.write("echo SLURM_JOB_ID $SLURM_JOB_ID\n")
                f.write("rm -f " + sbatch_script_path + "\n") # Self-delete script after run
            os.chmod(sbatch_script_path, 0o775)
            return True
        except Exception as e:
            Utils.print_error(f"Failed to create sbatch script for {self.name_version}: {e}")
            return False

    def _submit_sbatch(self, dep_ids: List[str]) -> Optional[str]:
        sbatch_script_path = os.path.join(Config.TMP_DIR, f"sbatch_build_{self.name_version.replace('/', '--')}.sh")
        slurm_job_id_regex = re.compile(r'Submitted batch job (\d+)')
        if not self._create_sbatch_script():
            return None

        cmd = ["sbatch", sbatch_script_path]
        if dep_ids:
            dep_str = ":".join(dep_ids)
            cmd.insert(1, f"--dependency=afterok:{dep_str}")
        Utils.print_debug(f"[SBATCH] Submitting sbatch job with command: {cmd}")
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            match = slurm_job_id_regex.search(result.stdout)
            if match:
                job_id = match.group(1)
                if dep_ids:
                    Utils.print_message(f"Submitted sbatch {Utils.blue_text(job_id)} for {Utils.yellow_text(self.name_version)} with dependencies on {Utils.blue_text(', '.join(dep_ids))}.")
                else:
                    Utils.print_message(f"Submitted sbatch {Utils.blue_text(job_id)} for {Utils.yellow_text(self.name_version)}.")
                return job_id
            else:
                Utils.print_error(f"Failed to parse sbatch submission output: {result.stdout}")
                return None
        except subprocess.CalledProcessError as e:
            Utils.print_error(f"Failed to submit sbatch job for {self.name_version}: {e.stderr}")
            return None

class BuildGraph:
    """
    BuildGraph expands given BuildMetadata items to include all transitive
    dependencies, detects cycles, produces a topologically-sorted order
    (dependencies before dependents) and separates items into two ordered
    lists:
      - download_metadata: BuildMetadata with sbatch == False
      - build_metadata: BuildMetadata with sbatch == True
    """

    def __init__(self, build_metadata_list: List[BuildObject]):
        # Use instance attributes (avoid shared mutable class attributes)
        self.graph: Dict[str, BuildObject] = {}
        self.download_metadata: List[BuildObject] = [] # No sbatch
        self.build_metadata: List[BuildObject] = [] # With sbatch
        self._build_job_ids: Dict[str, str] = {}

        # Seed graph with provided metadata
        for metadata in build_metadata_list:
            self.graph[metadata.name_version] = metadata

        # Topologically sort the graph and separate into download/build lists
        visiting = set()
        visited = set()
        order: List[str] = []

        def visit(node: str):
            if node in visited:
                return
            if node in visiting:
                raise RuntimeError(f"Circular dependency detected involving '{node}'")
            visiting.add(node)
            node_meta = self.graph.get(node)
            if node_meta is None:
                visiting.remove(node)
                # Missing node should not normally happen because we expanded graph, but guard against it.
                raise RuntimeError(f"Unknown dependency '{node}' encountered during graph traversal")
            for dep in node_meta.dependencies:
                if dep not in self.graph:
                    # Expand on-the-fly if needed
                    self.graph[dep] = BuildObject(dep)
                visit(dep)
            visiting.remove(node)
            visited.add(node)
            order.append(node)

        for n in list(self.graph.keys()):
            if n not in visited:
                visit(n)

        for name_version in order:
            meta = self.graph[name_version]
            if Config.use_sbatch and meta.sbatch and Utils.is_sbatch_available():
                self.build_metadata.append(meta)
            else:
                self.download_metadata.append(meta)

    def run(self) -> bool:
        if not self._run_local_step():
            return False
        if not self._run_sbatch_step():
            return False
        return True

    def _run_local_step(self) -> bool:
        for metadata in self.download_metadata:
            if ModGen.is_module_installed(metadata.name_version):
                continue
            Utils.print_message(f"Processing module {Utils.yellow_text(metadata.name_version)} (no sbatch)...")
            if not metadata.build():
                Utils.print_error(f"Failed to build module for {Utils.yellow_text(metadata.name_version)}.")
                return False
        return True

    def _run_sbatch_step(self) -> bool:
        for metadata in self.build_metadata:
            Utils.print_message(f"Processing module {Utils.yellow_text(metadata.name_version)} (with sbatch)...")
            dep_ids = []
            for dep in metadata.dependencies:
                if dep in self._build_job_ids:
                    dep_ids.append(self._build_job_ids[dep])
                elif ModGen.is_module_installed(dep):
                    continue
                else:
                    Utils.print_error(f"Dependency {Utils.yellow_text(dep)} for {Utils.yellow_text(metadata.name_version)} is not installed and was not submitted via sbatch.")
                    return False
            job_id = metadata._submit_sbatch(dep_ids)
            if job_id is None:
                Utils.print_error(f"Failed to submit sbatch job for {Utils.yellow_text(metadata.name_version)}.")
                return False
            self._build_job_ids[metadata.name_version] = job_id
        return True

class ModGen_Create:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_Create.parser_create = parser.add_parser(
            "create", aliases=["install", "i"],
            help="Create a modules using conda or available build scripts")
        ModGen_Create.parser_create.add_argument(
            "name_versions",
            nargs="*",
            help="Name/Version or Name=Version or Name@Version to create (e.g., bcftools/1.22)"
        )

    @staticmethod
    def parse_create_args(args):
        if not args.name_versions:
            ModGen_Create.parser_create.error("At least one of name_versions must be provided.")

        ModGen.ensure_micromamba()
        normalized_name_versions = [Utils.normalize_name_version(nv) for nv in args.name_versions]
        build_objects = [BuildObject(nv) for nv in normalized_name_versions]
        build_graph = BuildGraph(build_objects)
        build_graph.run()

    @staticmethod
    def ensure_templates():
        app_temp = Config.APPS_LMOD_TEMPLATE if Config.IS_LMOD else Config.APPS_EM_TEMPLATE
        ref_temp = Config.REF_LMOD_TEMPLATE if Config.IS_LMOD else Config.REF_EM_TEMPLATE

        if os.path.isfile(app_temp) and os.path.isfile(ref_temp):
            return True

        app_temp_rel_path = os.path.relpath(app_temp, Config.CONDATINER_DIR)
        ref_temp_rel_path = os.path.relpath(ref_temp, Config.CONDATINER_DIR)

        app_temp_url = Config.GIT_RAW_URL_PREFIX + app_temp_rel_path.replace('\\', '/')
        ref_temp_url = Config.GIT_RAW_URL_PREFIX + ref_temp_rel_path.replace('\\', '/')

        Utils.print_message(f"Downloading apps and reference modulefile templates...")
        if Utils.download_file(app_temp_url, app_temp) and \
            Utils.download_file(ref_temp_url, ref_temp):
            Utils.print_success("Apps modulefile template downloaded.")
            return True
        else:
            Utils.print_error("Failed to download modulefile templates.")
            return False

    @staticmethod
    def create_target_lmod_modulefile(normalized_name_version: str, whatis_url: Tuple[str, str], is_ref: bool = False, env_dict: Optional[Dict[str, Dict[str, str]]] = None) -> bool:
        template_path = Config.REF_LMOD_TEMPLATE if is_ref else Config.APPS_LMOD_TEMPLATE
        target_modulefile_path = ModGen.get_modulefile_path(normalized_name_version)

        try:
            content = open(template_path, "r").read()
            content = content.replace("{WHATIS}", whatis_url[0])
            content = content.replace("{HELP}", f"Website: {whatis_url[1]}")

            if env_dict:
                env_setting_lines = []
                env_note_lines = []
                env_max_len = max(len(env) for env in env_dict)
                for env in env_dict:
                    if "value" in env_dict[env]:
                        value = env_dict[env]["value"]
                        if "$app_root/" in value:
                            value = value.replace("$app_root/", 'pathJoin(app_root, "') + '")'
                        elif "$app_root" in value:
                            value = value.replace("$app_root", "app_root")
                        else:
                            value = f'"{value}"'
                        env_setting_lines.append(f'setenv("{env}", {value})')

                    if "note" in env_dict[env]:
                        env_note_lines.append(f'    io.stderr:write(\'  {env.ljust(env_max_len)} ({env_dict[env]["note"]})\\n\')')

                if env_setting_lines:
                    content += "\n" + "\n".join(env_setting_lines) + "\n"

                if env_note_lines:
                    # Only print notes on module load
                    env_note_lines.insert(0, 'if mode() == "load" and os.getenv("SLURM_JOB_ID") == nil then')
                    env_note_lines.insert(1, '    io.stderr:write("Available environment variables:\\n")')
                    env_note_lines.append('end')
                    content += "\n" + "\n".join(env_note_lines) + "\n"

            # Write modulefile
            with open(target_modulefile_path, "w") as f:
                f.write(content)

        except Exception as e:
            Utils.print_error(f"Error generating modulefile: {e}")
            return False

        return True

    @staticmethod
    def create_target_em_modulefile(normalized_name_version: str, whatis_url: Tuple[str, str], is_ref: bool = False, env_dict: Optional[Dict[str, Dict[str, str]]] = None) -> bool:
        template_path = Config.REF_EM_TEMPLATE if is_ref else Config.APPS_EM_TEMPLATE
        target_modulefile_path = ModGen.get_modulefile_path(normalized_name_version)
        Utils.print_debug("[CREATE] module type: " + ("ref" if is_ref else "apps") + normalized_name_version + "|" + target_modulefile_path)
        try:
            content = open(template_path, 'r').read()
            content = content.replace("{WHATIS}", whatis_url[0])
            content = content.replace("{HELP}", f"Website: {whatis_url[1]}")

            if env_dict:
                env_setting_lines = []
                env_note_lines = []
                env_max_len = max(len(env) for env in env_dict)
                for env in env_dict:
                    if "value" in env_dict[env]:
                        env_setting_lines.append(f'setenv {env} {env_dict[env]["value"]}')
                    if "note" in env_dict[env]:
                        env_note_lines.append(f'    puts stderr "  {env.ljust(env_max_len)} ({env_dict[env]["note"]})"')

                if env_setting_lines:
                    content = content + "\n" + "\n".join(env_setting_lines) + "\n"

                if env_note_lines:
                    # Only print help if in interactive shell
                    env_note_lines.insert(0, 'if { [module-info mode] == "load" && ![info exists env(SLURM_JOB_ID)] } {')
                    env_note_lines.insert(1, '    puts stderr "Available environment variables:"')
                    env_note_lines.append('}')
                    content = content + "\n" + "\n".join(env_note_lines) + "\n"

            with open(target_modulefile_path, 'w') as f:
                f.write(content)

        except Exception as e:
            Utils.print_error(f"Error generating modulefile: {e}")
            return False

        return True

    @staticmethod
    def create_target_modulefile(normalized_name_version: str, whatis_url: Tuple[str, str], is_ref: bool = False, env_dict: Optional[Dict[str, Dict[str, str]]] = None) -> bool:
        Utils.print_debug(f"[CREATE] Creating modulefile for {normalized_name_version} (is_ref={is_ref}) (is_lmod={Config.IS_LMOD})")
        if Config.IS_LMOD:
            return ModGen_Create.create_target_lmod_modulefile(normalized_name_version, whatis_url, is_ref, env_dict)
        else:
            return ModGen_Create.create_target_em_modulefile(normalized_name_version, whatis_url, is_ref, env_dict)

    @staticmethod
    def fetch_whatis_url_from_anaconda(normalized_name_version: str) -> Tuple[str, str]:
        """
        Fetch the whatis and URL from Anaconda package metadata.
        """
        package_name, version = normalized_name_version.split('/', 1)
        conda_forge_url = f"https://anaconda.org/channels/conda-forge/packages/{package_name}/overview"
        bioconda_url = f"https://anaconda.org/channels/bioconda/packages/{package_name}/overview"

        default_whatis_url = (f"Load module {package_name} version {version}", bioconda_url)

        try:
            import requests
            from bs4 import BeautifulSoup
        except ImportError:
            Utils.print_warning("Required libraries 'requests' and 'beautifulsoup4' not installed.")
            Utils.print_warning("Cannot fetch whatis and url info. Falling back to defaults.")
            return default_whatis_url

        try:
            url = conda_forge_url
            resp = requests.get(url)
            if resp.status_code != 200:
                Utils.print_warning("Cannot fetch whatis and url info. Falling back to defaults.")
                return default_whatis_url
            if "not found" in resp.text.lower():
                url = bioconda_url
                resp = requests.get(url)
                if resp.status_code != 200 or "not found" in resp.text.lower():
                    Utils.print_warning("Cannot fetch whatis and url info. Falling back to defaults.")
                    return default_whatis_url

            soup = BeautifulSoup(resp.text, 'html.parser')

            p = soup.select_one("body > prex-root > prex-package-details > div > div > div > prex-package-overview > div > div.overview-content-cards > div.right-column > kendo-card > kendo-card-body > div:nth-child(1) > p:nth-child(2)")
            if p:
                text = p.get_text()
                # take first line and 150 max
                text = text.split("\n")[0].strip().replace("\t", " ").replace("\"", "").replace("'", "").strip(".")[:150]
                text = text[0].upper() + text[1:]  # Capitalize first letter
                if len(text) == 150:
                    text = text + "..."
                whatis = text
                a = soup.select_one("body > prex-root > prex-package-details > div > div > div > prex-package-overview > div > div.overview-content-cards > div.right-column > kendo-card > kendo-card-body > div:nth-child(6) > a")
                if a:
                    url = str(a['href'])
                return (whatis, url)
            else:
                Utils.print_warning("Cannot fetch whatis and url info. Falling back to defaults.")
                Utils.print_warning(f" The website layout may have changed. Please check the URL manually and update the {Utils.yellow_text('soup.select_one')} selectors accordingly.")
                Utils.print_warning(f"Current URL: {url}")
                return default_whatis_url

        except Exception:
            Utils.print_warning("Cannot fetch whatis and url info. Falling back to defaults.")
            return default_whatis_url

class ModGen_Exec:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_Exec.parser_exec = parser.add_parser(
            "exec", aliases=["e"], 
            help="Execute a command with modules loaded")
        ModGen_Exec.parser_exec.add_argument(
            "-m", "--module",
            dest="modules",
            action="append",
            help="Module(s) to load before executing the command"
        )
        ModGen_Exec.parser_exec.add_argument(
            "-k", "--keep",
            action="store_true",
            help="Do not try to parse command to installed modules"
        )
        ModGen_Exec.parser_exec.add_argument(
            "commands",
            nargs=argparse.REMAINDER,
            help="The command to run inside the container (if not provided, defaults to bash shell)"
        )

    @staticmethod
    def parse_exec_args(args):
        modules_final = []
        command_final = []

        if not args.keep and not args.modules and args.commands:
            for command in args.commands:
                normalized_name_version = Utils.normalize_name_version(command)
                if ModGen.is_module_installed(normalized_name_version) or ModGen.is_module_available(normalized_name_version):
                    modules_final.append(normalized_name_version)
                else:
                    command_final.append(command)
        else:
            command_final = args.commands if args.commands else []

        modules_final.extend(args.modules if args.modules else [])

        ModGen_Exec.exec_command(modules_final, command_final if command_final else ["bash"])

    @staticmethod
    def exec_command(modules: List[str], command: List[str]):
        ml_commands = "module purge && module load " + " ".join(modules)
        safe_command = " ".join([shlex.quote(part) for part in command])
        full_command = f"{ml_commands} && {safe_command}"

        Utils.print_debug(f"[EXEC] Executing command:")
        Utils.print_debug(full_command)

        running_env = os.environ.copy()
        running_env["IN_CONDATINER"] = "1"

        try:
            subprocess.run(["bash", "-c", full_command], check=True, env=running_env)
        except subprocess.CalledProcessError as e:
            Utils.print_error(f"Command execution failed with exit code {e.returncode}.")
            sys.exit(e.returncode)
        except KeyboardInterrupt:
            Utils.print_error("Command execution interrupted by user.")
            sys.exit(1)

class ModGen_Avail:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_Avail.parser_avail = parser.add_parser(
            "avail", aliases=["av"],
            help="Check available local and remote build scripts")
        ModGen_Avail.parser_avail.add_argument(
            "terms",
            type=str,
            nargs="*",
            help="Search terms (AND logic applied)"
        )
        ModGen_Avail.parser_avail.add_argument(
            "-i", "--install",
            "-a", "--add",
            dest="install",
            action="store_true",
            help="Install the selected build scripts (used with terms)"
        )

    @staticmethod
    def parse_avail_args(args):
        local_packages = Utils.get_local_build_scripts()
        # Fetch remote metadata entries if configured
        remote_packages = {}
        if Config.REMOTE_METADATA_URL:
            remote_packages = Utils.fetch_remote_build_scripts()

        installed_modules = ModGen.get_installed_modules()

        added_packages = set()
        all_packages = []
        for p in local_packages.keys():
            if p in installed_modules:
                all_packages.append(f"{p} (installed)")
            else:
                all_packages.append(p)
            added_packages.add(p)
        # add remote-only packages with a marker
        for k in sorted(remote_packages.keys()):
            if k not in added_packages:
                if k in installed_modules:
                    all_packages.append(f"{k} (remote, installed)")
                else:
                    all_packages.append(f"{k} (remote)")
                added_packages.add(k)

        if args.terms:
            # match ONLY packages that contain *all* terms (logical AND)
            filtered_packages = [
                p for p in all_packages
                if all(re.search(re.escape(term), p, re.IGNORECASE) for term in args.terms)
            ]
        else:
            filtered_packages = all_packages

        if not filtered_packages:
            Utils.print_warning("No matching local or remote build scripts found.")
            return

        for pkg in sorted(filtered_packages):
            if args.terms:
                highlighted = pkg
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
                print(highlighted)
            else:
                print(pkg)

        uninstalled_packages = set()
        for pkg in filtered_packages:
            if "installed" in pkg:
                continue
            else:
                uninstalled_packages.add(pkg.split(' ')[0])

        if Utils.is_in_interactive_shell() and args.install and args.terms and uninstalled_packages:
            Utils.print_message("Do you want to install the above modules? [y/N]: ", end="")
            choice = input().strip().lower()
            if choice != 'y':
                return

            ModGen.ensure_micromamba()
            build_objects = [BuildObject(pkg) for pkg in uninstalled_packages]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All selected modules installed successfully.")
            else:
                Utils.print_error("Some modules failed to install.")

class ModGen_List:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_List.parser_list = parser.add_parser(
            "list", aliases=["ls"],
            help="List installed modules matching search terms")
        ModGen_List.parser_list.add_argument(
            "terms",
            type=str,
            nargs="*",
            help="Search terms (AND logic applied)"
        )
        ModGen_List.parser_list.add_argument(
            "-d", "--delete",
            "-r", "--remove",
            dest="delete",
            action="store_true",
            help="Delete listed modules after confirmation (used with terms)"
        )

    @staticmethod
    def parse_list_args(args):
        if os.path.isdir(Config.APPS_MODULEFILES_DIR):
            installed_modules = ModGen.get_installed_modules("apps")
            name_versions_dict = {}
            for module_name in installed_modules.keys():
                name, version = module_name.split('/', 1)
                if args.terms:
                    if not all(re.search(re.escape(term), module_name, re.IGNORECASE) for term in args.terms):
                        continue
                if name in name_versions_dict:
                    name_versions_dict[name].append(version)
                else:
                    name_versions_dict[name] = [version]

            if name_versions_dict:
                name_col_width = max(len(name) for name in name_versions_dict.keys())
                print("Available app modules:")
                for name in sorted(name_versions_dict.keys()):
                    print(f"{Utils.yellow_text(name.ljust(name_col_width))}: {', '.join(sorted(name_versions_dict[name]))}")

        if os.path.isdir(Config.REF_MODULEFILES_DIR):
            installed_modules = ModGen.get_installed_modules("ref")

            ref_modules = {}
            for module_name in installed_modules.keys():
                if args.terms:
                    if not all(re.search(re.escape(term), module_name, re.IGNORECASE) for term in args.terms):
                        continue
                ref_modules[module_name] = installed_modules[module_name]

            if ref_modules:
                print("Available reference modules:")
                for module_name in sorted(ref_modules.keys()):
                    module_name_display = module_name.replace('=', '/')
                    if args.terms:
                        colored_name = module_name_display
                        for term in args.terms:
                            colored_name = re.sub(
                                re.escape(term),
                                lambda m: Utils.yellow_text(m.group(0)),
                                colored_name,
                                flags=re.IGNORECASE
                            )
                        print(colored_name)
                    else:
                        print(module_name)

        if Utils.is_in_interactive_shell() and args.delete and args.terms:
            print("==================REMOVE==================")
            ModGen_Remove.parse_remove_args(args)

class ModGen_Remove:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_Remove.parser_remove = parser.add_parser(
            "remove", aliases=["rm", "delete", "del"],
            help="Remove installed modules matching search terms")
        ModGen_Remove.parser_remove.add_argument(
            "terms",
            type=str,
            nargs="+",
            help="Search terms (AND logic applied)"
        )

    @staticmethod
    def parse_remove_args(args):
        installed_modules_dict = ModGen.get_installed_modules()
        if not installed_modules_dict:
            Utils.print_warning("No installed modules found.")
            return

        filtered_modules = []
        for module in installed_modules_dict.keys():
            if args.terms:
                if all(re.search(re.escape(term), module, re.IGNORECASE) for term in args.terms):
                    filtered_modules.append(module)
            else:
                filtered_modules.append(module)

        if not filtered_modules:
            Utils.print_warning("No matching installed modules found.")
            return

        print("Modules to be removed:")
        for module in sorted(filtered_modules):
            highlighted = module
            if args.terms:
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
            print(f" - {highlighted}")

        Utils.print_message("Are you sure? Cannot be undone. [y/N]: ", end="")
        choice = input().strip().lower()
        if choice != 'y':
            return

        for module in filtered_modules:
            ModGen.remove_module(module)

class ModGen_Check:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_Check.parser_check = parser.add_parser(
            "check", aliases=["c"],
            help="Check if the dependencies of a script are installed")
        ModGen_Check.parser_check.add_argument(
            "script",
            type=str,
            help="Path to the script to check"
        )
        ModGen_Check.parser_check.add_argument(
            "-a", "--auto-install",
            "-i", "--install",
            dest="auto_install",
            action="store_true",
            help="Automatically install missing dependencies"
        )

    @staticmethod
    def parse_check_args(args):
        script_path_or_name = args.script
        is_remote = False
        if not os.path.isfile(script_path_or_name):
            script_path_or_name = Utils.normalize_name_version(script_path_or_name)
            local_build_scripts = Utils.get_local_build_scripts()
            Utils.print_debug(f"[CHECK] Checking for build script {script_path_or_name} locally and remotely...")
            if script_path_or_name in local_build_scripts:
                script_path = local_build_scripts[script_path_or_name]
                Utils.print_message(f"Found local build script {Utils.blue_text(script_path)}")
            elif script_path_or_name in Utils.fetch_remote_build_scripts():
                Utils.print_message(f"Downloading build script for {script_path_or_name} from remote metadata...")
                is_remote = True
                url = Utils.fetch_remote_build_scripts()[script_path_or_name]
                script_path = os.path.join(Config.CONDATINER_DIR, f"{script_path_or_name.replace('/', '--')}.sh")
                if Utils.download_executable(url, script_path):
                    Utils.print_message(f"Downloaded build script to {Utils.blue_text(script_path)}")
                else:
                    Utils.print_error(f"Failed to download build script for {script_path_or_name} from {url}.")
                    return
            else:
                Utils.print_error(f"Build script for {script_path_or_name} not found.")
                return
        else:
            script_path = script_path_or_name

        deps = Utils.get_dependencies_from_script(script_path, raise_when_finding_overlay=False)
        for d in deps:
            Utils.print_message(f"Dependency: {Utils.yellow_text(d)}" + Utils.red_text(" (missing)" if not ModGen.is_module_installed(d) and not ModGen.is_module_available(d) else ""))
        missing_deps = ModGen.get_missing_modules(deps)

        if not missing_deps:
            Utils.print_message("All dependencies are installed.")
            if is_remote and os.path.isfile(script_path):
                os.remove(script_path)
            return

        if args.auto_install:
            Utils.print_message("Attempting to auto-install missing dependencies...")
            for md in missing_deps:
                if md.endswith(('.sqf', '.img', '.squashfs')):
                    Utils.print_error(f"ModGen is not compatible with overlay dependencies. Please use CondaTainer instead.")
                    continue
            ModGen.ensure_micromamba()
            build_objects = [BuildObject(md) for md in missing_deps]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All missing dependencies installed successfully.")
            else:
                Utils.print_error("Some dependencies failed to install.")
        else:
            Utils.print_message(f"Run the command again with {Utils.blue_text('-a')} or {Utils.blue_text('--auto-install')} to install missing dependencies.")

        if is_remote and os.path.isfile(script_path):
            os.remove(script_path)

class ModGen_Run:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_Run.parser_run = parser.add_parser(
            "run", aliases=["r"], 
            help="Run a script and auto-solve the dependencies by #DEP tags")
        ModGen_Run.parser_run.add_argument(
            "script",
            type=str,
            help="Path to the script to run"
        )
        ModGen_Run.parser_run.add_argument(
            "-w", "--writable-img",
            help="Placeholder for CondaTainer compatibility (no effect)",
            action="store_true"
        )
        ModGen_Run.parser_run.add_argument(
            "-a", "--auto-install",
            "-i", "--install",
            dest="auto_install",
            help="Automatically install missing dependencies",
            action="store_true"
        )
        ModGen_Run.parser_run.add_argument(
            "script_args",
            nargs=argparse.REMAINDER,
            help="Arguments to pass to the script"
        )

    @staticmethod
    def parse_args_in_script(script_path: str) -> List[str]:
        args = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Script file {script_path} not found.")
            return args

        with open(script_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith("#CNT"):
                    arg_line = line[len("#CNT"):].strip()
                    args.append(arg_line)
        return args

    @staticmethod
    def parse_run_args(args):
        script_path = args.script
        if not os.path.isfile(script_path):
            ModGen_Run.parser_run.error(f"Script file {script_path} not found.")
        script_args = args.script_args

        args_from_script = ModGen_Run.parse_args_in_script(args.script)
        merged = args_from_script + sys.argv[2:]
        args = ModGen_Run.parser_run.parse_args(merged)

        try:
            deps = Utils.get_dependencies_from_script(script_path, raise_when_finding_overlay=True)
        except ValueError as ve:
            Utils.print_error(ve)
            Utils.print_message("ModGen is not compatible with overlay dependencies. Please use CondaTainer instead.")
            return
        missing_deps = ModGen.get_missing_modules(deps)

        if missing_deps:
            if not args.auto_install:
                Utils.print_message("Missing dependencies:")
                for md in missing_deps:
                    Utils.print_message(f"  - {Utils.yellow_text(md)}")

                Utils.print_message(f"Please run {Utils.blue_text(Config.SCRIPT_NAME + ' check -a')} to install missing dependencies.")
                return

            ModGen.ensure_micromamba()
            Utils.print_message("Attempting to auto-install missing dependencies...")
            build_objects = [BuildObject(md) for md in missing_deps]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All missing dependencies installed successfully.")
            else:
                Utils.print_error("Some dependencies failed to install.")
                return

        ModGen_Exec.exec_command(deps, ["/bin/bash", script_path] + script_args)

class ModGen_Init:
    module_yes = False
    conda_yes = False

    @staticmethod
    def add_parser_arguments(parser):
        ModGen_Init.parser_init = parser.add_parser("init", help="Initialize ModGen environment")
        ModGen_Init.parser_init.add_argument(
            "-m", "--modules",
            action="store_true",
            help="Add module use paths to shell profile"
        )
        ModGen_Init.parser_init.add_argument(
            "-c", "--conda",
            action="store_true",
            help="Initialize Micromamba Conda environment"
        )

    @staticmethod
    def parse_init_args(args):
        if args.modules:
            ModGen_Init.module_yes = True
            ModGen_Init.add_use_modules_to_shell()
        if args.conda:
            ModGen_Init.conda_yes = True
            ModGen_Init.micromamba_shell_init()
        if not args.modules and not args.conda:
            ModGen_Init.add_use_modules_to_shell()
            ModGen_Init.micromamba_shell_init()

    @staticmethod
    def micromamba_shell_init():
        ModGen.ensure_micromamba()

        if not Utils.is_in_interactive_shell():
            return False

        if not ModGen_Init.conda_yes:
            Utils.print_message("ModGen can run without micromamba initialization.")
            Utils.print_message("If you want to create another conda environment in the future, you can set root to the ModGen conda root to save space.")
            Utils.print_message("Are you sure to initialize micromamba shell integration? [y/N]: ", end='', flush=True)
            response = input()
            if response.strip().lower() not in ('y', 'yes'):
                return False

        shell_type = os.path.basename(os.environ.get("SHELL", "bash"))
        cmd_init = [Config.MICROMAMBA_BIN, "shell", "init", "-s", shell_type, "-r", Config.CONDA_ROOT_DIR]

        Utils.print_debug("[MICROMAMBA] Initializing micromamba shell with command:")
        Utils.print_debug(cmd_init)

        try:
            subprocess.run(cmd_init, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Micromamba shell initialization failed.")
            return False
        Utils.print_success("Micromamba initialized.")
        return True

    @staticmethod
    def add_use_modules_to_shell():
        if not Utils.is_in_interactive_shell():
            return False

        Utils.print_message("Lmod detected." if Config.IS_LMOD else "Environment Modules (Tcl) detected.")
        Utils.print_debug(f"[INIT] Checking shell profile for ModGen configuration...")

        shell_stype = os.path.basename(os.environ.get("SHELL", "bash"))

        if shell_stype == "bash":
            shell_profile = os.path.expanduser("~/.bashrc")
        elif shell_stype == "zsh":
            shell_profile = os.path.expanduser("~/.zshrc")
        else:
            Utils.print_warning(f"Unsupported shell type: {shell_stype}. Only bash and zsh are supported for automatic initialization.")
            return False
        START_MARKER = "# >>> MODGEN MODULES >>>"
        END_MARKER = "# <<< MODGEN MODULES <<<"

        if Config.IS_LMOD:
            detect = '[ -f "$LMOD_CMD" ]'
        else:
            detect = '[ -n "$MODULESHOME" ] && [ -f "$MODULESHOME/libexec/modulecmd.tcl" ]'

        new_block_content = f"""{START_MARKER}
# Use ModGen modulefiles (Only if 'module' command is available)
if {detect} && [ -d "{Config.CONDATINER_DIR}" ]; then
    module use {Config.APPS_MODULEFILES_DIR}
    module use {Config.REF_MODULEFILES_DIR}
fi
{END_MARKER}"""

        if not os.path.exists(shell_profile):
            content = ""
        else:
            with open(shell_profile, 'r') as f:
                content = f.read()

        start_idx = content.find(START_MARKER)
        end_idx = content.find(END_MARKER)

        # Check if a valid block exists (start found, end found, and end is after start)
        block_exists = (start_idx != -1) and (end_idx != -1) and (end_idx > start_idx)

        action_needed = False
        current_block_end_idx = 0 # To store where the old block ends

        if block_exists:
            # Extract the exact current block from the file
            current_block_end_idx = end_idx + len(END_MARKER)
            current_block = content[start_idx:current_block_end_idx]

            # Compare (ignoring surrounding whitespace for safety)
            if current_block.strip() == new_block_content.strip():
                Utils.print_message(f"ModGen configuration already up-to-date in {shell_profile}.")
                return True
            else:
                Utils.print_message(f"Detected outdated ModGen block in {shell_profile}.")
                action_needed = "update"
        else:
            Utils.print_message(f"ModGen block not found in {shell_profile}.")
            action_needed = "append"

        # 5. User Confirmation
        if not ModGen_Init.module_yes:
            prompt_msg = "Are you sure to update/add 'module use' commands to your shell profile? [Y/n]: "
            response = input(prompt_msg)
            if response.strip().lower() not in ('y', 'yes', ''):
                return False

        # 6. Execute Write
        try:
            if action_needed == "update":
                # Slice the string: Keep everything before start + New Block + Everything after end
                new_file_content = content[:start_idx] + new_block_content + content[current_block_end_idx:]

                with open(shell_profile, 'w') as f:
                    f.write(new_file_content)
                Utils.print_success(f"Updated ModGen configuration in {shell_profile}.")

            elif action_needed == "append":
                with open(shell_profile, 'a') as f:
                    # Ensure a newline exists before appending if the file isn't empty
                    prefix = "\n" if content and not content.endswith("\n") else ""
                    f.write(prefix + new_block_content + "\n")
                Utils.print_success(f"Added ModGen configuration to {shell_profile}.")

            Utils.print_message("Please restart your shell or source the profile.")
            return True

        except Exception as e:
            Utils.print_message(f"Error writing to {shell_profile}: {e}")
            return False

class ModGen_Update:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_Update.parser_update = parser.add_parser("update", help="Update ModGen to the latest version")
        ModGen_Update.parser_update.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm update"
        )

    @staticmethod
    def parse_update_args(args):
        if not args.yes:
            Utils.print_message("Are you sure to download and replace the current script from GitHub? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Update cancelled by user.")
                return

        Utils.print_message("Downloading the latest ModGen script...")
        if Utils.download_executable(Config.MODGEN_URL, Config.SCRIPT_PATH + ".tmp"):
            os.chmod(Config.SCRIPT_PATH + ".tmp", 0o775)
            shutil.move(Config.SCRIPT_PATH + ".tmp", Config.SCRIPT_PATH)
            Utils.print_success("ModGen updated.")
        else:
            Utils.print_error("Failed to download the latest ModGen script.")

class ModGen_CondaTainer:
    @staticmethod
    def add_parser_arguments(parser):
        ModGen_CondaTainer.parser_condatainer = parser.add_parser("condatainer", help="Install CondaTainer")
        ModGen_CondaTainer.parser_condatainer.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm installation"
        )
        ModGen_CondaTainer.parser_condatainer.add_argument(
            "-f", "--force",
            action="store_true",
            help="Force overwrite if CondaTainer is already installed"
        )

    @staticmethod
    def parse_condatainer_args(args):
        if not Utils.is_in_interactive_shell():
            return

        Utils.print_message(f"{Utils.blue_text('CondaTainer')}: Use apptainer/conda/squashFS to manage tools for HPC users.")
        Utils.print_message(f"Which is another way to manage software environments compared to {Utils.blue_text('ModGen')}.")
        Utils.print_message(f"Conda env tends to have a lot of small files, so {Utils.blue_text('ModGen')} will quickly {Utils.yellow_text('exceed the file number quota')}.")
        Utils.print_message(f"{Utils.blue_text('CondaTainer')} uses SquashFS overlays to reduce file number and improve performance.")
        print("", flush=True)

        target_path = os.path.join(os.path.dirname(Config.SCRIPT_PATH), "condatainer")
        if os.path.isfile(target_path) and not args.force:
            Utils.print_message(f"CondaTainer is already installed at {Utils.blue_text(target_path)}.")
            Utils.print_message("Overwrite? [y/N]: ", end="", flush=True)
            if not args.yes:
                confirm = input()
                if confirm.lower() != 'y':
                    Utils.print_message("Installation cancelled by user.")
                    return

        if not args.force and not args.yes:
            Utils.print_message("Are you sure to install CondaTainer? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Installation cancelled by user.")
                return

        Utils.print_message("Downloading CondaTainer...")
        if Utils.download_executable(Config.CONDATAINER_URL, target_path):
            Utils.print_success("CondaTainer installed.")
        else:
            Utils.print_error("Failed to download CondaTainer.")

if __name__ == "__main__":
    try:
        main()
    except RuntimeError as rte:
        Utils.print_note(str(rte))
        sys.exit()
    except ValueError as e:
        Utils.print_error(str(e))
        sys.exit(1)
    except Exception as e:
        Utils.print_error(f"An unexpected error occurred: {str(e)}")
        sys.exit(1)
    except KeyboardInterrupt:
        Utils.print_message("ModGen interrupted by user.")
        sys.exit(1)
