#!/usr/bin/env python3
import os
import sys
import subprocess
import re
import shutil
import argparse
import json
import urllib.request
import platform
import stat
from pathlib import Path
from typing import Dict, List, Optional, Tuple

os.umask(0o002)

class Config:
    VERSION = "1.0.1"
    # Remote settings
    debug = False
    GITHUB_REPO = "Justype/condatainer"
    REMOTE_METADATA_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/metadata/build-scripts.json.gz"
    MODGEN_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/bin/modgen"
    CONDATAINER_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/bin/condatainer"
    GIT_RAW_URL_PREFIX = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/"

    # Folder paths
    SCRIPT_PATH = os.path.abspath(__file__)
    SCRIPT_NAME = os.path.basename(SCRIPT_PATH)
    PROGRAM_DIR = os.path.dirname(SCRIPT_PATH)
    CONDATINER_DIR = os.path.abspath(os.path.join(PROGRAM_DIR, ".."))

    BUILD_SCRIPTS_DIR = os.path.join(CONDATINER_DIR, "build-scripts")
    IMAGES_DIR = os.path.join(CONDATINER_DIR, "images")
    REF_IMAGES_DIR = os.path.join(CONDATINER_DIR, "ref-images")
    CNT_DIR = os.path.join(CONDATINER_DIR, "cnt")

    # Local apptainer
    LOCAL_APPTAINER_DIR = os.path.join(CONDATINER_DIR, "apptainer")
    LOCAL_APPTAINER_BIN = os.path.join(LOCAL_APPTAINER_DIR, "bin", "apptainer")
    LOCAL_MICROMAMBA_BIN = os.path.join(CONDATINER_DIR, "bin", "micromamba")

    # File paths
    TMP_OVERLAY_PATH = os.path.join(CONDATINER_DIR, "tmp.img")
    BASE_IMAGE_DEF = os.path.join(BUILD_SCRIPTS_DIR, "base_image.def")
    BASE_IMAGE_SIF = os.path.join(IMAGES_DIR, "base_image.sif")
    APPTAINER_PATH = shutil.which("apptainer") # Not compatible with singularity anymore
    BAD_CHARS_REGEX = re.compile(r'[<>:"/\\|?*\0\s\'`$&;|!\[\]#%@=+{}(),]')

    # Utils
    NCPUS = os.environ.get("SLURM_CPUS_PER_TASK", 4)
    GZIP_FAST = "-comp gzip -Xcompression-level 3"
    GZIP = "-comp gzip"
    ZSTD_FAST = "-comp zstd -Xcompression-level 3"
    ZSTD_MEDIUM = "-comp zstd -Xcompression-level 8"
    ZSTD = "-comp zstd -Xcompression-level 14"
    LZ4 = "-comp lz4"
    compress_args = LZ4

def main():
    parser = argparse.ArgumentParser(description="CondaTainer: Use apptainer/conda/squashFS to manage tools for HPC users.")
    parser.add_argument("-v", "--version", action="version", version=Config.VERSION, help="Show the version of CondaTainer", default=argparse.SUPPRESS)
    parser.add_argument("--debug", action="store_true", help="Enable debug mode with verbose output")
    subparsers = parser.add_subparsers(dest="action", metavar="COMMAND", required=True, help="Available actions")

    CondaTainer_Overlay.add_parser_arguments(subparsers)
    CondaTainer_Create.add_parser_arguments(subparsers)
    CondaTainer_Avail.add_parser_arguments(subparsers)
    CondaTainer_List.add_parser_arguments(subparsers)
    CondaTainer_Remove.add_parser_arguments(subparsers)
    CondaTainer_Exec.add_parser_arguments(subparsers)
    CondaTainer_Check.add_parser_arguments(subparsers)
    CondaTainer_Run.add_parser_arguments(subparsers)
    CondaTainer_Info.add_parser_arguments(subparsers)
    CondaTainer_Apptainer.add_parser_arguments(subparsers)
    CondaTainer_Update.add_parser_arguments(subparsers)
    CondaTainer_ModGen.add_parser_arguments(subparsers)

    args = parser.parse_args()

    if args.debug:
        Config.debug = True
        Utils.print_debug("Debug mode enabled")
        Utils.print_debug(f"CondaTainer Version: {Config.VERSION}")

    if args.action in ("create", "install", "i"):
        CondaTainer_Create.parse_create_args(args)
    elif args.action == "exec":
        CondaTainer_Exec.parse_exec_args(args)
    elif args.action == "e":
        CondaTainer_Exec.parse_e_args(args)
    elif args.action in ("check", "c"):
        CondaTainer_Check.parse_check_args(args)
    elif args.action in ("run", "r"):
        CondaTainer_Run.parse_run_args(args)
    elif args.action == "info":
        CondaTainer_Info.parse_info_args(args)
    elif args.action in ("avail", "av"):
        CondaTainer_Avail.parse_avail_args(args)
    elif args.action in ("list", "ls"):
        CondaTainer_List.parse_list_args(args)
    elif args.action in ("remove", "delete", "uninstall"):
        CondaTainer_Remove.parse_remove_args(args)
    elif args.action in ("overlay", "o"):
        CondaTainer_Overlay.parse_overlay_args(args)
    elif args.action == "apptainer":
        CondaTainer_Apptainer.parse_apptainer_args(args)
    elif args.action == "update":
        CondaTainer_Update.parse_update_args(args)
    elif args.action == "modgen":
        CondaTainer_ModGen.parse_modgen_args(args)

class Utils:
    remote_build_scripts_links: Optional[Dict[str, str]] = None
    local_build_scripts_paths: Optional[Dict[str, str]] = None

    @staticmethod
    def blue_text(text):
        return f"\033[94m{text}\033[0m"

    @staticmethod
    def red_text(text):
        return f"\033[91m{text}\033[0m"

    @staticmethod
    def yellow_text(text):
        return f"\033[93m{text}\033[0m"

    @staticmethod
    def green_text(text):
        return f"\033[92m{text}\033[0m"

    @staticmethod
    def print_message(message, end="\n", flush=True):
        print(f"[CondaTainer] {message}", end=end, flush=flush)

    @staticmethod
    def print_debug(debug_object, end="\n", flush=True):
        if Config.debug:
            print(f"[CondaTainer][{Utils.yellow_text('DEBUG')}]", end=" ", flush=True)
            print(debug_object, end=end, flush=flush)

    @staticmethod
    def print_note(message, end="\n", flush=True):
        print(f"[CondaTainer][{Utils.blue_text('NOTE')}] {message}", end=end, flush=flush)

    @staticmethod
    def print_warning(message, end="\n", flush=True):
        print(f"[CondaTainer][{Utils.yellow_text('WARNING')}] {message}", file=sys.stderr, end=end, flush=flush)
    @staticmethod
    def print_error(message, end="\n", flush=True):
        print(f"[CondaTainer][{Utils.red_text('ERROR')}] {message}", file=sys.stderr, end=end, flush=flush)

    @staticmethod
    def print_success(message, end="\n", flush=True):
        print(f"[CondaTainer][{Utils.green_text('SUCCESS')}] {message}", end=end, flush=flush)

    @staticmethod
    def normalize_name_version(name_version: str) -> str:
        """
        Normalize package spec formats so that `name/version`, `name=version`, `name@version`
        are treated the same. This converts slashes to equal signs and strips
        surrounding whitespace.
        """
        if not isinstance(name_version, str):
            return name_version
        return name_version.strip().replace('=', '/').replace('@', '/').replace('--', '/')

    @staticmethod
    def fetch_remote_build_scripts() -> dict:
        """
        Fetch JSON metadata from a remote http(s) URL

        Returns a name-version to link mapping dictionary.
        """
        url = Config.REMOTE_METADATA_URL
        if not url:
            return {}

        if Utils.remote_build_scripts_links is not None:
            return Utils.remote_build_scripts_links

        normalized = {}

        try:
            with urllib.request.urlopen(url) as resp:
                if url.endswith('.gz'):
                    import gzip
                    with gzip.GzipFile(fileobj=resp) as gz:
                        data = gz.read()
                    metadata = json.loads(data)
                else:
                    data = resp.read()
                    metadata = json.loads(data)

                for k in metadata:
                    rel = Utils.normalize_name_version(k)
                    link = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/{rel}"
                    normalized[rel] = link

        except Exception as e:
            Utils.print_warning(f"Failed to fetch remote metadata from {url}: {e}")
            return {}

        if normalized:
            Utils.remote_build_scripts_links = normalized

        return normalized

    @staticmethod
    def get_local_build_scripts():
        """
        Get a name-version to local script path mapping dictionary.
        """
        if Utils.local_build_scripts_paths is not None:
            return Utils.local_build_scripts_paths
        packages = {}
        if not os.path.isdir(Config.BUILD_SCRIPTS_DIR):
            # No local build-scripts directory â€” behave as if there are no local scripts
            return packages
        try:
            script_paths = os.listdir(Config.BUILD_SCRIPTS_DIR)
        except Exception:
            return packages
        script_paths = sorted(script_paths)
        for script_dir in script_paths:
            if script_dir == "0-template":
                continue
            script_path = os.path.join(Config.BUILD_SCRIPTS_DIR, script_dir)
            if not os.path.isdir(script_path):
                continue

            versions = os.listdir(script_path)
            versions = [v for v in versions if not (v.startswith("template") or v.endswith("_data"))]
            if len(versions) == 0:
                continue

            # dir: ref
            if os.path.isdir(os.path.join(script_path, versions[0])):
                for data_type in versions:
                    data_type_path = os.path.join(script_path, data_type)
                    sub_versions = os.listdir(data_type_path)
                    for version in sub_versions:
                        if version.startswith("template") or version.endswith(('.sh', '.py')):
                            continue
                        packages[f"{script_dir}/{data_type}/{version}"] = os.path.join(data_type_path, version)
            else: # file: apps
                for version in versions:
                    if version.startswith("template") or version.endswith(('.sh', '.py')):
                        continue
                    packages[f"{script_dir}/{version}"] = os.path.join(script_path, version)

        Utils.local_build_scripts_paths = packages
        return packages

    @staticmethod
    def download_file(url: str, dest_path: str) -> bool:
        """
        Download a remote file to `dest_path`. Creates parent dirs. Returns True on success.
        """
        try:
            os.makedirs(os.path.dirname(dest_path), mode=0o775, exist_ok=True)
            with urllib.request.urlopen(url) as resp, open(dest_path, 'wb') as out_f:
                out_f.write(resp.read())
            return True
        except Exception as e:
            Utils.print_error(f"Failed to download file from {url}: {e}")
            return False

    @staticmethod
    def download_executable(url: str, dest_path: str) -> bool:
        """
        Download a remote build script to `dest_path`. Creates parent dirs and
        marks the file executable. Returns True on success.
        """
        try:
            return Utils.download_file(url, dest_path) and os.chmod(dest_path, 0o775) is None
        except Exception as e:
            Utils.print_error(f"Failed to download build script from {url}: {e}")
            return False

    @staticmethod
    def get_dependencies_from_script(script_path: str) -> List[str]:
        """
        Get dependencies from a build script by parsing #DEP: lines.

        :param script_path: Description
        :type script_path: str
        :return: Description
        :rtype: List[str]
        """
        dependencies = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}")
            return dependencies

        module_load_regex = re.compile(r'^\s*(module\s+load)\s+(.+)$')

        with open(script_path, 'r') as f:
            for line in f:
                if line.startswith("#DEP:"):
                    dep_line = line[len("#DEP:"):].strip()
                    if dep_line.endswith((".sqf", ".img", ".squashfs")):
                        dependencies.append(dep_line)
                    else:
                        dependencies.append(Utils.normalize_name_version(dep_line))
                else:
                    line = line.strip()
                    if module_load_regex.match(line):
                        parts = line.split()
                        if len(parts) >= 3:
                            for mod in parts[2:]:
                                dependencies.append(Utils.normalize_name_version(mod))
                    elif line.startswith("ml"):
                        parts = line.split()
                        if len(parts) >= 2:
                            for mod in parts[1:]:
                                if mod in ("purge", "list", "avail", "av"):
                                    break
                                elif mod == "load":
                                    continue
                                dependencies.append(Utils.normalize_name_version(mod))

        dependencies = list(dict.fromkeys(dependencies))  # Remove duplicates while preserving order

        return dependencies

    @staticmethod
    def share_to_ugo_recursive(path: str):
        """
        Recursively set permissions:
            - Files: ug+rw,o+r
            - Folders: ug+rwx,o+rx
        """
        for root, dirs, files in os.walk(path):
            # Set directories
            for d in dirs:
                dir_path = os.path.join(root, d)
                current_mode = os.stat(dir_path).st_mode
                # Add read/write/execute for user & group
                os.chmod(dir_path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                                            stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                                            stat.S_IROTH | stat.S_IXOTH) 

            # Set files
            for f in files:
                file_path = os.path.join(root, f)
                current_mode = os.stat(file_path).st_mode
                # Add read/write for user & group
                os.chmod(file_path, current_mode | stat.S_IRUSR | stat.S_IWUSR |
                                            stat.S_IRGRP | stat.S_IWGRP| stat.S_IROTH)

        # Finally, handle the top-level directory itself
        current_mode = os.stat(path).st_mode
        os.chmod(path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                                stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                                stat.S_IROTH | stat.S_IXOTH)

    @staticmethod
    def is_in_interactive_shell() -> bool:
        return sys.stdin.isatty() and sys.stdout.isatty()

class CondaTainer:
    @staticmethod
    def ensure_apptainer():
        if Config.APPTAINER_PATH is None:
            Utils.print_error("Apptainer not found in PATH.")
            Utils.print_note(f"Make sure you load the Apptainer module in your HPC system.")
            Utils.print_note(f"Please consider running: {Utils.blue_text('ml apptainer')}")
            Utils.print_note("If there is no Apptainer module, please contact your system administrator.")
            return False
        return True

    @staticmethod
    def ensure_base_def():
        base_def_path = Config.BASE_IMAGE_DEF
        if os.path.isfile(base_def_path):
            return True

        Utils.print_message("Base image definition file not found.")

        choice = "cpu"
        if Utils.is_in_interactive_shell():
            Utils.print_message("Select base image type to download:")
            Utils.print_message("  1) CPU-only (default)")
            Utils.print_message("  2) NVIDIA GPU support")
            Utils.print_message("  3) AMD GPU support")
            user_input = input("Enter choice [1-3]: ").strip()
            if user_input == "2":
                choice = "nv"
            elif user_input == "3":
                choice = "amd"
            else:
                Utils.print_warning("Invalid choice. Defaulting to CPU-only base image.")
        else:
            Utils.print_message("Non-interactive shell detected. Defaulting to CPU-only base image.")

        url_insert = ""
        if choice != "cpu":
            url_insert = f"_{choice}"

        url = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/base_image{url_insert}.def"
        if not Utils.download_file(url, base_def_path):
            Utils.print_error("Failed to download base image definition file.")
            return False
        return True


    @staticmethod
    def ensure_base_image():
        """
        Exit the program if the base image does not exist, after attempting to build it.
        """
        os.makedirs(Config.IMAGES_DIR, mode=0o775, exist_ok=True)
        os.makedirs(Config.REF_IMAGES_DIR, mode=0o775, exist_ok=True)

        if os.path.isfile(Config.LOCAL_APPTAINER_BIN):
            Config.APPTAINER_PATH = Config.LOCAL_APPTAINER_BIN
            Utils.print_message(f"Using local Apptainer binary at {Config.APPTAINER_PATH}")

        if not CondaTainer.ensure_apptainer():
            exit(1)
        if os.path.isfile(Config.BASE_IMAGE_SIF):
            return
        if not CondaTainer.ensure_base_def():
            exit(1)

        Utils.print_message("Base images not found. Building base images...")
        cmd = [
            Config.APPTAINER_PATH, "build",
            "--fakeroot",
            Config.BASE_IMAGE_SIF,
            Config.BASE_IMAGE_DEF,
        ]
        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Building base images failed.")
            exit(1)
        Utils.print_success("Base images built.")
        cmd = [ Config.APPTAINER_PATH, "cache", "clean", "--force" ]
        subprocess.run(cmd, capture_output=True)
        os.chmod(Config.BASE_IMAGE_SIF, 0o775)
        Utils.print_message("Apptainer cache cleaned.")

    @staticmethod
    def create_tmp_overlay():
        if os.path.isfile(Config.TMP_OVERLAY_PATH):
            os.remove(Config.TMP_OVERLAY_PATH)

        Utils.print_message("Creating temporary SquashFS overlay...")
        cmd = [
            Config.APPTAINER_PATH, "overlay", "create",
            "--sparse", "--size", "15360", "--fakeroot", 
            Config.TMP_OVERLAY_PATH
        ]

        Utils.print_debug(f"[CREATE] Creating temporary overlay with command: {cmd}")

        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Creating temporary overlay failed.")
            Utils.print_note("Please contact your system admin.")
            Utils.print_note("You can try ModGen to create Lmod modules without apptainer and overlays.")
            return False
        Utils.print_message("Temporary overlay created.")
        return True

    @staticmethod
    def remove_tmp_overlay():
        if os.path.isfile(Config.TMP_OVERLAY_PATH):
            os.remove(Config.TMP_OVERLAY_PATH)
            Utils.print_message("Temporary overlay removed.")
        return True

    @staticmethod
    def get_installed_overlays() -> Dict[str, str]:
        """
        Get name-version -> file path mapping of installed overlays.
        """
        overlays = {}
        if not os.path.isdir(Config.IMAGES_DIR):
            return overlays

        overlay_files = [f for f in os.listdir(Config.IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
        for overlay in overlay_files:
            name_version = os.path.splitext(overlay)[0]
            name_version = name_version.replace("--", "/")
            overlays[name_version] = os.path.join(Config.IMAGES_DIR, overlay)

        ref_overlay_files = [f for f in os.listdir(Config.REF_IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
        for overlay in ref_overlay_files:
            name_version = os.path.splitext(overlay)[0]
            name_version = name_version.replace("--", "/")
            overlays[name_version] = os.path.join(Config.REF_IMAGES_DIR, overlay)
        return overlays

    @staticmethod
    def check_overlay_installed(name_version_or_path: str) -> bool:
        if name_version_or_path.endswith(('.sqf', '.img', '.squashfs')):
            return os.path.isfile(name_version_or_path)
        installed_overlays = CondaTainer.get_installed_overlays().keys()
        return name_version_or_path in installed_overlays

    @staticmethod
    def get_missing_overlays(name_versions_or_paths: List[str]) -> List[str]:
        missing = []
        installed_overlays = CondaTainer.get_installed_overlays().keys()
        for nv in name_versions_or_paths:
            if nv.endswith(('.sqf', '.img', '.squashfs')):
                if not os.path.isfile(nv):
                    missing.append(nv)
            elif nv not in installed_overlays:
                missing.append(nv)
        return missing

    @staticmethod
    def generate_bind_args(*paths: Optional[str]) -> List[str]:
        """
        Accept multiple paths and return a list of absolute paths
        with --bind parameters suitable for binding in Singularity.

        Rules:
        - Resolve to absolute paths
        - Keep only one if multiple paths are the same
        - Skip paths that are children of another path
        """
        # Resolve all paths to absolute, normalized Path objects
        abs_paths = [Path(p).resolve() for p in paths if p] + [Path.home(), Path(".").resolve()]

        if os.environ.get("SCRATCH"):
            abs_paths.append(Path(os.environ["SCRATCH"]).resolve())

        # Remove duplicates
        unique_paths = []
        for p in abs_paths:
            if p not in unique_paths:
                unique_paths.append(p)

        # Filter out child paths
        final_paths = []
        for p in unique_paths:
            if not any(parent != p and p.is_relative_to(parent) for parent in unique_paths):
                final_paths.append(p)

        final_params = []
        for p in final_paths:
            final_params.extend(["--bind", str(p)])
        return final_params

    @staticmethod
    def generate_gpu_args() -> List[str]:
        params = []
        if shutil.which("nvidia-smi") or any("nvidia" in path.lower() for path in os.listdir("/dev")):
            params.extend(["--nv"])
        if shutil.which("rocm-smi"):
            params.extend(["--rocm"])
        return params

class CondaTainer_Create:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Create.parser_create = parser.add_parser(
            "create", aliases=["install", "i"],
            help="Create a new SquashFS overlay using conda or available build scripts")
        CondaTainer_Create.parser_create.add_argument(
            "name_versions",
            nargs="*",
            help="Name/Version or Name=Version or Name@Version to create (e.g., bcftools/1.22)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-n", "--name",
            type=str,
            help="Custom name for the overlay file (If used, all packages will be included in a single overlay)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-p", "--prefix",
            type=str,
            help="Custom prefix for the overlay file"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-f", "--file",
            type=str,
            help="Conda environment yaml (use with --name or --prefix)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-fast",
            action="store_true",
            help="Use zstd compression level 3" + (" (default)" if Config.compress_args == Config.ZSTD_FAST else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-medium",
            action="store_true",
            help="Use zstd compression level 8" + (" (default)" if Config.compress_args == Config.ZSTD_MEDIUM else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd",
            action="store_true",
            help="Use zstd compression level 14" + (" (default)" if Config.compress_args == Config.ZSTD else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--gzip",
            action="store_true",
            help="Use gzip compression" + (" (default)" if Config.compress_args == Config.GZIP else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--lz4",
            action="store_true",
            help="Use LZ4 compression" + (" (default)" if Config.compress_args == Config.LZ4 else "")
        )

    @staticmethod
    def parse_create_args(args):
        CondaTainer.ensure_base_image()
        if not args.name_versions and not args.file:
            CondaTainer_Create.parser_create.error("At least one of name_versions or --file must be provided.")
        if args.name_versions and args.file:
            CondaTainer_Create.parser_create.error("Cannot use both NAME=VERSION items and --file at the same time")
        if args.prefix and args.name:
            CondaTainer_Create.parser_create.error("Cannot use both --prefix and --name at the same time")
        if args.file and not (args.name or args.prefix):
            CondaTainer_Create.parser_create.error("When using --file, either --name or --prefix must be provided")
        if args.lz4:
            Config.compress_args = Config.LZ4
        elif args.zstd_fast:
            Config.compress_args = Config.ZSTD_FAST
        elif args.zstd_medium:
            Config.compress_args = Config.ZSTD_MEDIUM
        elif args.zstd:
            Config.compress_args = Config.ZSTD
        elif args.gzip:
            Config.compress_args = Config.GZIP

        if args.name_versions:
            args.name_versions = [Utils.normalize_name_version(nv) for nv in args.name_versions]

        try:
            if os.path.isfile(Config.TMP_OVERLAY_PATH):
                Utils.print_error("A temporary overlay already exists. Maybe another process is running CondaTainer create?")
                Utils.print_message("If you are sure there is no other process running, please delete the temporary overlay file:")
                Utils.print_message(f"  rm {Config.TMP_OVERLAY_PATH}")
                exit(1)

            if args.file:
                if args.prefix:
                    CondaTainer_Create.create_sqf_from_file(args.file, prefix=args.prefix)
                else:
                    CondaTainer_Create.create_sqf_from_file(args.file, args.name)
            else:
                if args.name:
                    if Config.BAD_CHARS_REGEX.search(args.name):
                        CondaTainer_Create.parser_create.error("The custom name contains invalid characters. Avoid using spaces and special characters like <>:\"/\\|?*`$&;|![]#%@=+{}(),")
                        exit(1)
                    if "--" in args.name:
                        CondaTainer_Create.parser_create.error("The custom name cannot contain '--' sequence.")
                        exit(1)
                    # Create a single overlay with all packages
                    packages = args.name_versions
                    overlay_filepath = f"{args.name}.sqf"
                    overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filepath)
                    relative_path = args.name.replace("--", "/")
                    if os.path.isfile(overlay_path):
                        Utils.print_message(f"Overlay {Utils.yellow_text(overlay_filepath)} already exists at {Utils.blue_text(overlay_path)}. Skipping creation.")
                        return

                    CondaTainer_Create.create_sqf_using_conda(
                        packages=packages,
                        overlay_path=overlay_path,
                        relative_path=relative_path
                    )
                elif args.prefix:
                    prefix_name = os.path.basename(args.prefix)
                    if Config.BAD_CHARS_REGEX.search(prefix_name):
                        CondaTainer_Create.parser_create.error("The custom prefix contains invalid characters. Avoid using spaces and special characters like <>:\"/\\|?*`$&;|![]#%@=+{}(),")
                        exit(1)

                    prefix_abs_path = os.path.abspath(args.prefix)
                    os.makedirs(os.path.dirname(prefix_abs_path), mode=0o775, exist_ok=True)

                    # Create a single overlay with all packages, using the prefix
                    packages = args.name_versions
                    overlay_path = f"{prefix_abs_path}.sqf"
                    relative_path = prefix_name.replace("--", "/")
                    if os.path.isfile(overlay_path):
                        Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(overlay_path))} already exists at {Utils.blue_text(overlay_path)}. Skipping creation.")
                        return

                    CondaTainer_Create.create_sqf_using_conda(
                        packages=packages,
                        overlay_path=overlay_path,
                        relative_path=relative_path
                    )

                else:
                    normalized_name_versions = [Utils.normalize_name_version(nv) for nv in args.name_versions]
                    if normalized_name_versions and any('/' not in nv for nv in normalized_name_versions):
                        CondaTainer_Create.parser_create.error("Must specify the versions in the format NAME/VERSION")
                    # Create individual overlays for each package
                    for nv in normalized_name_versions:
                        CondaTainer_Create.auto_create_overlay_from_str(nv)
        except RuntimeError as rte:
            Utils.print_note(str(rte))
            sys.exit()
        except KeyboardInterrupt:
            Utils.print_message("Process interrupted by user. Cleaning up...")
            CondaTainer.remove_tmp_overlay()
            shutil.rmtree(Config.CNT_DIR, ignore_errors=True)
            exit(1)

    @staticmethod
    def generate_config_yaml_content(name, packages: List[str]) -> str:
        content = f"name: {name}\n"
        content += "channels:\n"
        content += "  - conda-forge\n"
        content += "  - bioconda\n"
        content += "dependencies:\n"
        for pkg in packages:
            content += f"  - {pkg}\n"
        return content

    @staticmethod
    def create_sqf_using_conda(packages: List[str], overlay_path: str, relative_path) -> bool:
        Utils.print_message(f"Building SquashFS overlay at {Utils.blue_text(overlay_path)} with packages: {Utils.yellow_text(' '.join(packages))}")

        CondaTainer.create_tmp_overlay()

        yaml_path = os.path.join(Config.CONDATINER_DIR, "tmp_env.yaml")
        with open(yaml_path, 'w') as f:
            f.write(CondaTainer_Create.generate_config_yaml_content(relative_path.replace("/", "--"), packages))
        yaml_file_cmd = f"mv {os.path.abspath(yaml_path)} /cnt/{relative_path}/env.yaml"

        cmd_create = [
            Config.APPTAINER_PATH, "exec",
            "--fakeroot",
            "--env", "TMPDIR=/ext3/tmp",
            "--overlay", Config.TMP_OVERLAY_PATH,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            mkdir -p $TMPDIR
            micromamba create -r /ext3/conda -c conda-forge -c bioconda -y -p /cnt/{relative_path} {' '.join(packages)}

            {yaml_file_cmd}

            # Set permissions to ensure read access
            find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
            find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
            mksquashfs /cnt {os.path.abspath(overlay_path)} -processors {Config.NCPUS} -keep-as-directory {Config.compress_args} -b 1M
            """
        ]

        Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating {Utils.blue_text(overlay_path)} failed.")
            Utils.print_note(f"If apptainer cannot recognize zstd, please run f`{Config.SCRIPT_NAME} apptainer` to get the latest version.")
            Utils.print_note("If file/folder creation failed, please contact your system admin.")
            Utils.print_note("If cannot find the package. Please search the package on https://anaconda.org")
            CondaTainer.remove_tmp_overlay()
            return False

        Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(overlay_path))} created at {Utils.blue_text(overlay_path)}. Removing temporary overlay...")
        os.chmod(overlay_path, 0o664)
        CondaTainer.remove_tmp_overlay()
        return True

    @staticmethod
    def create_sqf_from_file(file_path: str, custom_name: Optional[str] = None, prefix: Optional[str] = None):
        if not file_path.endswith(('.yml', '.yaml')):
            Utils.print_error("The environment file must be in YAML format with .yml or .yaml extension.")
            return False

        file_path = os.path.abspath(file_path)
        file_basedir = os.path.dirname(file_path)

        Utils.print_message(f"Building SquashFS overlay from environment file {Utils.blue_text(file_path)}")
        if prefix:
            prefix_abs_path = os.path.abspath(prefix)
            os.makedirs(os.path.dirname(prefix_abs_path), mode=0o775, exist_ok=True)

            overlay_abs_path = f"{prefix_abs_path}.sqf"
            custom_name = os.path.basename(prefix)
            relative_path = custom_name.replace("--", "/")
        elif custom_name:
            overlay_abs_path = os.path.join(Config.IMAGES_DIR, f"{custom_name}.sqf")
            relative_path = custom_name.replace("--", "/")
        else:
            Utils.print_error("Either custom name or prefix must be provided when creating overlay from environment file.")
            return False

        if os.path.isfile(overlay_abs_path):
            Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} already exists at {Utils.blue_text(overlay_abs_path)}. Skipping creation.")
            return True
        CondaTainer.create_tmp_overlay()

        cmd_create = [
            Config.APPTAINER_PATH, "exec",
            "--fakeroot",
            "--env", "TMPDIR=/ext3/tmp",
            "--overlay", Config.TMP_OVERLAY_PATH,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR, file_basedir),
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            mkdir -p $TMPDIR
            micromamba create -r /ext3/conda -c conda-forge -c bioconda -y -p /cnt/{relative_path} -f {file_path}

            cp {file_path} /cnt/{relative_path}/env.yaml

            # Set permissions to ensure read access
            find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
            find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
            mksquashfs /cnt {os.path.abspath(overlay_abs_path)} -processors {Config.NCPUS} -keep-as-directory {Config.compress_args} -b 1M
            """
        ]

        Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating {Utils.blue_text(overlay_abs_path)} from {Utils.blue_text(file_path)} failed.")
            Utils.print_note(f"If apptainer cannot recognize zstd, please run `{Config.SCRIPT_NAME} apptainer` to get the latest version.")
            Utils.print_note("If file/folder creation failed, please contact your system admin.")
            Utils.print_note("If cannot resolve the environment file by libmamba, please please consider create img and manually install it with conda.")
            CondaTainer.remove_tmp_overlay()
            return False

        Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} created from {Utils.blue_text(file_path)}. Removing temporary overlay...")
        os.chmod(overlay_abs_path, 0o664)
        CondaTainer.remove_tmp_overlay()
        return True

    @staticmethod
    def get_env_dict_from_build_script(script_path) -> Dict[str, Dict[str, str]]:
        """
        Parse #ENV:KEY=VALUE and #ENVNOTE:KEY description lines from build script.
        Returns a dict:
            {
                "KEY": {"value": "VALUE", "note": "description"},
                ...
            }
        Example lines in script:
            #ENV:STAR_INDEX_DIR=$app_root/star
            #ENVNOTE:STAR_INDEX_DIR STAR index dir
        """
        env_dict: Dict[str, Dict[str, str]] = {}

        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}.")
            return env_dict

        with open(script_path, "r") as f:
            lines = f.readlines()
            env_indices = [i for i, line in enumerate(lines) if line.strip().startswith("#ENV:")]

            for env_index in env_indices:
                line = lines[env_index].strip()
                if line.startswith("#ENV:"):
                    # Parse KEY=VALUE
                    content = line[len("#ENV:"):].strip()
                    if "=" not in content:
                        continue
                    key, value = content.split("=", 1)
                    env_dict[key] = {"value": value, "note": ""}

                if env_index + 1 < len(lines):
                    next_line = lines[env_index + 1].strip()
                    if next_line.startswith("#ENVNOTE:"):
                        note = next_line[len("#ENVNOTE:"):].strip()
                        env_dict[key]["note"] = note

        return env_dict

    @staticmethod
    def get_sbatch_args_from_build_script(script_path) -> List[str]:
        """
        Parse #SBATCH: lines from build script.
        Returns a list of sbatch arguments.
        Example line in script:
            #SBATCH --cpus-per-task=4
        """
        sbatch_args = []

        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}.")
            return sbatch_args

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#SBATCH"):
                    arg = line[len("#SBATCH"):].strip()
                    sbatch_args.append(arg)

        return sbatch_args

    @staticmethod
    def submit_sbatch(normalized_name_version: str,  sbatch_args: List[str]) -> bool:
        """
        Generate a temporary sbatch script to run the build script with sbatch.
        Returns the path to the temporary sbatch script.
        """
        tmp_sbatch_script_path = os.path.join(Config.CONDATINER_DIR, f"sbatch_build_tmp.sh") # after submission, SLURM will create its own copy
        with open(tmp_sbatch_script_path, "w") as f:
            f.write("#!/bin/bash\n")
            for arg in sbatch_args:
                f.write(f"#SBATCH {arg}\n")
            f.write("\n")
            f.write(f"{Config.SCRIPT_PATH} create {normalized_name_version}\n")

        cmd_final = ["sbatch", tmp_sbatch_script_path]
        Utils.print_debug(f"[CREATE] Submitting sbatch job with command: {cmd_final}")

        try:
            subprocess.run(cmd_final, check=True)
            return True
        except subprocess.CalledProcessError:
            return False

    @staticmethod
    def create_app_overlay(name: str, version: str):
        """
        Check if the script exists locally or remotely,
        - if yes, use build script,
        - if not, use micromamba installer.
        """
        overlay_filename = f"{name}--{version}.sqf"
        overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)
        relative_path = f"{name}/{version}"
        if os.path.isfile(overlay_path):
            Utils.print_message(f"Overlay {Utils.yellow_text(overlay_filename)} already exists at {Utils.blue_text(overlay_path)}. Skipping creation.")
            return True

        local_packages = Utils.get_local_build_scripts().keys()
        remote_packages = Utils.fetch_remote_build_scripts().keys()
        avail_packages = set(local_packages).union(set(remote_packages))
        if f"{name}/{version}" not in avail_packages:
            return CondaTainer_Create.create_sqf_using_conda(
                packages=[f"{name}={version}"],
                overlay_path=overlay_path,
                relative_path=relative_path
            )
        else:
            return CondaTainer_Create.create_app_overlay_from_build_script(name, version)

    @staticmethod
    def auto_create_overlay_from_str(name_version: str) -> bool:
        # Accept both name=version and name/version formats by normalizing
        name_version = Utils.normalize_name_version(name_version)
        if '/' not in name_version:
            Utils.print_error("Must specify the version in the format NAME/VERSION")
            return False

        n = name_version.count('/')
        if n == 1:
            name, version = name_version.split('/', 1)
            return CondaTainer_Create.create_app_overlay(name, version)
        elif n == 2:
            assembly, data_type, version = name_version.split('/', 2)
            return CondaTainer_Create.create_ref_overlay_from_build_script(assembly, data_type, version)
        else:
            Utils.print_error("Too many '/' characters in the NAME/VERSION string.")
            return False

    @staticmethod
    def create_app_overlay_from_build_script(name: str, version: str):
        overlay_filename = f"{name}--{version}.sqf"
        overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)
        relative_path = f"{name}/{version}"
        if os.path.isfile(overlay_path):
            Utils.print_message(f"Overlay {Utils.yellow_text(overlay_filename)} already exists at {Utils.blue_text(overlay_path)}. Skipping creation.")
            return True

        is_remote = False
        script_path = os.path.join(Config.BUILD_SCRIPTS_DIR, name, version)
        if not os.path.isfile(script_path):
            # Try to fetch build script from remote metadata if configured
            metadata = Utils.fetch_remote_build_scripts()
            key = Utils.normalize_name_version(f"{name}/{version}")
            if metadata and key in metadata:
                is_remote = True
                script_path = os.path.join(Config.CONDATINER_DIR, f"{key.replace('/', '--')}.sh")
                Utils.print_message(f"Downloading build script for {name}/{version} from remote metadata...")
                url = metadata[key]
                if Utils.download_executable(url, script_path):
                    Utils.print_message(f"Downloaded build script to {Utils.blue_text(script_path)}")
                else:
                    Utils.print_error(f"Failed to download build script for {name}/{version} from {url}.")
                    return False
            else:
                Utils.print_error(f"Build script for {name} version {version} not found at {Utils.blue_text(script_path)}.")
                return False

        sbatch_args = CondaTainer_Create.get_sbatch_args_from_build_script(script_path)
        if sbatch_args and shutil.which("sbatch") and Utils.is_in_interactive_shell():
            Utils.print_note("This script requires SLURM sbatch to run. Submitting job...")
            if CondaTainer_Create.submit_sbatch(Utils.normalize_name_version(f"{name}/{version}"), sbatch_args):
                raise RuntimeError("Build script submitted successfully. Exiting current process. Please monitor the sbatch job for completion. And the log is under current directory.")
            else:
                Utils.print_error("Submitting sbatch job failed.")
                return False

        Utils.print_message(f"Building SquashFS overlay for {name} version {version} using build script.")

        CondaTainer.create_tmp_overlay()

        cmd_create = [
            Config.APPTAINER_PATH, "exec",
            "--fakeroot",
            "--env", "TMPDIR=/ext3/tmp",
            "--env", "tmp_dir=/ext3/tmp",
            "--env", f"target_dir=/cnt/{relative_path}",
            "--env", f"app_name={name}",
            "--env", f"version={version}",
            "--env", f"app_name_version={name}/{version}",
            "--overlay", Config.TMP_OVERLAY_PATH,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            mkdir -p $TMPDIR
            bash {script_path}

            if [ $? -ne 0 ]; then
                echo "Build script for {name} version {version} failed."
                exit 1
            fi

            # Set permissions to ensure read access
            find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
            find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
            mksquashfs /cnt {os.path.abspath(overlay_path)} -processors {Config.NCPUS} -keep-as-directory {Config.compress_args} -b 1M
            """
        ]

        Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating {Utils.blue_text(overlay_path)} failed.")
            Utils.print_note(f"If apptainer cannot recognize zstd, please run `{Config.SCRIPT_NAME} apptainer` to get the latest version.")
            Utils.print_note("If file/folder creation failed, please contact your system admin.")
            Utils.print_note("Some build script needs an interactive shell to accept download links or licenses.")
            CondaTainer.remove_tmp_overlay()
            return False

        if not os.path.isfile(overlay_path):
            Utils.print_error(f"Error occurred during Overlay {Utils.blue_text(overlay_path)} creation.")
            CondaTainer.remove_tmp_overlay()
            return False

        env_settings = CondaTainer_Create.get_env_dict_from_build_script(script_path)
        if env_settings:
            env_file_path = os.path.splitext(overlay_path)[0] + ".env"
            with open(env_file_path, 'w') as f:
                for env in env_settings:
                    value = env_settings[env]["value"].replace('$app_root', f"/cnt/{name}/{version}")
                    f.write(f"{env}={value}\n")
                    note = env_settings[env].get("note", "")
                    if note:
                        f.write(f"#ENVNOTE:{env}={note}\n")
            Utils.print_message(f"Environment variables file created at {Utils.blue_text(env_file_path)}")
            os.chmod(env_file_path, 0o664)

        Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(overlay_path))} created at {Utils.blue_text(overlay_path)}. Removing temporary overlay...")
        os.chmod(overlay_path, 0o664)
        CondaTainer.remove_tmp_overlay()
        if is_remote and os.path.isfile(script_path):
            os.remove(script_path)
        return True

    @staticmethod
    def ref_install_cleanup():
        shutil.rmtree(Config.CNT_DIR, ignore_errors=True)
        CondaTainer.remove_tmp_overlay()

    @staticmethod
    def create_ref_overlay_from_build_script(assembly: str, data_type: str, version: str):
        overlay_filename = f"{assembly}--{data_type}--{version}.sqf"
        overlay_path = os.path.join(Config.REF_IMAGES_DIR, overlay_filename)
        relative_path = f"{assembly}/{data_type}/{version}"

        if os.path.isfile(overlay_path):
            Utils.print_message(f"Reference overlay {Utils.yellow_text(overlay_filename)} already exists at {Utils.blue_text(overlay_path)}. Skipping creation.")
            return True

        is_remote = False
        script_path = os.path.join(Config.BUILD_SCRIPTS_DIR, assembly, data_type, version)
        if not os.path.isfile(script_path):
            # Try to fetch reference build script from remote metadata if configured
            metadata = Utils.fetch_remote_build_scripts()
            key = Utils.normalize_name_version(f"{assembly}/{data_type}/{version}")
            if metadata and key in metadata:
                is_remote = True
                script_path = os.path.join(Config.CONDATINER_DIR, f"{key.replace('/', '--')}.sh")
                Utils.print_message(f"Downloading reference build script for {assembly}/{data_type}/{version} from remote metadata...")
                url = metadata[key]
                if not Utils.download_executable(url, script_path):
                    Utils.print_error(f"Failed to download reference build script for {assembly}/{data_type}/{version} from {url}.")
                    return False
                Utils.print_message(f"Downloaded reference build script to {Utils.blue_text(script_path)}")
            else:
                Utils.print_error(f"Build script for reference {assembly} {data_type} version {version} not found at {Utils.blue_text(script_path)}.")
                return False

        deps = Utils.get_dependencies_from_script(script_path)
        missing_deps = CondaTainer.get_missing_overlays(deps)

        if os.path.exists(Config.CNT_DIR):
            Utils.print_warning(f"Temporary cnt directory {Config.CNT_DIR} already exists. Removing it first...")
            shutil.rmtree(Config.CNT_DIR, ignore_errors=True)

        if missing_deps:
            for md in missing_deps:
                if md.endswith(('.sqf', '.img', '.squashfs')):
                    Utils.print_error(f"Custom overlay {Utils.yellow_text(md)} is missing. Cannot proceed with creating this overlay.")
                    return False
                Utils.print_message(f"Dependency overlay {Utils.yellow_text(md)} is missing. Creating it first...")
                if CondaTainer_Create.auto_create_overlay_from_str(md):
                    Utils.print_success(f"Dependency overlay {Utils.yellow_text(md)} created.")
                else:
                    Utils.print_error(f"Failed to create dependency overlay {Utils.yellow_text(md)}.")
                    return False

        sbatch_args = CondaTainer_Create.get_sbatch_args_from_build_script(script_path)
        if sbatch_args and shutil.which("sbatch") and Utils.is_in_interactive_shell():
            Utils.print_note("This script requires SLURM sbatch to run. Submitting job...")
            if CondaTainer_Create.submit_sbatch(Utils.normalize_name_version(f"{assembly}/{data_type}/{version}"), sbatch_args):
                raise RuntimeError("Build script submitted successfully. Exiting current process. Please monitor the sbatch job for completion. And the log is under current directory.")
            else:
                Utils.print_error("Submitting sbatch job failed.")
                return False

        Utils.print_message(f"Building reference SquashFS overlay for {assembly} {data_type} version {version} using build script.")

        target_dir = os.path.join(Config.CNT_DIR, relative_path)

        CondaTainer.create_tmp_overlay()
        cmd_create = [
            Config.APPTAINER_PATH, "exec",
            "--fakeroot",
            "--env", "TMPDIR=/ext3/tmp",
            "--env", "tmp_dir=/ext3/tmp",
            "--env", f"target_dir={target_dir}",
            "--env", f"app_name={assembly}/{data_type}",
            "--env", f"version={version}",
            "--env", f"app_name_version={assembly}/{data_type}/{version}",
            "--env", "script_path=/dev/null",  # Prevent build script from downloading dependencies again
            "--env", f"PATH={CondaTainer_Exec.get_path_env(deps)}",
            *CondaTainer_Exec.generate_overlay_args(deps),
            "--overlay", Config.TMP_OVERLAY_PATH,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *CondaTainer_Exec.get_overlay_env_configs(deps),
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            mkdir -p $TMPDIR
            bash {script_path}
            """
        ]

        Utils.print_debug(f"[CREATE] with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating reference overlay {overlay_path} failed.")
            CondaTainer_Create.ref_install_cleanup()
            return False

        if os.listdir(target_dir) == []:
            Utils.print_error(f"Reference overlay build script did not create any files in {Utils.blue_text(target_dir)}.")
            CondaTainer_Create.ref_install_cleanup()
            return False
        
        Utils.share_to_ugo_recursive(Config.CNT_DIR) # Ensure permissions before creating SquashFS

        Utils.print_message(f"Creating SquashFS file at {Utils.blue_text(overlay_path)}...")
        cmd_mksqf = [
            Config.APPTAINER_PATH, "exec",
            "--fakeroot",
            "--overlay", Config.TMP_OVERLAY_PATH,
            "--bind", Config.CONDATINER_DIR,
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            mksquashfs {Config.CNT_DIR} {os.path.abspath(overlay_path)} -processors {Config.NCPUS} -keep-as-directory {Config.compress_args} -b 1M
            """
        ]

        Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_mksqf}")

        try:
            subprocess.run(cmd_mksqf, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating SquashFS file {Utils.blue_text(overlay_path)} failed.")
            Utils.print_note(f"If apptainer cannot recognize zstd, please run `{Config.SCRIPT_NAME} apptainer` to get the latest version.")
            Utils.print_note("If file/folder creation failed, please contact your system admin.")
            CondaTainer_Create.ref_install_cleanup()
            return False

        env_settings = CondaTainer_Create.get_env_dict_from_build_script(script_path)
        if env_settings:
            env_file_path = os.path.splitext(overlay_path)[0] + ".env"
            with open(env_file_path, 'w') as f:
                for env in env_settings:
                    value = env_settings[env]["value"].replace('$app_root', f"/cnt/{assembly}/{data_type}/{version}")
                    f.write(f"{env}={value}\n")
                    note = env_settings[env].get("note", "")
                    if note:
                        f.write(f"#ENVNOTE:{env}={note}\n")
            Utils.print_message(f"ENV file created at {Utils.blue_text(env_file_path)}")
            os.chmod(env_file_path, 0o664)

        Utils.print_success(f"Reference created at {Utils.blue_text(overlay_path)}. Cleaning up...")
        os.chmod(overlay_path, 0o664)
        CondaTainer_Create.ref_install_cleanup()
        if is_remote and os.path.isfile(script_path):
            os.remove(script_path)
        return True

class CondaTainer_Exec:
    is_img_writable = False

    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Exec.parser_exec = parser.add_parser("exec", help="Execute a command using overlays")
        CondaTainer_Exec.parser_exec.add_argument(
            "-o", "--overlay",
            dest="overlays",
            action="append",
            help="Overlay (can be used multiple times)"
        )
        CondaTainer_Exec.parser_exec.add_argument(
            "-k", "--keep",
            action="store_true",
            help="Do not try to parse command to installed overlays"
        )
        CondaTainer_Exec.parser_exec.add_argument(
            "-w", "--writable-img",
            help="Make .img overlays writable (default: read-only)",
            action="store_true"
        )
        CondaTainer_Exec.parser_exec.add_argument(
            "commands",
            nargs=argparse.REMAINDER,
            help="The command to run inside the container (if not provided, defaults to bash shell)"
        )
        CondaTainer_Exec.parser_e = parser.add_parser("e", help="Run bash using writable overlays")
        CondaTainer_Exec.parser_e.add_argument(
            "overlays",
            nargs="*",
            help="Overlay files to mount (can be .sqf, .squashfs, or .img)"
        )

    @staticmethod
    def parse_exec_args(args):
        CondaTainer.ensure_base_image()
        CondaTainer_Exec.is_img_writable = args.writable_img

        installed_overlays = CondaTainer.get_installed_overlays()

        overlay_final = []
        command_final = []

        if not args.keep and not args.overlays and args.commands:
            Utils.print_debug("[EXEC] Parsing commands to separate overlays and command...")
            for command in args.commands:
                if command.endswith(('.sqf', '.img', '.squashfs')):
                    overlay_final.append(command)
                elif Utils.normalize_name_version(command) in installed_overlays:
                    Utils.print_warning(f"Convert command {Utils.yellow_text(command)} to overlay")
                    overlay_final.append(command)
                else:
                    command_final.append(command)
        else:
            command_final = args.commands if args.commands else []

        overlay_final.extend(args.overlays if args.overlays else [])
        command_final = command_final if command_final else ["bash"]

        for ov in overlay_final:
            if not os.path.isfile(ov):
                Utils.print_error(f"Overlay file {ov} not found.")
                exit(1)

        CondaTainer_Exec.exec_command(overlay_final, command_final)

    @staticmethod
    def parse_e_args(args):
        CondaTainer.ensure_base_image()
        CondaTainer_Exec.is_img_writable = True

        overlay_final = args.overlays if args.overlays else []
        command_final = ["bash"]

        for ov in overlay_final:
            if not os.path.isfile(ov):
                Utils.print_error(f"Overlay file {ov} not found.")
                exit(1)

        CondaTainer_Exec.exec_command(overlay_final, command_final)

    @staticmethod
    def get_overlay_abs_paths(paths_or_name_version: List[str]) -> List[str]:
        overlay_abs_paths = []
        if not paths_or_name_version:
            return overlay_abs_paths
        for path in paths_or_name_version:
            # If it's an actual file path (exists or looks like a file), handle that first
            if path.endswith((".sqf", ".img", ".squashfs")):
                if os.path.isfile(path):
                    overlay_abs_paths.append(os.path.abspath(path))
                    continue
                else:
                    CondaTainer_Exec.parser_exec.error(f"Overlay file {path} not found.")
                    return []

            # Treat non-file inputs as package specs. Accept both name=version and name/version
            # map normalized separator '/' into filename-safe '--'
            normalized_spec = Utils.normalize_name_version(path)
            formatted_filename = normalized_spec.replace("/", "--")
            overlay_filename = f"{formatted_filename}.sqf"
            n = normalized_spec.count('/')
            if n < 2:
                overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)
            elif n == 2:
                overlay_path = os.path.join(Config.REF_IMAGES_DIR, overlay_filename)
            else:
                CondaTainer_Exec.parser_exec.error(f"Invalid overlay format: {path}. Too many '/' characters.")
                return []

            if not os.path.isfile(overlay_path):
                Utils.print_error(f"Overlay {Utils.yellow_text(overlay_filename)} not found at {Utils.blue_text(overlay_path)}.")
                CondaTainer_Exec.parser_exec.error(f"Overlay {overlay_filename} not found.")
                return []
            overlay_abs_paths.append(overlay_path)
        return overlay_abs_paths

    @staticmethod
    def get_overlay_env_configs(paths_or_name_version: List[str]) -> List[str]:
        configs = { }
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            env_path = os.path.splitext(op)[0] + ".env"
            if not os.path.isfile(env_path):
                continue

            with open(env_path, 'r') as f:
                for line in f:
                    if line.startswith("#"):
                        continue
                    line = line.strip()
                    if line and '=' in line:
                        key, value = line.split('=', 1)
                        if key in configs:
                            Utils.print_message(f"Environment variable {key} is defined in multiple overlays. Using the value from {os.path.basename(op)}.")
                        configs[key] = value

        params = []
        for key, value in configs.items():
            params.extend(["--env", f"{key}={value}"])
        return params

    @staticmethod
    def get_overlay_env_notes(paths_or_name_version: List[str]) -> Dict[str, str]:
        notes = { }
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            env_path = os.path.splitext(op)[0] + ".env"
            if not os.path.isfile(env_path):
                continue

            with open(env_path, 'r') as f:
                for line in f:
                    if line.startswith("#ENVNOTE:"):
                        note_content = line[len("#ENVNOTE:"):].strip()
                        if '=' in note_content:
                            key, note = note_content.split('=', 1)
                            notes[key] = note
        return notes

    @staticmethod
    def get_path_env(paths_or_name_version: List[str]) -> str:
        paths = [ "/usr/sbin", "/usr/bin" ]
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for path in overlay_abs_paths:
            name = os.path.basename(path)
            name = os.path.splitext(name)[0]  # Remove extension
            name = name.replace("=", "/").replace("--", "/")
            if path.endswith(".img"):
                relative_path = f"/ext3/{name}/bin"
            elif path.endswith((".sqf", ".squashfs")):
                relative_path = f"/cnt/{name}/bin"
            else:
                Utils.print_warning(f"Unknown overlay file extension for {path}. Skipping PATH addition.")
                continue
            paths.insert(0, relative_path)
        return ":".join(paths)

    @staticmethod
    def generate_overlay_args(paths_or_name_version: List[str]) -> List[str]:
        mounts = []
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            if CondaTainer_Exec.is_img_writable and op.endswith(".img"):
                Utils.print_debug(f"[EXEC] Making overlay {Utils.blue_text(op)} writable.")
                mounts.extend(["--overlay", op])
            else:
                mounts.extend(["--overlay", op + ":ro"])
        if CondaTainer_Exec.is_img_writable:
            # Ensure only the last .img is writable
            n_img = len([o for o in overlay_abs_paths if o.endswith('.img')])
            if n_img > 1:
                for op in overlay_abs_paths:
                    if op.endswith('.img'):
                        n_img -= 1
                        if n_img >= 1:
                            mounts[mounts.index(op)] = op + ":ro"
        return mounts

    @staticmethod
    def exec_command(paths_or_name_versions: List[str], command: List[str], capture_output: bool = False) -> bool:
        path_env = CondaTainer_Exec.get_path_env(paths_or_name_versions)
        env_params = CondaTainer_Exec.get_overlay_env_configs(paths_or_name_versions)

        n_img = 0
        last_img = None
        writable_path = None
        if paths_or_name_versions:
            for o in paths_or_name_versions:
                if o.endswith('.img'):
                    last_img = o
                    n_img += 1

        if last_img is not None and CondaTainer_Exec.is_img_writable:
            # Convert filename-safe separators back to normalized path
            writable_path = f"/ext3/{os.path.splitext(os.path.basename(last_img))[0].replace('--', '/').replace('=', '/') }"

        exec_cmd = [
            Config.APPTAINER_PATH, "exec",
            "--fakeroot",
            *CondaTainer_Exec.generate_overlay_args(paths_or_name_versions),
            *env_params,
            "--env", f"PATH={path_env}",
            # "--env", f"PS1=CT \\w> ",
            "--env", "IN_CONDATINER=1",
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            # "--bind", "/etc/localtime:/etc/localtime:ro",
            *(["--env", "CNT_CONDA_PREFIX=" + writable_path] if writable_path else []),
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            *command
        ]

        Utils.print_debug(f"[EXEC] Executing command: {exec_cmd}")

        if n_img > 1 and CondaTainer_Exec.is_img_writable:
            Utils.print_warning("Multiple img provided, but only the last one will be mounted as writable.")

        if Utils.is_in_interactive_shell() and not capture_output:
            env_notes = CondaTainer_Exec.get_overlay_env_notes(paths_or_name_versions)

            if env_notes:
                env_max_len = max(len(key) for key in env_notes.keys())
                Utils.print_message("Overlay envs:")
                for key, note in env_notes.items():
                    print(f"  {Utils.yellow_text(key.ljust(env_max_len))}: {note}")
                if writable_path:
                    print(f"  {Utils.yellow_text('CNT_CONDA_PREFIX'.ljust(env_max_len))}: {Utils.blue_text(writable_path)}")
                print("")
            else:
                if writable_path:
                    print(f"Overlay env:\n  {Utils.yellow_text('CNT_CONDA_PREFIX')}: {Utils.blue_text(writable_path)}\n")
        try:
            subprocess.run(exec_cmd, check=True, capture_output=capture_output)
        except subprocess.CalledProcessError:
            Utils.print_warning("Command execution failed inside the container.")
            return False
        
        return True

class CondaTainer_Avail:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Avail.parser_avail = parser.add_parser(
            "avail", aliases=["av"],
            help="Check available local and remote build scripts")
        CondaTainer_Avail.parser_avail.add_argument(
            "terms",
            type=str,
            nargs="*",
            help="Search terms (AND logic applied)"
        )
        CondaTainer_Avail.parser_avail.add_argument(
            "-i", "--install",
            action="store_true",
            help="Install the selected build scripts (used with terms)"
        )
        CondaTainer_Avail.parser_avail.add_argument(
            "-a", "--add",
            action="store_true",
            help="Alias for --install (used with terms)"
        )

    @staticmethod
    def parse_avail_args(args):
        local_packages = Utils.get_local_build_scripts()
        is_install = args.install or args.add

        # Fetch remote metadata entries if configured
        remote_packages = {}
        if Config.REMOTE_METADATA_URL:
            remote_packages = Utils.fetch_remote_build_scripts()

        installed_overlays = CondaTainer.get_installed_overlays()

        added_packages = set()
        all_packages = []
        for p in local_packages.keys():
            if p in installed_overlays:
                all_packages.append(f"{p} (installed)")
            else:
                all_packages.append(p)
            added_packages.add(p)
        # add remote-only packages with a marker
        for k in sorted(remote_packages.keys()):
            if k not in added_packages:
                if k in installed_overlays:
                    all_packages.append(f"{k} (remote, installed)")
                else:
                    all_packages.append(f"{k} (remote)")
                added_packages.add(k)

        if args.terms:
            # match ONLY packages that contain *all* terms (logical AND)
            filtered_packages = [
                p for p in all_packages
                if all(re.search(re.escape(term), p, re.IGNORECASE) for term in args.terms)
            ]
        else:
            filtered_packages = all_packages

        if not filtered_packages:
            Utils.print_warning("No matching local or remote build scripts found.")
            return

        for pkg in sorted(filtered_packages):
            if args.terms:
                highlighted = pkg
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
                print(highlighted)
            else:
                print(pkg)

        uninstalled_packages = set()
        for pkg in filtered_packages:
            if "installed" in pkg:
                continue
            else:
                uninstalled_packages.add(pkg.split(' ')[0])

        if Utils.is_in_interactive_shell() and is_install and args.terms and uninstalled_packages:
            CondaTainer.ensure_base_image()
            print("==================INSTALL==================")
            print("The following overlays will be installed:")
            for pkg in sorted(uninstalled_packages):
                print(f" - {pkg}")
            Utils.print_message("Do you want to install the above overlays? [y/N]: ", end="")
            choice = input().strip().lower()
            if choice != 'y':
                return

            for pkg in uninstalled_packages:
                Utils.print_message(f"Installing overlay for {Utils.yellow_text(pkg)}...")
                if CondaTainer_Create.auto_create_overlay_from_str(pkg):
                    Utils.print_success(f"Overlay for {Utils.yellow_text(pkg)} installed.")
                else:
                    Utils.print_error(f"Failed to install overlay for {Utils.yellow_text(pkg)}.")

class CondaTainer_List:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_List.parser_list = parser.add_parser(
            "list", aliases=["ls"],
            help="List installed overlays matching search terms")
        CondaTainer_List.parser_list.add_argument(
            "terms",
            type=str,
            nargs="*",
            help="Search terms (AND logic applied)"
        )
        CondaTainer_List.parser_list.add_argument(
            "-d", "--delete",
            action="store_true",
            help="Delete listed overlays after confirmation (used with terms)"
        )
        CondaTainer_List.parser_list.add_argument(
            "-r", "--remove",
            action="store_true",
            help="Alias for --delete (used with terms)"
        )

    @staticmethod
    def parse_list_args(args):
        is_delete = args.delete or args.remove
        if os.path.isdir(Config.IMAGES_DIR):
            overlay_files = [f for f in os.listdir(Config.IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
            name_versions_dict = {}
            for overlay in overlay_files:
                name_version = os.path.splitext(overlay)[0]
                if '--' in name_version:
                    name, version = name_version.split('--', 1)
                    if args.terms:
                        if not all(re.search(re.escape(term), name_version, re.IGNORECASE) for term in args.terms):
                            continue
                    if name in name_versions_dict:
                        name_versions_dict[name].append(version)
                    else:
                        name_versions_dict[name] = [version]
                else:
                    if args.terms:
                        if not all(re.search(re.escape(term), name_version, re.IGNORECASE) for term in args.terms):
                            continue
                    name_versions_dict[name_version] = [f"(conda env, config: {Utils.blue_text('/cnt/' + name_version.replace('--', '/') + '/env.yml')})"]

            if name_versions_dict:
                name_col_width = max(len(name) for name in name_versions_dict.keys())
                print("Available app overlays:")
                for name in sorted(name_versions_dict.keys()):
                    print(f" {Utils.yellow_text(name.ljust(name_col_width))}: {', '.join(sorted(name_versions_dict[name]))}")

        if os.path.isdir(Config.REF_IMAGES_DIR):
            ref_overlay_files = [
                f for f in os.listdir(Config.REF_IMAGES_DIR) 
                    if f.endswith(('.sqf', '.img', '.squashfs')) and 
                    all(re.search(re.escape(term), f, re.IGNORECASE) for term in args.terms)]
            if ref_overlay_files:
                print("Available reference overlays:")
                for overlay in sorted(ref_overlay_files):
                    name_version = os.path.splitext(overlay)[0].replace('--', '/')
                    if args.terms:
                        colored_name_version = name_version
                        for term in args.terms:
                            colored_name_version = re.sub(
                                re.escape(term),
                                lambda m: Utils.yellow_text(m.group(0)),
                                colored_name_version,
                                flags=re.IGNORECASE
                            )
                        print(" " + colored_name_version)
                    else:
                        print(" " + name_version)

        if Utils.is_in_interactive_shell() and is_delete and args.terms:
            print("==================REMOVE==================")
            CondaTainer_Remove.parse_remove_args(args)

class CondaTainer_Remove:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Remove.parser_remove = parser.add_parser(
            "remove", aliases=["delete"],
            help="Remove installed overlays matching search terms")
        CondaTainer_Remove.parser_remove.add_argument(
            "terms",
            type=str,
            nargs="+",
            help="Search terms (AND logic applied)"
        )

    @staticmethod
    def parse_remove_args(args):
        installed_overlays_dict = CondaTainer.get_installed_overlays()
        if not installed_overlays_dict:
            Utils.print_warning("No installed overlays found.")
            return

        filtered_overlays = []
        for overlay in installed_overlays_dict.keys():
            if args.terms:
                if all(re.search(re.escape(term), overlay, re.IGNORECASE) for term in args.terms):
                    filtered_overlays.append(overlay)
            else:
                filtered_overlays.append(overlay)

        if not filtered_overlays:
            Utils.print_warning("No matching installed overlays found.")
            return

        print("Overlays to be removed:")
        for overlay in sorted(filtered_overlays):
            highlighted = overlay
            if args.terms:
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
            print(f" - {highlighted}")

        Utils.print_message("Are you sure? Cannot be undone. [y/N]: ", end="")
        choice = input().strip().lower()
        if choice != 'y':
            return

        for overlay in filtered_overlays:
            overlay_path = installed_overlays_dict[overlay]
            try:
                os.remove(overlay_path)
                Utils.print_success(f"Removed overlay {Utils.yellow_text(overlay)} at {Utils.blue_text(overlay_path)}.")
                env_path = os.path.splitext(overlay_path)[0] + ".env"
                if os.path.isfile(env_path):
                    os.remove(env_path)
                    Utils.print_success(f"Also removed associated env file at {Utils.blue_text(env_path)}.")
            except Exception as e:
                Utils.print_error(f"Failed to remove overlay {Utils.yellow_text(overlay)}: {str(e)}")

class CondaTainer_Info:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Info.parser_info = parser.add_parser("info", help="Show information about a specific overlay")
        CondaTainer_Info.parser_info.add_argument(
            "overlay",
            type=str,
            help="Overlay package (e.g., bcftools/1.22)"
        )

    @staticmethod
    def parse_info_args(args):
        installed_overlays_dict = CondaTainer.get_installed_overlays()
        overlay = Utils.normalize_name_version(args.overlay)
        if overlay in installed_overlays_dict.keys(): # installed overlay
            overlay_path = installed_overlays_dict[overlay]
        else: # external overlay
            overlay_path = os.path.abspath(args.overlay)
            if not os.path.isfile(overlay_path):
                Utils.print_error(f"Overlay file {Utils.blue_text(overlay_path)} not found.")
                return

        print(f"Information for overlay {Utils.yellow_text(os.path.basename(overlay_path))}:")
        # Additional info can be added here, e.g., size, creation date, etc.
        file_size = os.path.getsize(overlay_path)
        print(f"Size: {file_size / (1024 * 1024):.2f} MB")
        if overlay_path.endswith((".sqf", ".squashfs")):
            name = os.path.splitext(os.path.basename(overlay_path))[0]
            name = name.replace('--', '/').replace('=', '/')
            print(f"Potential mount path: {Utils.blue_text('/cnt/' + name)}")
        elif overlay_path.endswith(".img"):
            name = os.path.splitext(os.path.basename(overlay_path))[0]
            name = name.replace('--', '/').replace('=', '/')
            print(f"Potential mount path: {Utils.blue_text('/ext3/' + name)}")

        env_path = os.path.splitext(overlay_path)[0] + ".env"
        if os.path.isfile(env_path):
            print("Environment variables:")
            with open(env_path, 'r') as f:
                for line in f:
                    print(f"  - {line.strip()}")

class CondaTainer_Check:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Check.parser_check = parser.add_parser(
            "check", aliases=["c"],
            help="Check if the dependencies of a script are installed")
        CondaTainer_Check.parser_check.add_argument(
            "script",
            type=str,
            help="Path to the script to check"
        )
        CondaTainer_Check.parser_check.add_argument(
            "-a", "--auto-install",
            action="store_true",
            help="Automatically install missing dependencies"
        )
        CondaTainer_Check.parser_check.add_argument(
            "-i", "--install",
            action="store_true",
            help="Alias for --auto-install"
        )

    @staticmethod
    def parse_check_args(args):
        is_install = args.auto_install or args.install
        script_path_or_name = args.script
        is_remote = False
        if not os.path.isfile(script_path_or_name):
            script_path_or_name = Utils.normalize_name_version(script_path_or_name)
            local_build_scripts = Utils.get_local_build_scripts()
            Utils.print_debug(f"[CHECK] Checking for build script {script_path_or_name} locally and remotely...")
            if script_path_or_name in local_build_scripts:
                script_path = local_build_scripts[script_path_or_name]
                Utils.print_message(f"Found local build script {Utils.blue_text(script_path)}")
            elif script_path_or_name in Utils.fetch_remote_build_scripts():
                Utils.print_message(f"Downloading build script for {script_path_or_name} from remote metadata...")
                is_remote = True
                url = Utils.fetch_remote_build_scripts()[script_path_or_name]
                script_path = os.path.join(Config.CONDATINER_DIR, f"{script_path_or_name.replace('/', '--')}.sh")
                if Utils.download_executable(url, script_path):
                    Utils.print_message(f"Downloaded build script to {Utils.blue_text(script_path)}")
                else:
                    Utils.print_error(f"Failed to download build script for {script_path_or_name} from {url}.")
                    return
            else:
                Utils.print_error(f"Build script for {script_path_or_name} not found.")
                return
        else:
            script_path = script_path_or_name

        deps = Utils.get_dependencies_from_script(script_path)
        for d in deps:
            Utils.print_message(f"Dependency: {Utils.yellow_text(d)}" + Utils.red_text(" (missing)" if not CondaTainer.check_overlay_installed(d) else ""))
        missing_deps = CondaTainer.get_missing_overlays(deps)

        if not missing_deps:
            Utils.print_message("All dependencies are installed.")
            if is_remote and os.path.isfile(script_path):
                os.remove(script_path)
            return

        if is_install:
            CondaTainer.ensure_base_image()
            Utils.print_message("Attempting to auto-install missing dependencies...")
            for md in missing_deps:
                if md.endswith(('.sqf', '.img', '.squashfs')):
                    Utils.print_error(f"Custom overlay {Utils.yellow_text(md)} is missing. Cannot proceed with auto-installation.")
                    continue
                if CondaTainer_Create.auto_create_overlay_from_str(md):
                    Utils.print_success(f"Dependency overlay {Utils.yellow_text(md)} created.")
                else:
                    Utils.print_error(f"Failed to create dependency overlay {Utils.yellow_text(md)}.")
        else:
            Utils.print_message(f"Run the command again with {Utils.blue_text('-a')} or {Utils.blue_text('--auto-install')} to install missing dependencies.")

        if is_remote and os.path.isfile(script_path):
            os.remove(script_path)

class CondaTainer_Run:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Run.parser_run = parser.add_parser(
            "run", aliases=["r"],
            help="Run a script and auto-solve the dependencies by #DEP tags")
        CondaTainer_Run.parser_run.add_argument(
            "script",
            type=str,
            help="Path to the script to run"
        )
        CondaTainer_Run.parser_run.add_argument(
            "-w", "--writable-img",
            help="Make .img overlays writable (default: read-only)",
            action="store_true"
        )
        CondaTainer_Run.parser_run.add_argument(
            "-a", "--auto-install",
            help="Automatically install missing dependencies",
            action="store_true"
        )
        CondaTainer_Run.parser_run.add_argument(
            "-i", "--install",
            help="Alias for --auto-install",
            action="store_true"
        )
        CondaTainer_Run.parser_run.add_argument(
            "script_args",
            nargs=argparse.REMAINDER,
            help="Arguments to pass to the script"
        )

    @staticmethod
    def parse_args_in_script(script_path: str) -> List[str]:
        args = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Script file {script_path} not found.")
            return args

        with open(script_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith("#CNT"):
                    arg_line = line[len("#CNT"):].strip()
                    args.append(arg_line)
        return args

    @staticmethod
    def parse_run_args(args):
        CondaTainer.ensure_base_image()
        script_path = args.script
        if not os.path.isfile(script_path):
            CondaTainer_Run.parser_run.error(f"Script file {script_path} not found.")
        script_args = args.script_args

        args_from_script = CondaTainer_Run.parse_args_in_script(args.script)
        merged = args_from_script + sys.argv[2:]
        args = CondaTainer_Run.parser_run.parse_args(merged)
        is_install = args.auto_install or args.install

        if Config.debug and args_from_script:
            Utils.print_debug(f"[RUN] Additional script arguments found: {args_from_script}")

        deps = Utils.get_dependencies_from_script(script_path)
        missing_deps = CondaTainer.get_missing_overlays(deps)

        if missing_deps:
            if not is_install:
                Utils.print_message("Missing dependencies:")
                for md in missing_deps:
                    Utils.print_message(f"  - {Utils.yellow_text(md)}")

                Utils.print_message(f"Please run {Utils.blue_text(Config.SCRIPT_NAME + ' check -a')} to install missing dependencies.")
                return
            
            Utils.print_message("Attempting to auto-install missing dependencies...")
            for md in missing_deps:
                if md.endswith(('.sqf', '.img', '.squashfs')):
                    Utils.print_error(f"Custom overlay {Utils.yellow_text(md)} is missing. Cannot proceed with auto-installation.")
                    return
                if CondaTainer_Create.auto_create_overlay_from_str(md):
                    Utils.print_success(f"Dependency overlay {Utils.yellow_text(md)} created.")
                else:
                    Utils.print_error(f"Failed to create dependency overlay {Utils.yellow_text(md)}.")
                    return

        if args.writable_img:
            CondaTainer_Exec.is_img_writable = True

        CondaTainer_Exec.exec_command(deps, ["/bin/bash", script_path] + script_args)

class CondaTainer_Overlay:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Overlay.parser_overlay = parser.add_parser(
            "overlay", aliases=["o"],
            help="Create an empty overlay img")
        CondaTainer_Overlay.parser_overlay.add_argument(
            "image",
            type=str,
            help="Path to create the overlay image"
        )
        CondaTainer_Overlay.parser_overlay.add_argument(
            "-s", "--size",
            type=int,
            default=10240,
            help="Size of the overlay image in MiB"
        )
        CondaTainer_Overlay.parser_overlay.add_argument(
            "-f", "--file",
            type=str,
            help="Conda env YAML file"
        )

    @staticmethod
    def parse_overlay_args(args):
        CondaTainer.ensure_apptainer()
        overlay_path = os.path.abspath(args.image)
        size_mib = args.size

        if not overlay_path.endswith(".img"):
            if '.' in os.path.basename(overlay_path):
                CondaTainer_Overlay.parser_overlay.error("Overlay image must have a .img extension.")
            overlay_path += ".img"

        if os.path.isfile(overlay_path) or os.path.isdir(overlay_path):
            Utils.print_error(f"Path {overlay_path} already exists.")
            return
        
        if args.file:
            if not os.path.isfile(args.file):
                Utils.print_error(f"Conda env file {args.file} not found.")
                return
        
        Utils.print_message(f"Creating overlay image at {Utils.blue_text(overlay_path)} with size {Utils.yellow_text(str(size_mib) + ' MiB')}...")
        cmd_overlay = [
            Config.APPTAINER_PATH, "overlay", "create",
            "--size", str(size_mib), "--sparse", "--fakeroot",
            overlay_path
        ]
        
        try:
            subprocess.run(cmd_overlay, check=True)
            Utils.print_success(f"Overlay image created at {Utils.blue_text(overlay_path)}.")
        except subprocess.CalledProcessError:
            Utils.print_error("Failed to create overlay image.")
            return
        
        CondaTainer_Exec.is_img_writable = True
        if args.file:
            Utils.print_message(f"Initializing conda environment using {os.path.abspath(args.file)}...")
            if CondaTainer_Exec.exec_command([overlay_path], ["mm-create", "-f", os.path.abspath(args.file), "-y"], capture_output=True):
                CondaTainer_Exec.exec_command([overlay_path], ["mm-clean", "-a", "-y"], capture_output=True)
                Utils.print_success(f"Conda env is created inside {Utils.blue_text(overlay_path)}.")
            else:
                Utils.print_error(f"Failed to create conda env inside {Utils.blue_text(overlay_path)}.")
        else:
            Utils.print_message("Initializing minimal conda environment with small package (zlib)...")
            if CondaTainer_Exec.exec_command([overlay_path], ["mm-create", "zlib", "-y"], capture_output=True):
                CondaTainer_Exec.exec_command([overlay_path], ["mm-clean", "-a", "-y"], capture_output=True)
                Utils.print_success(f"Conda env is created inside {Utils.blue_text(overlay_path)}.")
            else:
                Utils.print_error(f"Failed to create conda env inside {Utils.blue_text(overlay_path)}.")

class CondaTainer_Apptainer:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Apptainer.parser_apptainer = parser.add_parser("apptainer", help="Get latest Apptainer executable from conda-forge")

        CondaTainer_Apptainer.parser_apptainer.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm installation"
        )

        CondaTainer_Apptainer.parser_apptainer.add_argument(
            "-f", "--force",
            action="store_true",
            help="Force re-installation even if Apptainer is already installed"
        )

    @staticmethod
    def parse_apptainer_args(args):
        if os.path.isdir(Config.LOCAL_APPTAINER_DIR) and not args.force:
            Utils.print_message(f"Apptainer executable already exists at {Config.LOCAL_APPTAINER_DIR}. Use -f or --force to re-install.")
            return

        if not args.yes:
            Utils.print_warning("You cannot build sif images with conda-forge Apptainer.")
            Utils.print_message("Are you sure you want to install? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Installation cancelled by user.")
                return

        CondaTainer_Apptainer.install_apptainer(args.force)

    @staticmethod
    def secure_local_micromamba():
        if os.path.exists(Config.LOCAL_MICROMAMBA_BIN):
            return True

        # Detect architecture
        machine = platform.machine()
        if machine in ("aarch64", "ppc64le", "arm64"):
            ARCH = machine
        else:
            ARCH = "64"

        release_url = f"https://github.com/mamba-org/micromamba-releases/releases/latest/download/micromamba-linux-{ARCH}"
        if Utils.download_executable(release_url, Config.LOCAL_MICROMAMBA_BIN):
            Utils.print_success(f"Micromamba downloaded to {Config.LOCAL_MICROMAMBA_BIN}.")
            return True
        else:
            Utils.print_error("Failed to download Micromamba.")
            return False

    @staticmethod
    def install_apptainer(force: bool = False):
        if not CondaTainer_Apptainer.secure_local_micromamba():
            Utils.print_error("Cannot proceed with Apptainer installation without Micromamba.")
            return

        if not force and os.path.isdir(Config.LOCAL_APPTAINER_DIR):
            Utils.print_message(f"Apptainer already exists at {Config.LOCAL_APPTAINER_DIR}. Use -f or --force to re-install.")
            return

        Utils.print_message("Installing Apptainer using Micromamba...")
        cmd_install = [
            Config.LOCAL_MICROMAMBA_BIN, 
            "-r", os.path.join(Config.CONDATINER_DIR, "micromamba_env"),
            "create", "-c", "conda-forge",
            "-p", Config.LOCAL_APPTAINER_DIR,
            "-y",
            "apptainer"
        ]

        Utils.print_debug(f"[APPTAINER] Installing Apptainer with command: {cmd_install}")

        try:
            subprocess.run(cmd_install, check=True)
            Utils.print_success(f"Apptainer installed to {Config.APPTAINER_PATH}.")
            Utils.print_message("Cleaning up Micromamba environment...")
            shutil.rmtree(os.path.join(Config.CONDATINER_DIR, "micromamba_env"), ignore_errors=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Failed to install Apptainer.")

class CondaTainer_Update:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Update.parser_update = parser.add_parser("update", help="Update CondaTainer to the latest version")
        CondaTainer_Update.parser_update.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm update"
        )

    @staticmethod
    def parse_update_args(args):
        if not args.yes:
            Utils.print_message("Are you sure to download and replace the current script from GitHub? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Update cancelled by user.")
                return

        Utils.print_message("Downloading the latest CondaTainer script...")
        if Utils.download_executable(Config.CONDATAINER_URL, Config.SCRIPT_PATH + ".tmp"):
            os.chmod(Config.SCRIPT_PATH + ".tmp", 0o775)
            shutil.move(Config.SCRIPT_PATH + ".tmp", Config.SCRIPT_PATH)
            Utils.print_success("CondaTainer updated.")
        else:
            Utils.print_error("Failed to download the latest CondaTainer script.")

class CondaTainer_ModGen:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_ModGen.parser_modgen = parser.add_parser("modgen", help="Get latest modgen executable from GitHub")
        CondaTainer_ModGen.parser_modgen.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm installation"
        )
        CondaTainer_ModGen.parser_modgen.add_argument(
            "-f", "--force",
            action="store_true",
            help="Force overwrite if CondaTainer is already installed"
        )

    @staticmethod
    def parse_modgen_args(args):
        if not Utils.is_in_interactive_shell():
            return

        Utils.print_message(f"{Utils.blue_text('ModGen')}: Use conda and build scripts to create environment-modules or Lmod modules.")
        Utils.print_message(f"Which is another way to manage software environments compared to {Utils.blue_text('CondaTainer')}.")
        Utils.print_message(f"HPC systems often have numbers of prebuilt modules available via Lmod.")
        Utils.print_message(f"{Utils.blue_text('ModGen')} will take the advantage of existing modules and only install missing modules via micromamba.")
        print("", flush=True)

        target_path = os.path.join(os.path.dirname(Config.SCRIPT_PATH), "modgen")
        if os.path.isfile(target_path) and not args.force:
            Utils.print_message(f"ModGen is already installed at {Utils.blue_text(target_path)}.")
            Utils.print_message("Overwrite? [y/N]: ", end="", flush=True)
            if not args.yes:
                confirm = input()
                if confirm.lower() != 'y':
                    Utils.print_message("Installation cancelled by user.")
                    return

        if not args.force and not args.yes:
            Utils.print_message("Are you sure to install ModGen? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Installation cancelled by user.")
                return

        Utils.print_message("Downloading ModGen...")
        if Utils.download_executable(Config.MODGEN_URL, target_path):
            Utils.print_success("ModGen installed.")
        else:
            Utils.print_error("Failed to download ModGen.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        Utils.print_message("CondaTainer interrupted by user.")
        sys.exit(1)
