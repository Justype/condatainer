#!/usr/bin/env python3
import os
import sys
import subprocess
import re
import shutil
import argparse
import time
import json
import urllib.request
import platform
from pathlib import Path
from typing import Dict, List, Optional

os.umask(0o002)

class Config:
    VERSION = "1.0.0"
    # Remote settings
    DEBUG = False
    GITHUB_REPO = "Justype/condatainer"
    REMOTE_METADATA_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/metadata/build-scripts.json"

    # Folder paths
    SCRIPT_PATH = os.path.abspath(__file__)
    PROGRAM_DIR = os.path.dirname(SCRIPT_PATH)
    CONDATINER_DIR = os.path.abspath(os.path.join(PROGRAM_DIR, ".."))
    BUILD_SCRIPTS_DIR = os.path.join(CONDATINER_DIR, "build-scripts")
    IMAGES_DIR = os.path.join(CONDATINER_DIR, "images")
    REF_IMAGES_DIR = os.path.join(CONDATINER_DIR, "ref-images")
    CNT_DIR = os.path.join(CONDATINER_DIR, "cnt")

    # Local apptainer
    LOCAL_APPTAINER_DIR = os.path.join(CONDATINER_DIR, "apptainer")
    LOCAL_APPTAINER_BIN = os.path.join(LOCAL_APPTAINER_DIR, "bin", "apptainer")
    LOCAL_MICROMAMBA_BIN = os.path.join(CONDATINER_DIR, "bin", "micromamba")

    # File paths
    TMP_OVERLAY_PATH = os.path.join(CONDATINER_DIR, "tmp.img")
    BASE_IMAGE_DEF = os.path.join(BUILD_SCRIPTS_DIR, "base_image.def")
    BASE_IMAGE_SIF = os.path.join(IMAGES_DIR, "base_image.sif")
    APPTAINER_PATH = shutil.which("apptainer") if shutil.which("apptainer") else shutil.which("singularity")
    BAD_CHARS_REGEX = re.compile(r'[<>:"/\\|?*\0\s\'`$&;|!\[\]#%@=+{}(),]')

    # Utils
    NCPUS = os.environ.get("SLURM_CPUS_PER_TASK", 4)
    GZIP = "-comp gzip"
    ZSTD_FAST = "-comp zstd -Xcompression-level 3"
    ZSTD_MEDIUM = "-comp zstd -Xcompression-level 8"
    ZSTD = "-comp zstd -Xcompression-level 14"
    LZ4 = "-comp lz4"
    COMPRESS_ARGS = LZ4

def main():
    parser = argparse.ArgumentParser(description="CondaTainer CLI Tool\nUse apptainer/conda/squashFS to manage tools for HPC users.")
    parser.add_argument("-v", "--version", action="version", version=Config.VERSION, help="Show the version of CondaTainer", default=argparse.SUPPRESS)
    parser.add_argument("--debug", action="store_true", help="Enable debug mode with verbose output")
    subparsers = parser.add_subparsers(dest="action", required=True, help="Available actions")

    CondaTainer_Avail.add_parser_arguments(subparsers)
    CondaTainer_Create.add_parser_arguments(subparsers)
    CondaTainer_Exec.add_parser_arguments(subparsers)
    CondaTainer_Check.add_parser_arguments(subparsers)
    CondaTainer_Run.add_parser_arguments(subparsers)
    subparsers.add_parser("list", help="List all installed overlays")
    CondaTainer_Info.add_parser_arguments(subparsers)
    CondaTainer_Apptainer.add_parser_arguments(subparsers)
    CondaTainer_Update.add_parser_arguments(subparsers)
    subparsers.add_parser("help", help="Show help information about CondaTainer")

    args = parser.parse_args()
    if args.debug:
        Config.DEBUG = True
    if args.action == "create":
        Utils.ensure_base_image()
        CondaTainer_Create.parse_create_args(args)
    elif args.action == "exec":
        Utils.ensure_base_image()
        CondaTainer_Exec.parse_exec_args(args)
    elif args.action == "check":
        Utils.ensure_base_image()
        CondaTainer_Check.parse_check_args(args)
    elif args.action == "run":
        Utils.ensure_base_image()
        CondaTainer_Run.parse_run_args(args)
    elif args.action == "list":
        CondaTainer_List.list_overlays()
    elif args.action == "info":
        CondaTainer_Info.parse_info_args(args)
    elif args.action == "avail":
        CondaTainer_Avail.parse_avail_args(args)
    elif args.action == "apptainer":
        CondaTainer_Apptainer.parse_apptainer_args(args)
    elif args.action == "update":
        CondaTainer_Update.parse_update_args(args)
    elif args.action == "help":
        parser.print_help()

class Utils:
    remote_build_scripts_links: Optional[Dict[str, str]] = None
    local_build_scripts_paths: Optional[Dict[str, str]] = None

    @staticmethod
    def blue_text(text):
        return f"\033[94m{text}\033[0m"

    @staticmethod
    def red_text(text):
        return f"\033[91m{text}\033[0m"

    @staticmethod
    def yellow_text(text):
        return f"\033[93m{text}\033[0m"

    @staticmethod
    def green_text(text):
        return f"\033[92m{text}\033[0m"

    @staticmethod
    def print_message(message):
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {message}", flush=True)

    @staticmethod
    def print_debug(message):
        if Config.DEBUG:
            print(f"[{Utils.yellow_text('DEBUG')}]", end=" ", flush=True)
            print(message)

    @staticmethod
    def print_note(message):
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}][{Utils.blue_text('NOTE')}] {message}", flush=True)

    @staticmethod
    def print_warning(message):
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}][{Utils.yellow_text('WARNING')}] {message}", file=sys.stderr, flush=True)
    @staticmethod
    def print_error(message):
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}][{Utils.red_text('ERROR')}] {message}", file=sys.stderr, flush=True)

    @staticmethod
    def print_success(message):
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}][{Utils.green_text('SUCCESS')}] {message}", flush=True)

    @staticmethod
    def ensure_apptainer():
        if Config.APPTAINER_PATH is None:
            Utils.print_message("Apptainer not found in PATH.")
            Utils.print_message("Make sure you load the Apptainer module in your HPC system.")
            Utils.print_message("If there is no Apptainer module, please contact your system administrator.")
            return False
        return True

    @staticmethod
    def normalize_name_version(name_version: str) -> str:
        """
        Normalize package spec formats so that `name/version`, `name=version`, `name@version`
        are treated the same. This converts slashes to equal signs and strips
        surrounding whitespace.
        """
        if not isinstance(name_version, str):
            return name_version
        return name_version.strip().replace('/', '=').replace('@', '=')

    @staticmethod
    def fetch_remote_build_scripts() -> dict:
        """
        Fetch JSON metadata from a remote http(s) URL

        Returns a name-version to link mapping dictionary.
        """
        url = Config.REMOTE_METADATA_URL
        if not url:
            return {}

        if Utils.remote_build_scripts_links is not None:
            return Utils.remote_build_scripts_links

        normalized = {}

        try:
            with urllib.request.urlopen(url) as resp:
                data = resp.read()
                metadata = json.loads(data)

                for k in metadata:
                    normalized_key = Utils.normalize_name_version(k)
                    rel = normalized_key.replace('=', '/')
                    link = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/{rel}"
                    normalized[normalized_key] = link

        except Exception as e:
            Utils.print_warning(f"Failed to fetch remote metadata from {url}: {e}")
            return {}

        if normalized:
            Utils.remote_build_scripts_links = normalized

        return normalized

    @staticmethod
    def get_local_build_scripts():
        """
        Get a name-version to local script path mapping dictionary.
        """
        if Utils.local_build_scripts_paths is not None:
            return Utils.local_build_scripts_paths
        packages = {}
        if not os.path.isdir(Config.BUILD_SCRIPTS_DIR):
            # No local build-scripts directory â€” behave as if there are no local scripts
            return packages
        try:
            script_paths = os.listdir(Config.BUILD_SCRIPTS_DIR)
        except Exception:
            return packages
        script_paths = sorted(script_paths)
        for script_name in script_paths:
            if script_name == "0-template":
                continue
            script_path = os.path.join(Config.BUILD_SCRIPTS_DIR, script_name)
            if not os.path.isdir(script_path):
                continue

            versions = os.listdir(script_path)
            versions = [v for v in versions if not (v.startswith("template") or v.endswith("_data"))]
            if len(versions) == 0:
                continue

            # Test if version is a file or directory
            if os.path.isdir(os.path.join(script_path, versions[0])):
                for data_type in versions:
                    # skip .sh .py scripts
                    if data_type.endswith('.sh') or data_type.endswith('.py'):
                        continue
                    data_type_path = os.path.join(script_path, data_type)
                    sub_versions = os.listdir(data_type_path)
                    for version in sub_versions:
                        packages[f"{script_name}={data_type}={version}"] = os.path.join(data_type_path, version)
            else:
                for version in versions:
                    if version.startswith("template") or version.endswith('.sh') or version.endswith('.py'):
                        continue
                    packages[f"{script_name}={version}"] = os.path.join(script_path, version)

        Utils.local_build_scripts_paths = packages
        return packages

    @staticmethod
    def download_file(url: str, dest_path: str) -> bool:
        """
        Download a remote build script to `dest_path`. Creates parent dirs and
        marks the file executable. Returns True on success.
        """
        try:
            os.makedirs(os.path.dirname(dest_path), exist_ok=True)
            with urllib.request.urlopen(url) as resp, open(dest_path, 'wb') as out_f:
                out_f.write(resp.read())
            # Ensure executable
            os.chmod(dest_path, 0o775)
            return True
        except Exception as e:
            Utils.print_error(f"Failed to download build script from {url}: {e}")
            return False

    @staticmethod
    def ensure_base_def():
        base_def_path = Config.BASE_IMAGE_DEF
        if os.path.isfile(base_def_path):
            return True

        Utils.print_message("Base image definition file not found. Downloading...")
        url = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/base_image.def"
        if not Utils.download_file(url, base_def_path):
            Utils.print_error("Failed to download base image definition file.")
            return False
        return True

    @staticmethod
    def ensure_base_image():
        """
        Exit the program if the base image does not exist, after attempting to build it.
        """
        os.makedirs(Config.IMAGES_DIR, exist_ok=True)
        os.makedirs(Config.REF_IMAGES_DIR, exist_ok=True)

        if os.path.isfile(Config.LOCAL_APPTAINER_BIN):
            Config.APPTAINER_PATH = Config.LOCAL_APPTAINER_BIN
            Utils.print_message(f"Using local Apptainer binary at {Config.APPTAINER_PATH}")

        if not Utils.ensure_apptainer():
            exit(1)
        if os.path.isfile(Config.BASE_IMAGE_SIF):
            return
        if not Utils.ensure_base_def():
            exit(1)

        Utils.print_message("Base images not found. Building base images...")
        cmd = [
            Config.APPTAINER_PATH, "build",
            "--fakeroot",
            Config.BASE_IMAGE_SIF,
            Config.BASE_IMAGE_DEF,
        ]
        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Building base images failed.")
            exit(1)
        Utils.print_success("Base images built successfully.")
        cmd = [ Config.APPTAINER_PATH, "cache", "clean", "--force" ]
        subprocess.run(cmd, capture_output=True)
        os.chmod(Config.BASE_IMAGE_SIF, 0o775)
        Utils.print_message("Apptainer cache cleaned.")

    @staticmethod
    def create_tmp_overlay():
        if os.path.isfile(Config.TMP_OVERLAY_PATH):
            os.remove(Config.TMP_OVERLAY_PATH)

        Utils.print_message("Creating temporary SquashFS overlay...")
        cmd = [
            Config.APPTAINER_PATH, "overlay", "create",
            "--sparse", "--size", "10240",  # Size in MB
            Config.TMP_OVERLAY_PATH
        ]

        Utils.print_debug("[CREATE] Creating temporary overlay with command:")
        Utils.print_debug(cmd)

        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Creating temporary overlay failed.")
            return False
        Utils.print_message("Temporary overlay created successfully.")
        return True

    @staticmethod
    def remove_tmp_overlay():
        if os.path.isfile(Config.TMP_OVERLAY_PATH):
            os.remove(Config.TMP_OVERLAY_PATH)
            Utils.print_message("Temporary overlay removed.")
        return True

    @staticmethod
    def get_installed_overlays() -> Dict[str, str]:
        """
        Get name-version -> file path mapping of installed overlays.
        """
        overlays = {}
        if not os.path.isdir(Config.IMAGES_DIR):
            return overlays

        overlay_files = [f for f in os.listdir(Config.IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
        for overlay in overlay_files:
            name_version = os.path.splitext(overlay)[0]
            name_version = name_version.replace("--", "=")
            overlays[name_version] = os.path.join(Config.IMAGES_DIR, overlay)

        ref_overlay_files = [f for f in os.listdir(Config.REF_IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
        for overlay in ref_overlay_files:
            name_version = os.path.splitext(overlay)[0]
            name_version = name_version.replace("--", "=")
            overlays[name_version] = os.path.join(Config.REF_IMAGES_DIR, overlay)
        return overlays

    @staticmethod
    def get_dependencies_from_script(script_path: str) -> List[str]:
        """
        Get dependencies from a build script by parsing #DEP: lines.

        :param script_path: Description
        :type script_path: str
        :return: Description
        :rtype: List[str]
        """
        dependencies = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}")
            return dependencies

        with open(script_path, 'r') as f:
            for line in f:
                if line.startswith("#DEP:"):
                    dep_line = line[len("#DEP:"):].strip()
                    if dep_line.endswith((".sqf", ".img", ".squashfs")):
                        dependencies.append(dep_line)
                    else:
                        dependencies.append(dep_line.replace("/", "="))
        return dependencies

    @staticmethod
    def check_overlay_installed(name_version: str) -> bool:
        installed_overlays = Utils.get_installed_overlays().keys()
        return name_version in installed_overlays

    @staticmethod
    def get_missing_overlays(name_versions_or_paths: List[str]) -> List[str]:
        missing = []
        installed_overlays = Utils.get_installed_overlays().keys()
        for nv in name_versions_or_paths:
            if nv.endswith(('.sqf', '.img', '.squashfs')):
                if not os.path.isfile(nv):
                    missing.append(nv)
            elif nv not in installed_overlays:
                missing.append(nv)
        return missing

    @staticmethod
    def is_in_interactive_shell() -> bool:
        return sys.stdin.isatty() and sys.stdout.isatty()

    @staticmethod
    def generate_bind_args(*paths: str) -> List[str]:
        """
        Accept multiple paths and return a list of absolute paths
        with --bind parameters suitable for binding in Singularity.

        Rules:
        - Resolve to absolute paths
        - Keep only one if multiple paths are the same
        - Skip paths that are children of another path
        """
        # Resolve all paths to absolute, normalized Path objects
        abs_paths = [Path(p).resolve() for p in paths]

        # Remove duplicates
        unique_paths = []
        for p in abs_paths:
            if p not in unique_paths:
                unique_paths.append(p)

        # Filter out child paths
        final_paths = []
        for p in unique_paths:
            if not any(parent != p and p.is_relative_to(parent) for parent in unique_paths):
                final_paths.append(p)

        final_params = []
        for p in final_paths:
            final_params.extend(["--bind", str(p)])
        return final_params

    def generate_gpu_args() -> List[str]:
        params = []
        if shutil.which("nvidia-smi") or any("nvidia" in path.lower() for path in os.listdir("/dev")):
            params.extend(["--nv"])
        if shutil.which("rocm-smi"):
            params.extend(["--rocm"])
        return params

class CondaTainer_Create:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Create.parser_create = parser.add_parser("create", help="Create a new SquashFS overlay")
        CondaTainer_Create.parser_create.add_argument(
            "name_versions",
            nargs="*",
            help="Name=Version of the overlay to create (e.g., bcftools=1.22)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-n", "--name",
            type=str,
            help="Custom name for the overlay file (If used, all packages will be included in a single overlay)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-p", "--prefix",
            type=str,
            help="Custom prefix for the overlay file"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-f", "--file",
            type=str,
            help="Conda environment file (YAML format) to create the overlay from"
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-fast",
            action="store_true",
            help="Use zstd compression level 3" + (" (default)" if Config.COMPRESS_ARGS == Config.ZSTD_FAST else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-medium",
            action="store_true",
            help="Use zstd compression level 8" + (" (default)" if Config.COMPRESS_ARGS == Config.ZSTD_MEDIUM else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd",
            action="store_true",
            help="Use zstd compression level 14" + (" (default)" if Config.COMPRESS_ARGS == Config.ZSTD else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--gzip",
            action="store_true",
            help="Use gzip compression" + (" (default)" if Config.COMPRESS_ARGS == Config.GZIP else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--lz4",
            action="store_true",
            help="Use LZ4 compression" + (" (default)" if Config.COMPRESS_ARGS == Config.LZ4 else "")
        )

    @staticmethod
    def parse_create_args(args):
        if not args.name_versions and not args.file:
            CondaTainer_Create.parser_create.error("At least one of --name_versions or --file must be provided.")
        if args.name_versions and args.file:
            CondaTainer_Create.parser_create.error("Cannot use both NAME=VERSION items and --file at the same time")
        if args.prefix and args.name:
            CondaTainer_Create.parser_create.error("Cannot use both --prefix and --name at the same time")
        if args.lz4:
            Config.COMPRESS_ARGS = Config.LZ4
        elif args.zstd_fast:
            Config.COMPRESS_ARGS = Config.ZSTD_FAST
        elif args.zstd_medium:
            Config.COMPRESS_ARGS = Config.ZSTD_MEDIUM
        elif args.zstd:
            Config.COMPRESS_ARGS = Config.ZSTD
        elif args.gzip:
            Config.COMPRESS_ARGS = Config.GZIP

        if args.name_versions:
            args.name_versions = [Utils.normalize_name_version(nv) for nv in args.name_versions]

        try:
            if os.path.isfile(Config.TMP_OVERLAY_PATH):
                Utils.print_error("A temporary overlay already exists. Maybe another process is running CondaTainer create?")
                Utils.print_message("If you are sure there is no other process running, please delete the temporary overlay file:")
                Utils.print_message(f"  rm {Config.TMP_OVERLAY_PATH}")
                exit(1)

            if args.file:
                if args.prefix:
                    CondaTainer_Create.create_sqf_from_file(args.file, prefix=args.prefix)
                else:
                    CondaTainer_Create.create_sqf_from_file(args.file, args.name)
            else:
                if args.name:
                    if Config.BAD_CHARS_REGEX.search(args.name):
                        CondaTainer_Create.parser_create.error("The custom name contains invalid characters. Avoid using spaces and special characters like <>:\"/\\|?*`$&;|![]#%@=+{}(),")
                        exit(1)
                    # Create a single overlay with all packages
                    packages = args.name_versions
                    overlay_filepath = f"{args.name}.sqf"
                    overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filepath)
                    relative_path = args.name.replace("--", "/")
                    if os.path.isfile(overlay_path):
                        Utils.print_message(f"Overlay {Utils.yellow_text(overlay_filepath)} already exists at {overlay_path}. Skipping creation.")
                        return

                    CondaTainer_Create.create_sqf(
                        packages=packages,
                        overlay_path=overlay_path,
                        relative_path=relative_path
                    )
                elif args.prefix:
                    prefix_name = os.path.basename(args.prefix)
                    if Config.BAD_CHARS_REGEX.search(prefix_name):
                        CondaTainer_Create.parser_create.error("The custom prefix contains invalid characters. Avoid using spaces and special characters like <>:\"/\\|?*`$&;|![]#%@=+{}(),")
                        exit(1)

                    prefix_abs_path = os.path.abspath(args.prefix)
                    os.makedirs(os.path.dirname(prefix_abs_path), exist_ok=True)

                    # Create a single overlay with all packages, using the prefix
                    packages = args.name_versions
                    overlay_path = f"{prefix_abs_path}.sqf"
                    config_path = f"{prefix_abs_path}.yaml"
                    relative_path = prefix_name.replace("--", "/")
                    if os.path.isfile(overlay_path):
                        Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(overlay_path))} already exists at {overlay_path}. Skipping creation.")
                        return

                    CondaTainer_Create.create_sqf(
                        packages=packages,
                        overlay_path=overlay_path,
                        relative_path=relative_path
                    )

                else:
                    if any('=' not in nv for nv in args.name_versions) and args.name_versions:
                        CondaTainer_Create.parser_create.error("Must specify the versions in the format NAME=VERSION")
                    # Create individual overlays for each package
                    for nv in args.name_versions:
                        CondaTainer_Create.auto_create_overlay_from_str(nv)
        except KeyboardInterrupt:
            Utils.print_message("Process interrupted by user. Cleaning up...")
            Utils.remove_tmp_overlay()
            shutil.rmtree(Config.CNT_DIR, ignore_errors=True)
            exit(1)

    @staticmethod
    def generate_config_yaml_content(name, packages: List[str]) -> str:
        content = f"name: {name}\n"
        content += "channels:\n"
        content += "  - conda-forge\n"
        content += "  - bioconda\n"
        content += "dependencies:\n"
        for pkg in packages:
            content += f"  - {pkg}\n"
        return content

    @staticmethod
    def create_sqf(packages: List[str], overlay_path: str, relative_path) -> bool:
        Utils.print_message(f"Building SquashFS overlay at {overlay_path} with packages: {Utils.yellow_text(' '.join(packages))}")

        Utils.create_tmp_overlay()

        yaml_path = os.path.join(Config.CONDATINER_DIR, "tmp_env.yaml")
        with open(yaml_path, 'w') as f:
            f.write(CondaTainer_Create.generate_config_yaml_content(relative_path.replace("/", "--"), packages))
        yaml_file_cmd = f"mv {os.path.abspath(yaml_path)} /cnt/{relative_path}/env.yaml"

        cmd_create = [
            Config.APPTAINER_PATH, "exec",
            "--overlay", Config.TMP_OVERLAY_PATH,
            "--bind", Config.CONDATINER_DIR,
            *Utils.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            micromamba create -r /ext3/conda -c conda-forge -c bioconda -y -p /cnt/{relative_path} {' '.join(packages)}

            {yaml_file_cmd}

            # Set permissions to ensure read access
            find /cnt -type f -exec chmod ug+rw,o+r {{}} \;
            find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \;
            mksquashfs /cnt {os.path.abspath(overlay_path)} -processors {Config.NCPUS} -keep-as-directory {Config.COMPRESS_ARGS} -b 1M
            """
        ]

        Utils.print_debug("[CREATE] Creating overlay with command:")
        Utils.print_debug(cmd_create)

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating {overlay_path} failed.")
            Utils.print_note("If apptainer cannot recognize zstd, please run `condatainer apptainer -f` to get the latest version.")
            Utils.print_note("If file/folder creation failed, please contact your system admin.")
            Utils.print_note("If cannot find the package. Please search the package on https://anaconda.org")
            Utils.remove_tmp_overlay()
            return False

        Utils.print_success(f"Overlay {overlay_path} created successfully. Removing temporary overlay...")
        os.chmod(overlay_path, 0o664)
        Utils.remove_tmp_overlay()
        return True

    @staticmethod
    def create_sqf_from_file(file_path: str, custom_name: Optional[str] = None, prefix: Optional[str] = None):
        if not file_path.endswith(('.yml', '.yaml')):
            Utils.print_error("The environment file must be in YAML format with .yml or .yaml extension.")
            return False

        file_path = os.path.abspath(file_path)
        file_basedir = os.path.dirname(file_path)

        Utils.print_message(f"Building SquashFS overlay from environment file {file_path}")
        if prefix:
            prefix_abs_path = os.path.abspath(prefix)
            os.makedirs(os.path.dirname(prefix_abs_path), exist_ok=True)

            overlay_abs_path = f"{prefix_abs_path}.sqf"
            custom_name = os.path.basename(prefix)
            relative_path = custom_name.replace("--", "/")

        else:
            if custom_name is None:
                name_regex = r"name:\s*(\S+)"
                with open(file_path, 'r') as f:
                    content = f.read()
                    match = re.search(name_regex, content)
                    if match:
                        custom_name = match.group(1)
                    else:
                        Utils.print_error("Could not find the environment name in the YAML file. Please provide a custom name using -n/--name.")
                        return False

            overlay_abs_path = os.path.join(Config.IMAGES_DIR, f"{custom_name}.sqf")
            relative_path = custom_name.replace("--", "/")

        if os.path.isfile(overlay_abs_path):
            Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} already exists at {overlay_abs_path}. Skipping creation.")
            return True
        Utils.create_tmp_overlay()

        cmd_create = [
            Config.APPTAINER_PATH, "exec",
            "--overlay", Config.TMP_OVERLAY_PATH,
            *Utils.generate_bind_args(Config.CONDATINER_DIR, file_basedir),
            *Utils.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            micromamba create -r /ext3/conda -c conda-forge -c bioconda -y -p /cnt/{relative_path} -f {file_path}

            cp {file_path} /cnt/{relative_path}/env.yaml

            # Set permissions to ensure read access
            find /cnt -type f -exec chmod ug+rw,o+r {{}} \;
            find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \;
            mksquashfs /cnt {os.path.abspath(overlay_abs_path)} -processors {Config.NCPUS} -keep-as-directory {Config.COMPRESS_ARGS} -b 1M
            """
        ]

        Utils.print_debug("[CREATE] Creating overlay with command:")
        Utils.print_debug(cmd_create)

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating {overlay_abs_path} from {file_path} failed.")
            Utils.print_note("If apptainer cannot recognize zstd, please run `condatainer apptainer -f` to get the latest version.")
            Utils.print_note("If file/folder creation failed, please contact your system admin.")
            Utils.print_note("If cannot resolve the environment file by libmamba, please please consider create img and manually install it with conda.")
            Utils.remove_tmp_overlay()
            return False

        Utils.print_success(f"Overlay {os.path.basename(overlay_abs_path)} created successfully from {file_path}. Removing temporary overlay...")
        os.chmod(overlay_abs_path, 0o664)
        Utils.remove_tmp_overlay()
        return True

    @staticmethod
    def get_env_settings_from_build_script(script_path) -> List[str]:
        """
        #ENV:KEY=VALUE lines in build script
        #ENVNOTE:KEY descriptions
        """
        env_settings = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Build script not found at {script_path}.")
            return env_settings

        parsed_lines = []

        with open(script_path, 'r') as f:
            lines = f.readlines()
            env_indices = [i for i, line in enumerate(lines) if line.startswith("#ENV:")]
            for env_index in env_indices:
                env_line = lines[env_index].strip()
                env_content = env_line[len("#ENV:"):].strip()
                key_value = env_content.split('=', 1)
                if len(key_value) != 2:
                    continue
                parsed_lines.append(env_content) # Store KEY=VALUE for later processing

                key, value = key_value
                note = ""
                # Check for corresponding #ENVNOTE line
                if env_index + 1 < len(lines):
                    next_line = lines[env_index + 1].strip()
                    if next_line.startswith("#ENVNOTE:"):
                        note = next_line[len("#ENVNOTE:"):].strip()
                parsed_lines.append(f"#ENVNOTE:{key}={note}")

        return parsed_lines

    @staticmethod
    def create_app_overlay(name: str, version: str):
        """
        Check if the script exists locally or remotely,
        - if yes, use build script,
        - if not, use micromamba installer.
        """
        overlay_filename = f"{name}--{version}.sqf"
        overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)
        relative_path = f"{name}/{version}"
        if os.path.isfile(overlay_path):
            Utils.print_message(f"Overlay {Utils.yellow_text(overlay_filename)} already exists at {overlay_path}. Skipping creation.")
            return True

        local_packages = Utils.get_local_build_scripts().keys()
        remote_packages = Utils.fetch_remote_build_scripts().keys()
        avail_packages = set(local_packages).union(set(remote_packages))
        if f"{name}={version}" not in avail_packages:
            return CondaTainer_Create.create_sqf(
                packages=[f"{name}={version}"],
                overlay_path=overlay_path,
                relative_path=relative_path
            )
        else:
            return CondaTainer_Create.create_app_overlay_from_build_script(name, version)

    @staticmethod
    def auto_create_overlay_from_str(name_version: str):
        # Accept both name=version and name/version formats by normalizing
        name_version = Utils.normalize_name_version(name_version)
        if '=' not in name_version:
            Utils.print_error("Must specify the version in the format NAME=VERSION")
            return False

        n = name_version.count('=')
        if n == 1:
            name, version = name_version.split('=', 1)
            return CondaTainer_Create.create_app_overlay(name, version)
        elif n == 2:
            assembly, data_type, version = name_version.split('=', 2)
            return CondaTainer_Create.create_ref_overlay_from_build_script(assembly, data_type, version)
        else:
            Utils.print_error("Too many '=' characters in the NAME=VERSION string.")
            return False

        return False

    @staticmethod
    def create_app_overlay_from_build_script(name: str, version: str):
        overlay_filename = f"{name}--{version}.sqf"
        overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)
        relative_path = f"{name}/{version}"
        if os.path.isfile(overlay_path):
            Utils.print_message(f"Overlay {Utils.yellow_text(overlay_filename)} already exists at {overlay_path}. Skipping creation.")
            return True

        is_remote = False
        script_path = os.path.join(Config.BUILD_SCRIPTS_DIR, name, version)
        if not os.path.isfile(script_path):
            # Try to fetch build script from remote metadata if configured
            metadata = Utils.fetch_remote_build_scripts()
            key = Utils.normalize_name_version(f"{name}={version}")
            if metadata and key in metadata:
                is_remote = True
                script_path = os.path.join(Config.CONDATINER_DIR, "tmp_build_script.sh")
                Utils.print_message(f"Downloading build script for {name}={version} from remote metadata...")
                url = metadata[key]
                if Utils.download_file(url, script_path):
                    Utils.print_message(f"Downloaded build script to {script_path}")
                else:
                    Utils.print_error(f"Failed to download build script for {name}={version} from {url}.")
                    return False
            else:
                Utils.print_error(f"Build script for {name} version {version} not found at {script_path}.")
                return False

        Utils.print_message(f"Building SquashFS overlay for {name} version {version} using build script.")

        Utils.create_tmp_overlay()

        cmd_create = [
            Config.APPTAINER_PATH, "exec",
            "--overlay", Config.TMP_OVERLAY_PATH,
            "--bind", Config.CONDATINER_DIR,
            "--env", "tmp_dir=/ext3/tmp",
            "--env", f"target_dir=/cnt/{relative_path}",
            "--env", f"app_name={name}",
            "--env", f"version={version}",
            "--env", f"app_name_version={name}-{version}",
            *Utils.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            bash {script_path}

            if [ $? -ne 0 ]; then
                echo "Build script for {name} version {version} failed."
                exit 1
            fi

            # Set permissions to ensure read access
            find /cnt -type f -exec chmod ug+rw,o+r {{}} \;
            find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \;
            mksquashfs /cnt {os.path.abspath(overlay_path)} -processors {Config.NCPUS} -keep-as-directory {Config.COMPRESS_ARGS} -b 1M
            """
        ]

        Utils.print_debug("[CREATE] Creating overlay with command:")
        Utils.print_debug(cmd_create)

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating {overlay_path} failed.")
            Utils.print_note("If apptainer cannot recognize zstd, please run `condatainer apptainer -f` to get the latest version.")
            Utils.print_note("If file/folder creation failed, please contact your system admin.")
            Utils.print_note("Some build script needs an interactive shell to accept download links or licenses.")
            Utils.remove_tmp_overlay()
            return False

        if not os.path.isfile(overlay_path):
            Utils.print_error(f"Error occurred during Overlay {overlay_path} creation.")
            Utils.remove_tmp_overlay()
            return False

        env_settings = CondaTainer_Create.get_env_settings_from_build_script(script_path)
        if env_settings:
            env_file_path = os.path.splitext(overlay_path)[0] + ".env"
            with open(env_file_path, 'w') as f:
                for line in env_settings:
                    line = line.replace('$app_root', f"/cnt/{name}/{version}")
                    f.write(f"{line}\n")
            Utils.print_message(f"Environment variables file created at {env_file_path}")
            os.chmod(env_file_path, 0o664)

        Utils.print_success(f"Overlay {overlay_path} created successfully. Removing temporary overlay...")
        os.chmod(overlay_path, 0o664)
        Utils.remove_tmp_overlay()
        if is_remote and os.path.isfile(script_path):
            os.remove(script_path)
        return True

    @staticmethod
    def ref_install_cleanup():
        shutil.rmtree(Config.CNT_DIR, ignore_errors=True)
        Utils.remove_tmp_overlay()

    @staticmethod
    def create_ref_overlay_from_build_script(assembly: str, data_type: str, version: str):
        overlay_filename = f"{assembly}--{data_type}--{version}.sqf"
        overlay_path = os.path.join(Config.REF_IMAGES_DIR, overlay_filename)
        relative_path = f"{assembly}/{data_type}/{version}"

        if os.path.isfile(overlay_path):
            Utils.print_message(f"Reference overlay {Utils.yellow_text(overlay_filename)} already exists at {overlay_path}. Skipping creation.")
            return True

        is_remote = False
        script_path = os.path.join(Config.BUILD_SCRIPTS_DIR, assembly, data_type, version)
        if not os.path.isfile(script_path):
            # Try to fetch reference build script from remote metadata if configured
            metadata = Utils.fetch_remote_build_scripts()
            key = Utils.normalize_name_version(f"{assembly}={data_type}={version}")
            if metadata and key in metadata:
                is_remote = True
                script_path = os.path.join(Config.CONDATINER_DIR, "tmp_ref_build_script.sh")
                Utils.print_message(f"Downloading reference build script for {assembly}={data_type}={version} from remote metadata...")
                url = metadata[key]
                if not Utils.download_file(url, script_path):
                    Utils.print_error(f"Failed to download reference build script for {assembly}={data_type}={version} from {url}.")
                    return False
                Utils.print_message(f"Downloaded reference build script to {script_path}")
            else:
                Utils.print_error(f"Build script for reference {assembly} {data_type} version {version} not found at {script_path}.")
                return False

        deps = Utils.get_dependencies_from_script(script_path)
        missing_deps = Utils.get_missing_overlays(deps)

        if os.path.exists(Config.CNT_DIR):
            Utils.print_warning(f"Temporary cnt directory {Config.CNT_DIR} already exists. Removing it first...")
            shutil.rmtree(Config.CNT_DIR, ignore_errors=True)

        if missing_deps:
            for md in missing_deps:
                if md.endswith(('.sqf', '.img', '.squashfs')):
                    Utils.print_error(f"Custom overlay {md} is missing. Cannot proceed with creating this overlay.")
                    return False
                Utils.print_message(f"Dependency overlay {Utils.yellow_text(md)} is missing. Creating it first...")
                if CondaTainer_Create.auto_create_overlay_from_str(md):
                    Utils.print_success(f"Dependency overlay {Utils.yellow_text(md)} created successfully.")
                else:
                    Utils.print_error(f"Failed to create dependency overlay {md}.")
                    return False

        Utils.print_message(f"Building reference SquashFS overlay for {assembly} {data_type} version {version} using build script.")

        target_dir = os.path.join(Config.CNT_DIR, relative_path)

        Utils.create_tmp_overlay()
        cmd_create = [
            Config.APPTAINER_PATH, "exec",
            "--overlay", Config.TMP_OVERLAY_PATH,
            "--bind", Config.CONDATINER_DIR,
            "--env", "tmp_dir=/ext3/tmp",
            "--env", f"target_dir={target_dir}",
            "--env", f"app_name_version={assembly}/{data_type}/{version}",
            "--env", "script_path=/dev/null",  # Prevent build script from downloading dependencies again
            "--env", f"PATH={CondaTainer_Exec.get_path_env(deps)}",
            *CondaTainer_Exec.generate_overlay_args(deps),
            *CondaTainer_Exec.get_overlay_env_configs(deps),
            *Utils.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            bash {script_path}
            """
        ]

        Utils.print_debug("[CREATE] Creating overlay with command:")
        Utils.print_debug(cmd_create)

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating reference overlay {overlay_path} failed.")
            CondaTainer_Create.ref_install_cleanup()
            return False

        if os.listdir(target_dir) == []:
            Utils.print_error(f"Reference overlay build script did not create any files in {target_dir}.")
            CondaTainer_Create.ref_install_cleanup()
            return False

        Utils.print_message(f"Creating SquashFS file at {overlay_path}...")
        cmd_mksqf = [
            Config.APPTAINER_PATH, "exec",
            "--overlay", Config.TMP_OVERLAY_PATH,
            "--bind", Config.CONDATINER_DIR,
            *Utils.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            # Set permissions to ensure read access
            find {Config.CNT_DIR} -type f -exec chmod 664 {{}} \;
            find {Config.CNT_DIR} -type d -exec chmod 775 {{}} \;
            mksquashfs {Config.CNT_DIR} {os.path.abspath(overlay_path)} -processors {Config.NCPUS} -keep-as-directory {Config.COMPRESS_ARGS} -b 1M
            """
        ]

        Utils.print_debug("[CREATE] Creating overlay with command:")
        Utils.print_debug(cmd_mksqf)

        try:
            subprocess.run(cmd_mksqf, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Creating SquashFS file {overlay_path} failed.")
            Utils.print_note("If apptainer cannot recognize zstd, please run `condatainer apptainer -f` to get the latest version.")
            Utils.print_note("If file/folder creation failed, please contact your system admin.")
            CondaTainer_Create.ref_install_cleanup()
            return False

        env_settings = CondaTainer_Create.get_env_settings_from_build_script(script_path)
        if env_settings:
            env_file_path = os.path.splitext(overlay_path)[0] + ".env"
            with open(env_file_path, 'w') as f:
                for line in env_settings:
                    line = line.replace('$app_root', f"/cnt/{assembly}/{data_type}/{version}")
                    f.write(f"{line}\n")
            Utils.print_message(f"Environment variables file created at {env_file_path}")
            os.chmod(env_file_path, 0o664)

        Utils.print_success(f"Reference overlay {overlay_path} created successfully. Cleaning up...")
        os.chmod(overlay_path, 0o664)
        CondaTainer_Create.ref_install_cleanup()
        if is_remote and os.path.isfile(script_path):
            os.remove(script_path)
        return True

class CondaTainer_Exec:
    IMG_WRITABLE = False

    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Exec.parser_exec = parser.add_parser("exec", help="Execute a command using a group of overlays")
        CondaTainer_Exec.parser_exec.add_argument(
            "-o", "--overlay",
            dest="overlays",
            action="append",
            help="Overlay package (can be used multiple times)"
        )
        CondaTainer_Exec.parser_exec.add_argument(
            "-w", "--writable-img",
            help="Make .img overlays writable (default: read-only)",
            action="store_true"
        )
        CondaTainer_Exec.parser_exec.add_argument(
            "command",
            nargs=argparse.REMAINDER,
            help="The command to run inside the container"
        )

    @staticmethod
    def parse_exec_args(args):
        if not args.command:
            CondaTainer_Exec.parser_exec.error("A command to execute must be provided.")

        CondaTainer_Exec.IMG_WRITABLE = args.writable_img

        CondaTainer_Exec.exec_command(args.overlays, args.command)

    @staticmethod
    def get_overlay_abs_paths(overlay_paths: List[str]) -> List[str]:
        overlay_abs_paths = []
        if not overlay_paths:
            return overlay_abs_paths
        for path in overlay_paths:
            # If it's an actual file path (exists or looks like a file), handle that first
            if path.endswith((".sqf", ".img", ".squashfs")):
                if os.path.isfile(path):
                    overlay_abs_paths.append(os.path.abspath(path))
                    continue
                else:
                    CondaTainer_Exec.parser_exec.error(f"Overlay file {path} not found.")
                    return []

            # Treat non-file inputs as package specs. Accept both name=version and name/version
            spec = Utils.normalize_name_version(path)
            filename = os.path.basename(spec)
            formatted_filename = filename.replace("=", "--")
            overlay_filename = f"{formatted_filename}.sqf"
            n = spec.count('=')
            if n < 2:
                overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)
            elif n == 2:
                overlay_path = os.path.join(Config.REF_IMAGES_DIR, overlay_filename)
            else:
                CondaTainer_Exec.parser_exec.error(f"Invalid overlay format: {path}. Too many '=' characters.")
                return []

            if not os.path.isfile(overlay_path):
                Utils.print_error(f"Overlay {overlay_filename} not found at {overlay_path}.")
                CondaTainer_Exec.parser_exec.error(f"Overlay {overlay_filename} not found.")
                return []
            overlay_abs_paths.append(overlay_path)
        return overlay_abs_paths

    @staticmethod
    def get_overlay_env_configs(overlay_paths: List[str]) -> List[str]:
        configs = { }
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(overlay_paths)
        for op in overlay_abs_paths:
            env_path = os.path.splitext(op)[0] + ".env"
            if not os.path.isfile(env_path):
                continue

            with open(env_path, 'r') as f:
                for line in f:
                    if line.startswith("#"):
                        continue
                    line = line.strip()
                    if line and '=' in line:
                        key, value = line.split('=', 1)
                        if key in configs:
                            Utils.print_message(f"Environment variable {key} is defined in multiple overlays. Using the value from {os.path.basename(op)}.")
                        configs[key] = value

        params = []
        for key, value in configs.items():
            params.extend(["--env", f"{key}={value}"])
        return params

    @staticmethod
    def get_overlay_env_notes(overlay_paths: List[str]) -> Dict[str, str]:
        notes = { }
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(overlay_paths)
        for op in overlay_abs_paths:
            env_path = os.path.splitext(op)[0] + ".env"
            if not os.path.isfile(env_path):
                continue

            with open(env_path, 'r') as f:
                for line in f:
                    if line.startswith("#ENVNOTE:"):
                        note_content = line[len("#ENVNOTE:"):].strip()
                        if '=' in note_content:
                            key, note = note_content.split('=', 1)
                            notes[key] = note
        return notes

    @staticmethod
    def get_path_env(overlay_paths: List[str]) -> str:
        paths = [ "/usr/sbin", "/usr/bin" ]
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(overlay_paths)
        for path in overlay_abs_paths:
            name = os.path.basename(path)
            name = os.path.splitext(name)[0]  # Remove extension
            name = name.replace("=", "/").replace("--", "/")
            if path.endswith(".img"):
                relative_path = f"/ext3/{name}/bin"
            elif path.endswith((".sqf", ".squashfs")):
                relative_path = f"/cnt/{name}/bin"
            else:
                Utils.print_warning(f"Unknown overlay file extension for {path}. Skipping PATH addition.")
                continue
            paths.insert(0, relative_path)
        return ":".join(paths)

    @staticmethod
    def generate_overlay_args(overlay_paths: List[str]) -> List[str]:
        mounts = []
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(overlay_paths)
        for op in overlay_abs_paths:
            if CondaTainer_Exec.IMG_WRITABLE and op.endswith(".img"):
                Utils.print_debug(f"[EXEC] Making overlay {Utils.blue_text(op)} writable.")
                mounts.extend(["--overlay", op])
            else:
                mounts.extend(["--overlay", op + ":ro"])
        if CondaTainer_Exec.IMG_WRITABLE:
            # Ensure only the last .img is writable
            n_img = len([o for o in overlay_abs_paths if o.endswith('.img')])
            if n_img > 1:
                for op in overlay_abs_paths:
                    if op.endswith('.img'):
                        n_img -= 1
                        if n_img >= 1:
                            mounts[mounts.index(op)] = op + ":ro"
        return mounts

    @staticmethod
    def exec_command(overlay_paths: List[str], command: List[str]) -> List[str]:
        path_env = CondaTainer_Exec.get_path_env(overlay_paths)
        env_params = CondaTainer_Exec.get_overlay_env_configs(overlay_paths)

        n_img = 0
        last_img = None
        writable_path = None
        for o in overlay_paths:
            if o.endswith('.img'):
                last_img = o
                n_img += 1

        if last_img is not None and CondaTainer_Exec.IMG_WRITABLE:
            writable_path = f"/ext3/{os.path.splitext(os.path.basename(last_img))[0].replace('=', '/').replace('--', '/')}"

        exec_cmd = [
            Config.APPTAINER_PATH, "exec",
            *CondaTainer_Exec.generate_overlay_args(overlay_paths),
            *env_params,
            "--env", f"PATH={path_env}",
            # "--env", f"PS1=CT \\w> ",
            "--env", "IN_CONDATINER=1",
            *Utils.generate_bind_args(Config.CONDATINER_DIR, os.path.abspath(".")),
            # "--bind", "/etc/localtime:/etc/localtime:ro",
            *(["--env", "WRITABLE_PATH=" + writable_path] if writable_path else []),
            *Utils.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            *command
        ]

        Utils.print_debug("[EXEC] Executing command:")
        Utils.print_debug(exec_cmd)

        if n_img > 1 and CondaTainer_Exec.IMG_WRITABLE:
            Utils.print_warning("Multiple img provided, but only the last one will be mounted as writable.")

        if Utils.is_in_interactive_shell():
            env_notes = CondaTainer_Exec.get_overlay_env_notes(overlay_paths)

            if env_notes:
                env_max_len = max(len(key) for key in env_notes.keys())
                Utils.print_message("Overlay envs:")
                for key, note in env_notes.items():
                    print(f"  {Utils.yellow_text(key.ljust(env_max_len))}: {note}")
                if writable_path:
                    print(f"  {Utils.yellow_text('WRITABLE_PATH'.ljust(env_max_len))}: {writable_path}")
                print("")
            else:
                if writable_path:
                    Utils.print_message(f"Overlay env:\n  {Utils.yellow_text('WRITABLE_PATH')}: {writable_path}\n")
        try:
            subprocess.run(exec_cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_warning("Command execution failed inside the container.")
            return False

class CondaTainer_Avail:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Avail.parser_avail = parser.add_parser("avail", help="Check available local build scripts")
        CondaTainer_Avail.parser_avail.add_argument(
            "terms",
            type=str,
            nargs="*",
            help="Search terms (AND logic applied)"
        )

    @staticmethod
    def parse_avail_args(args):
        local_packages = Utils.get_local_build_scripts()

        # Fetch remote metadata entries if configured
        remote_packages = {}
        if Config.REMOTE_METADATA_URL:
            remote_packages = Utils.fetch_remote_build_scripts()

        all_packages = list(local_packages.keys())
        # add remote-only packages with a marker
        for k in sorted(remote_packages.keys()):
            if k not in all_packages:
                all_packages.append(f"{k} (remote)")

        if args.terms:
            # match ONLY packages that contain *all* terms (logical AND)
            filtered_packages = [
                p for p in all_packages
                if all(re.search(re.escape(term), p, re.IGNORECASE) for term in args.terms)
            ]
        else:
            filtered_packages = all_packages

        if not filtered_packages:
            Utils.print_warning("No matching local or remote build scripts found.")
            return

        for pkg in sorted(filtered_packages):
            if args.terms:
                highlighted = pkg
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
                print(highlighted)
            else:
                print(pkg)

class CondaTainer_List:
    @staticmethod
    def list_overlays():
        if not os.path.isdir(Config.IMAGES_DIR):
            Utils.print_message("Overlays directory not found.")
            return

        overlay_files = [f for f in os.listdir(Config.IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
        if not overlay_files:
            Utils.print_message("No overlays found.")
            return

        name_versions_dict = {}

        for overlay in overlay_files:
            name_version = os.path.splitext(overlay)[0]
            if '--' in name_version:
                name, version = name_version.split('--', 1)
                if name in name_versions_dict:
                    name_versions_dict[name].append(version)
                else:
                    name_versions_dict[name] = [version]
            else:
                name_versions_dict[name_version] = [f"(conda env, config: /cnt/{name_version.replace('--', '/')}/env.yml)"]

        name_col_width = max(len(name) for name in name_versions_dict.keys())
        print("Available app overlays:")
        for name in sorted(name_versions_dict.keys()):
            print(f"{Utils.yellow_text(name.ljust(name_col_width))}: {', '.join(sorted(name_versions_dict[name]))}")

        ref_overlay_files = [f for f in os.listdir(Config.REF_IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
        if ref_overlay_files:
            print("\nAvailable reference overlays:")
            for overlay in sorted(ref_overlay_files):
                name_version = os.path.splitext(overlay)[0]
                print(name_version.replace('--', '='))

class CondaTainer_Info:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Info.parser_info = parser.add_parser("info", help="Show information about a specific overlay")
        CondaTainer_Info.parser_info.add_argument(
            "overlay",
            type=str,
            help="Overlay package (e.g., bcftools=1.22)"
        )

    @staticmethod
    def parse_info_args(args):
        installed_overlays_dict = Utils.get_installed_overlays()
        overlay = Utils.normalize_name_version(args.overlay)
        if overlay in installed_overlays_dict.keys(): # installed overlay
            overlay_path = installed_overlays_dict[overlay]
        else: # external overlay
            overlay_path = os.path.abspath(args.overlay)
            if not os.path.isfile(overlay_path):
                Utils.print_error(f"Overlay file {overlay_path} not found.")
                return

        print(f"Information for overlay {Utils.yellow_text(os.path.basename(overlay_path))}:")
        # Additional info can be added here, e.g., size, creation date, etc.
        file_size = os.path.getsize(overlay_path)
        print(f"Size: {file_size / (1024 * 1024):.2f} MB")
        if overlay_path.endswith((".sqf", ".squashfs")):
            print(f"Potential mount path: /cnt/{os.path.splitext(os.path.basename(overlay_path))[0].replace('=', '/').replace('--', '/')}")
        elif overlay_path.endswith(".img"):
            print(f"Potential mount path: /ext3/{os.path.splitext(os.path.basename(overlay_path))[0].replace('=', '/').replace('--', '/')}")

        env_path = os.path.splitext(overlay_path)[0] + ".env"
        if os.path.isfile(env_path):
            print("Environment variables:")
            with open(env_path, 'r') as f:
                for line in f:
                    print(f"  - {line.strip()}")

class CondaTainer_Dep:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Dep.parser_dep = parser.add_parser("dep", help="Get dependencies of a script")
        CondaTainer_Dep.parser_dep.add_argument(
            "script",
            type=str,
            help="Path to the script to analyze"
        )

class CondaTainer_Check:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Check.parser_check = parser.add_parser("check", help="Check if the dependencies of a script are installed")
        CondaTainer_Check.parser_check.add_argument(
            "script",
            type=str,
            help="Path to the script to check"
        )
        CondaTainer_Check.parser_check.add_argument(
            "-a", "--auto-install",
            action="store_true",
            help="Automatically install missing dependencies"
        )

    @staticmethod
    def parse_check_args(args):
        script_path_or_name = args.script
        if not os.path.isfile(script_path_or_name):
            script_path_or_name = Utils.normalize_name_version(script_path_or_name)
            local_build_scripts = Utils.get_local_build_scripts()
            Utils.print_debug(f"[CHECK] Checking for build script {script_path_or_name} locally and remotely...")
            if script_path_or_name in local_build_scripts:
                script_path = local_build_scripts[script_path_or_name]
                Utils.print_message(f"Found local build script {script_path}")
            elif script_path_or_name in Utils.fetch_remote_build_scripts():
                Utils.print_message(f"Downloading build script for {script_path_or_name} from remote metadata...")
                url = Utils.fetch_remote_build_scripts()[script_path_or_name]
                script_path = os.path.join(Config.CONDATINER_DIR, "tmp_build_script.sh")
                if Utils.download_file(url, script_path):
                    Utils.print_message(f"Downloaded build script to {script_path}")
                else:
                    Utils.print_error(f"Failed to download build script for {script_path_or_name} from {url}.")
                    return
            else:
                Utils.print_error(f"Build script for {script_path_or_name} not found.")
                return
        else:
            script_path = script_path_or_name

        deps = Utils.get_dependencies_from_script(script_path)
        for d in deps:
            Utils.print_message(f"Dependency found: {Utils.yellow_text(d)}")
        missing_deps = Utils.get_missing_overlays(deps)

        if not missing_deps:
            Utils.print_message("All dependencies are installed.")
            return

        Utils.print_message("Missing dependencies:")
        for md in missing_deps:
            Utils.print_message(f"  - {Utils.yellow_text(md)}")

        if args.auto_install:
            Utils.print_message("Attempting to auto-install missing dependencies...")
            for md in missing_deps:
                if md.endswith(('.sqf', '.img', '.squashfs')):
                    Utils.print_error(f"Custom overlay {md} is missing. Cannot proceed with auto-installation.")
                    continue
                if CondaTainer_Create.auto_create_overlay_from_str(md):
                    Utils.print_success(f"Dependency overlay {Utils.yellow_text(md)} created successfully.")
                else:
                    Utils.print_error(f"Failed to create dependency overlay {md}.")
        else:
            Utils.print_message("Run the command again with -a or --auto-install to automatically install missing dependencies.")

class CondaTainer_Run:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Run.parser_run = parser.add_parser("run", help="Run a script and auto-solve the dependencies by #DEP tags")
        CondaTainer_Run.parser_run.add_argument(
            "script",
            type=str,
            help="Path to the script to run"
        )
        CondaTainer_Run.parser_run.add_argument(
            "-a", "--auto-install",
            action="store_true",
            help="Automatically install missing dependencies"
        )
        CondaTainer_Run.parser_run.add_argument(
            "-w", "--writable-img",
            help="Make .img overlays writable (default: read-only)",
            action="store_true"
        )
        CondaTainer_Run.parser_run.add_argument(
            "script_args",
            nargs=argparse.REMAINDER,
            help="Arguments to pass to the script"
        )

    @staticmethod
    def parse_args_in_script(script_path: str) -> List[str]:
        args = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Script file {script_path} not found.")
            return args

        with open(script_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith("#CNT"):
                    arg_line = line[len("#CNT"):].strip()
                    args.append(arg_line)
        return args

    @staticmethod
    def parse_run_args(args):
        script_path = args.script
        if not os.path.isfile(script_path):
            CondaTainer_Run.parser_run.error(f"Script file {script_path} not found.")
        script_args = args.script_args

        args_from_script = CondaTainer_Run.parse_args_in_script(args.script)
        merged = args_from_script + sys.argv[2:]
        args = CondaTainer_Run.parser_run.parse_args(merged)

        if Config.DEBUG and args_from_script:
            Utils.print_debug("[RUN] Additional script arguments found:")
            for sa in args_from_script:
                Utils.print_debug(f"  {sa}")

        deps = Utils.get_dependencies_from_script(script_path)
        missing_deps = Utils.get_missing_overlays(deps)

        if missing_deps:
            Utils.print_message("Missing dependencies:")
            for md in missing_deps:
                Utils.print_message(f"  - {Utils.yellow_text(md)}")

            if args.auto_install:
                Utils.print_message("Attempting to auto-install missing dependencies...")
                for md in missing_deps:
                    if md.endswith(('.sqf', '.img', '.squashfs')):
                        Utils.print_error(f"Custom overlay {md} is missing. Cannot proceed with running the script.")
                        return
                    if CondaTainer_Create.auto_create_overlay_from_str(md):
                        Utils.print_success(f"Dependency overlay {Utils.yellow_text(md)} created successfully.")
                    else:
                        Utils.print_error(f"Failed to create dependency overlay {md}. Cannot proceed with running the script.")
                        return
            else:
                Utils.print_message("Run the command again with -a or --auto-install to automatically install missing dependencies.")
                return

        if args.writable_img:
            CondaTainer_Exec.IMG_WRITABLE = True

        Utils.print_message("All dependencies are installed. Running the script...")
        CondaTainer_Exec.exec_command(deps, ["/bin/bash", script_path] + script_args)

class CondaTainer_Apptainer:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Apptainer.parser_apptainer = parser.add_parser("apptainer", help="Get latest Apptainer executable from conda-forge")

        CondaTainer_Apptainer.parser_apptainer.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm installation"
        )

        CondaTainer_Apptainer.parser_apptainer.add_argument(
            "-f", "--force",
            action="store_true",
            help="Force re-installation even if Apptainer is already installed"
        )

    @staticmethod
    def parse_apptainer_args(args):
        if os.path.isdir(Config.LOCAL_APPTAINER_DIR) and not args.force:
            Utils.print_message(f"Apptainer executable already exists at {Config.LOCAL_APPTAINER_DIR}. Use -f or --force to re-install.")
            return

        if not args.yes:
            confirm = input(f"Are you sure you want to install Apptainer to {Config.LOCAL_APPTAINER_DIR}? [y/N]: ")
            if confirm.lower() != 'y':
                Utils.print_message("Installation cancelled by user.")
                return

        CondaTainer_Apptainer.install_apptainer(args.force)

    @staticmethod
    def secure_local_micromamba():
        if os.path.exists(Config.LOCAL_MICROMAMBA_BIN):
            return True

        # Detect architecture
        machine = platform.machine()
        if machine in ("aarch64", "ppc64le", "arm64"):
            ARCH = machine
        else:
            ARCH = "64"

        release_url = f"https://github.com/mamba-org/micromamba-releases/releases/latest/download/micromamba-linux-{ARCH}"
        if Utils.download_file(release_url, Config.LOCAL_MICROMAMBA_BIN):
            os.chmod(Config.LOCAL_MICROMAMBA_BIN, 0o775)
            Utils.print_success(f"Micromamba downloaded successfully to {Config.LOCAL_MICROMAMBA_BIN}.")
            return True
        else:
            Utils.print_error("Failed to download Micromamba.")
            return False

    @staticmethod
    def install_apptainer(force: bool = False):
        if not CondaTainer_Apptainer.secure_local_micromamba():
            Utils.print_error("Cannot proceed with Apptainer installation without Micromamba.")
            return

        if not force and os.path.isdir(Config.LOCAL_APPTAINER_DIR):
            Utils.print_message(f"Apptainer already exists at {Config.LOCAL_APPTAINER_DIR}. Use -f or --force to re-install.")
            return

        Utils.print_message("Installing Apptainer using Micromamba...")
        cmd_install = [
            Config.LOCAL_MICROMAMBA_BIN, 
            "-r", os.path.join(Config.CONDATINER_DIR, "micromamba_env"),
            "create", "-c", "conda-forge",
            "-p", Config.LOCAL_APPTAINER_DIR,
            "-y",
            "apptainer"
        ]

        Utils.print_debug("[APPTAINER] Installing Apptainer with command:")
        Utils.print_debug(cmd_install)

        try:
            subprocess.run(cmd_install, check=True)
            Utils.print_success(f"Apptainer installed successfully to {Config.APPTAINER_PATH}.")
            Utils.print_message("Cleaning up Micromamba environment...")
            shutil.rmtree(os.path.join(Config.CONDATINER_DIR, "micromamba_env"), ignore_errors=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Failed to install Apptainer.")

class CondaTainer_Update:
    script_url = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/bin/condatainer"

    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Update.parser_update = parser.add_parser("update", help="Update CondaTainer to the latest version")
        CondaTainer_Update.parser_update.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm update"
        )

    @staticmethod
    def parse_update_args(args):
        print("Are you sure to download and replace the current script from GitHub? [y/N]: ", end="", flush=True)
        if not args.yes:
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Update cancelled by user.")
                return

        Utils.print_message("Downloading the latest CondaTainer script...")
        Utils.download_file(CondaTainer_Update.script_url, Config.SCRIPT_PATH + ".tmp")
        os.chmod(Config.SCRIPT_PATH + ".tmp", 0o775)
        shutil.move(Config.SCRIPT_PATH + ".tmp", Config.SCRIPT_PATH)
        Utils.print_success("CondaTainer updated successfully.")

if __name__ == "__main__":
    main()
