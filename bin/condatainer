#!/usr/bin/env python3
import os
import sys
import subprocess
import re
import shutil
import argparse
import json
import urllib.request
import platform
import stat
from pathlib import Path
from typing import Dict, List, Optional, Tuple

os.umask(0o002)

class Config:
    VERSION = "1.0.2"
    # Remote settings
    debug = False
    use_sbatch = True
    GITHUB_REPO = "Justype/condatainer"
    REMOTE_METADATA_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/metadata/build-scripts.json.gz"
    MODGEN_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/bin/modgen"
    CONDATAINER_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/bin/condatainer"
    GIT_RAW_URL_PREFIX = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/"

    # Folder paths
    SCRIPT_PATH = os.path.abspath(__file__)
    SCRIPT_NAME = os.path.basename(SCRIPT_PATH)
    PROGRAM_DIR = os.path.dirname(SCRIPT_PATH)
    CONDATINER_DIR = os.path.abspath(os.path.join(PROGRAM_DIR, ".."))

    BUILD_SCRIPTS_DIR = os.path.join(CONDATINER_DIR, "build-scripts")
    IMAGES_DIR = os.path.join(CONDATINER_DIR, "images")
    REF_IMAGES_DIR = os.path.join(CONDATINER_DIR, "ref-images")
    TMP_DIR = os.path.join(CONDATINER_DIR, "tmp")
    LOGS_DIR = os.path.join(CONDATINER_DIR, "logs")

    # Local apptainer
    SYSTEM_APPTAINER_BIN = shutil.which("apptainer")
    LOCAL_APPTAINER_DIR = os.path.join(CONDATINER_DIR, "apptainer")
    LOCAL_APPTAINER_BIN = os.path.join(LOCAL_APPTAINER_DIR, "bin", "apptainer")
    LOCAL_MICROMAMBA_BIN = os.path.join(CONDATINER_DIR, "bin", "micromamba")

    # File paths
    BASE_IMAGE_DEF = os.path.join(BUILD_SCRIPTS_DIR, "base_image.def")
    BASE_IMAGE_SIF = os.path.join(IMAGES_DIR, "base_image.sif")
    APPTAINER_BIN = LOCAL_APPTAINER_BIN if os.path.isfile(LOCAL_APPTAINER_BIN) else SYSTEM_APPTAINER_BIN
    BAD_CHARS_REGEX = re.compile(r'[<>:"/\\|?*\0\s\'`$&;|!\[\]#%@=+{}(),]')

    # Utils
    NCPUS = os.environ.get("SLURM_CPUS_PER_TASK", 4)
    GZIP_FAST = "-comp gzip -Xcompression-level 3"
    GZIP = "-comp gzip"
    ZSTD_FAST = "-comp zstd -Xcompression-level 3"
    ZSTD_MEDIUM = "-comp zstd -Xcompression-level 8"
    ZSTD = "-comp zstd -Xcompression-level 14"
    ZSTD_HIGH = "-comp zstd -Xcompression-level 18"
    LZ4 = "-comp lz4"
    compress_args = LZ4

def adjust_compression_args_based_on_apptainer_version():
    """Change to ZSTD_MEDIUM if apptainer version >= 1.4.0"""
    if Config.APPTAINER_BIN is None:
        return
    try:
        result = subprocess.run([Config.APPTAINER_BIN, "--version"], capture_output=True, text=True)
        version_match = re.search(r"apptainer version (\d+)\.(\d+)", result.stdout)
        if version_match:
            major, minor = map(int, version_match.groups())
            if (major, minor) >= (1, 4):
                Config.compress_args = Config.ZSTD_MEDIUM
                Utils.print_debug(f"Apptainer version {major}.{minor} detected. Using ZSTD_MEDIUM compression.")
            else:
                Utils.print_debug(f"Apptainer version {major}.{minor} detected. Using LZ4 compression.")
    except Exception:
        pass

def main():
    adjust_compression_args_based_on_apptainer_version()
    parser = argparse.ArgumentParser(
        description="CondaTainer: Use apptainer/conda/squashFS to manage tools for HPC users.",
        epilog=f"For full manual, see https://github.com/{Config.GITHUB_REPO}/blob/main/docs/MANUAL_CNT.md")
    parser.add_argument("-v", "--version", action="version", version=Config.VERSION, help="Show the version of CondaTainer", default=argparse.SUPPRESS)
    parser.add_argument("--debug", action="store_true", help="Enable debug mode with verbose output")
    parser.add_argument("-n", "--no-sbatch", "--local", dest="no_sbatch", action="store_true", help="Run all operations locally without using sbatch")
    subparsers = parser.add_subparsers(dest="action", metavar="COMMAND", required=True, help="Available actions")

    CondaTainer_Overlay.add_parser_arguments(subparsers)
    CondaTainer_Create.add_parser_arguments(subparsers)
    CondaTainer_Avail.add_parser_arguments(subparsers)
    CondaTainer_List.add_parser_arguments(subparsers)
    CondaTainer_Remove.add_parser_arguments(subparsers)
    CondaTainer_Exec.add_parser_arguments(subparsers)
    CondaTainer_Check.add_parser_arguments(subparsers)
    CondaTainer_Run.add_parser_arguments(subparsers)
    CondaTainer_Info.add_parser_arguments(subparsers)
    CondaTainer_Apptainer.add_parser_arguments(subparsers)
    CondaTainer_Update.add_parser_arguments(subparsers)
    CondaTainer_ModGen.add_parser_arguments(subparsers)

    args = parser.parse_args()
    if args.debug:
        Config.debug = True
        Utils.print_debug("Debug mode enabled")
        Utils.print_debug(f"CondaTainer Version: {Config.VERSION}")
        Utils.print_debug(f"Apptainer Path: {Config.APPTAINER_BIN}")
    if args.no_sbatch:
        Config.use_sbatch = False
        Utils.print_debug("No sbatch mode enabled")
    adjust_compression_args_based_on_apptainer_version()

    if args.action in ("create", "install", "i"):
        CondaTainer_Create.parse_create_args(args)
    elif args.action == "exec":
        CondaTainer_Exec.parse_exec_args(args)
    elif args.action == "e":
        CondaTainer_Exec.parse_e_args(args)
    elif args.action in ("check", "c"):
        CondaTainer_Check.parse_check_args(args)
    elif args.action in ("run", "r"):
        CondaTainer_Run.parse_run_args(args)
    elif args.action == "info":
        CondaTainer_Info.parse_info_args(args)
    elif args.action in ("avail", "av"):
        CondaTainer_Avail.parse_avail_args(args)
    elif args.action in ("list", "ls"):
        CondaTainer_List.parse_list_args(args)
    elif args.action in ("remove", "delete", "uninstall", "rm", "del"):
        CondaTainer_Remove.parse_remove_args(args)
    elif args.action in ("overlay", "o"):
        CondaTainer_Overlay.parse_overlay_args(args)
    elif args.action == "apptainer":
        CondaTainer_Apptainer.parse_apptainer_args(args)
    elif args.action == "self-update":
        CondaTainer_Update.parse_update_args(args)
    elif args.action == "modgen":
        CondaTainer_ModGen.parse_modgen_args(args)

class Utils:
    remote_build_scripts_links: Optional[Dict[str, str]] = None
    local_build_scripts_paths: Optional[Dict[str, str]] = None

    @staticmethod
    def blue_text(text):
        return f"\033[94m{text}\033[0m"

    @staticmethod
    def red_text(text):
        return f"\033[91m{text}\033[0m"

    @staticmethod
    def yellow_text(text):
        return f"\033[93m{text}\033[0m"

    @staticmethod
    def green_text(text):
        return f"\033[92m{text}\033[0m"

    @staticmethod
    def print_message(message, end="\n", flush=True):
        print(f"[CondaTainer] {message}", end=end, flush=flush)

    @staticmethod
    def print_debug(debug_object, end="\n", flush=True):
        if Config.debug:
            print(f"[CondaTainer][{Utils.yellow_text('DEBUG')}]", end=" ", flush=True)
            print(debug_object, end=end, flush=flush)

    @staticmethod
    def print_note(message, end="\n", flush=True):
        print(f"[CondaTainer][{Utils.blue_text('NOTE')}] {message}", end=end, flush=flush)

    @staticmethod
    def print_warning(message, end="\n", flush=True):
        print(f"[CondaTainer][{Utils.yellow_text('WARNING')}] {message}", file=sys.stderr, end=end, flush=flush)
    @staticmethod
    def print_error(message, end="\n", flush=True):
        print(f"[CondaTainer][{Utils.red_text('ERROR')}] {message}", file=sys.stderr, end=end, flush=flush)

    @staticmethod
    def print_success(message, end="\n", flush=True):
        print(f"[CondaTainer][{Utils.green_text('SUCCESS')}] {message}", end=end, flush=flush)

    @staticmethod
    def normalize_name_version(name_version: str) -> str:
        """
        Normalize package spec formats so that `name/version`, `name=version`, `name@version`
        are treated the same. This converts slashes to equal signs and strips
        surrounding whitespace.
        """
        if not isinstance(name_version, str):
            return name_version
        return name_version.strip().replace('=', '/').replace('@', '/').replace('--', '/')

    @staticmethod
    def fetch_remote_build_scripts() -> dict:
        """
        Fetch JSON metadata from a remote http(s) URL

        Returns a name-version to link mapping dictionary.
        """
        url = Config.REMOTE_METADATA_URL
        if not url:
            return {}

        if Utils.remote_build_scripts_links is not None:
            return Utils.remote_build_scripts_links

        normalized = {}

        try:
            with urllib.request.urlopen(url) as resp:
                if url.endswith('.gz'):
                    import gzip
                    with gzip.GzipFile(fileobj=resp) as gz:
                        data = gz.read()
                    metadata = json.loads(data)
                else:
                    data = resp.read()
                    metadata = json.loads(data)

                for k in metadata:
                    rel = Utils.normalize_name_version(k)
                    link = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/{rel}"
                    normalized[rel] = link

        except Exception as e:
            Utils.print_warning(f"Failed to fetch remote metadata from {url}: {e}")
            return {}

        if normalized:
            Utils.remote_build_scripts_links = normalized

        return normalized

    @staticmethod
    def get_local_build_scripts():
        """
        Get a name-version to local script path mapping dictionary.
        """
        if Utils.local_build_scripts_paths is not None:
            return Utils.local_build_scripts_paths

        packages = {}
        if not os.path.isdir(Config.BUILD_SCRIPTS_DIR):
            return packages

        # os.walk mimics 'find' by visiting every subdirectory recursively
        for root, _, files in os.walk(Config.BUILD_SCRIPTS_DIR):
            for filename in files:
                # 1. skip non-build-script files
                if filename.endswith(('.py', '.sh')):
                    continue

                full_path = os.path.join(root, filename)

                # 2. skip template files
                if "template" in full_path:
                    continue

                # 3. generate key (relative path like 'apps/tool/v1')
                relative_key = os.path.relpath(full_path, Config.BUILD_SCRIPTS_DIR)

                if relative_key.endswith('.def'):
                    if relative_key.startswith('base_image'):
                        continue  # skip base_image scripts
                    relative_key = relative_key[:-4]  # remove .def suffix

                packages[relative_key] = full_path

        Utils.local_build_scripts_paths = packages
        return packages

    @staticmethod
    def download_file(url: str, dest_path: str) -> bool:
        """
        Download a remote file to `dest_path`. Creates parent dirs. Returns True on success.
        """
        try:
            os.makedirs(os.path.dirname(dest_path), mode=0o775, exist_ok=True)
            with urllib.request.urlopen(url) as resp, open(dest_path, 'wb') as out_f:
                out_f.write(resp.read())
            return True
        except Exception as e:
            Utils.print_error(f"Failed to download file from {url}: {e}")
            return False

    @staticmethod
    def download_executable(url: str, dest_path: str) -> bool:
        """
        Download a remote build script to `dest_path`. Creates parent dirs and
        marks the file executable. Returns True on success.
        """
        try:
            return Utils.download_file(url, dest_path) and os.chmod(dest_path, 0o775) is None
        except Exception as e:
            Utils.print_error(f"Failed to download build script from {url}: {e}")
            return False

    @staticmethod
    def get_dependencies_from_script(script_path: str) -> List[str]:
        """
        Get dependencies from a build script by parsing #DEP: lines.

        :param script_path: Description
        :type script_path: str
        :return: Description
        :rtype: List[str]
        """
        dependencies = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"[DEP] Build script not found at {script_path}")
            return dependencies

        module_load_regex = re.compile(r'^\s*(module\s+load)\s+(.+)$')

        with open(script_path, 'r') as f:
            for line in f:
                if line.startswith("#DEP:"):
                    dep_line = line[len("#DEP:"):].strip()
                    if dep_line.endswith((".sqf", ".img", ".squashfs")):
                        dependencies.append(dep_line)
                    else:
                        dependencies.append(Utils.normalize_name_version(dep_line))
                else:
                    line = line.strip()
                    if module_load_regex.match(line):
                        parts = line.split()
                        if len(parts) >= 3:
                            for mod in parts[2:]:
                                dependencies.append(Utils.normalize_name_version(mod))
                    elif line.startswith("ml"):
                        parts = line.split()
                        if len(parts) >= 2:
                            for mod in parts[1:]:
                                if mod in ("purge", "list", "avail", "av"):
                                    break
                                elif mod == "load":
                                    continue
                                dependencies.append(Utils.normalize_name_version(mod))

        dependencies = list(dict.fromkeys(dependencies))  # Remove duplicates while preserving order

        return dependencies

    @staticmethod
    def get_whatis_url_from_build_script(script_path: str, normalized_name_version: str) -> Tuple[str, str]:
        """
        Parse #WHATIS and #URL lines from a build script.

        Example lines in script:
            #WHATIS:Cell Ranger GRCh38 2024-A index
            #URL:https://www.10xgenomics.com/support/software/cell-ranger/downloads#reference-downloads

        Returns:
            (whatis_text, url_text)
            If not found, empty strings are returned.
        """
        package_name, version = normalized_name_version.split('/', 1)
        whatis = f"Load module {package_name} version {version}"
        url = "Not available"

        if not os.path.isfile(script_path):
            Utils.print_error(f"[WHATIS] Build script not found at {script_path}.")
            return whatis, url

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#WHATIS:"):
                    whatis = line[len("#WHATIS:"):].strip()
                elif line.startswith("#URL:"):
                    url = line[len("#URL:"):].strip()

                if whatis and url:
                    break

        return whatis, url

    @staticmethod
    def get_env_dict_from_build_script(script_path) -> Dict[str, Dict[str, str]]:
        """
        Parse #ENV:KEY=VALUE and #ENVNOTE:KEY description lines from build script.
        Returns a dict:
            {
                "KEY": {"value": "VALUE", "note": "description"},
                ...
            }
        Example lines in script:
            #ENV:STAR_INDEX_DIR=$app_root/star
            #ENVNOTE:STAR_INDEX_DIR STAR index dir
        """
        env_dict: Dict[str, Dict[str, str]] = {}

        if not os.path.isfile(script_path):
            Utils.print_error(f"[ENV] Build script not found at {script_path}.")
            return env_dict

        with open(script_path, "r") as f:
            lines = f.readlines()
            env_indices = [i for i, line in enumerate(lines) if line.strip().startswith("#ENV:")]

            for env_index in env_indices:
                line = lines[env_index].strip()
                if line.startswith("#ENV:"):
                    # Parse KEY=VALUE
                    content = line[len("#ENV:"):].strip()
                    if "=" not in content:
                        continue
                    key, value = content.split("=", 1)
                    env_dict[key] = {"value": value, "note": ""}

                if env_index + 1 < len(lines):
                    next_line = lines[env_index + 1].strip()
                    if next_line.startswith("#ENVNOTE:"):
                        note = next_line[len("#ENVNOTE:"):].strip()
                        env_dict[key]["note"] = note

        return env_dict

    @staticmethod
    def get_sbatch_args_from_build_script(script_path) -> List[str]:
        """
        Parse #SBATCH: lines from build script.
        Returns a list of sbatch arguments.
        Example line in script:
            #SBATCH --cpus-per-task=4
        """
        sbatch_args = []

        if not os.path.isfile(script_path):
            Utils.print_error(f"[SBATCH] Build script not found at {script_path}.")
            return sbatch_args

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#SBATCH"):
                    arg = line[len("#SBATCH"):].strip()
                    sbatch_args.append(arg)

        return sbatch_args

    @staticmethod
    def get_interactive_prompts(script_path: str) -> List[str]:
        """
        Parse #INTERACTIVE: lines from build script.
        Returns a list of interactive prompt descriptions.
        Example line in script:
            #INTERACTIVE:Please enter the license key
        """
        prompts = []

        if not os.path.isfile(script_path):
            Utils.print_error(f"[INTERACTIVE] Build script not found at {script_path}.")
            return prompts

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#INTERACTIVE:"):
                    prompt = line[len("#INTERACTIVE:"):].strip()
                    prompts.append(prompt)

        return prompts

    @staticmethod
    def share_to_ugo_recursive(path: str):
        """
        Recursively set permissions:
            - Files: ug+rw,o+r
            - Folders: ug+rwx,o+rx
        """
        for root, dirs, files in os.walk(path):
            # Set directories
            for d in dirs:
                dir_path = os.path.join(root, d)
                current_mode = os.stat(dir_path).st_mode
                # Add read/write/execute for user & group
                os.chmod(dir_path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                                            stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                                            stat.S_IROTH | stat.S_IXOTH) 

            # Set files
            for f in files:
                file_path = os.path.join(root, f)
                current_mode = os.stat(file_path).st_mode
                # Add read/write for user & group
                os.chmod(file_path, current_mode | stat.S_IRUSR | stat.S_IWUSR |
                                            stat.S_IRGRP | stat.S_IWGRP| stat.S_IROTH)

        # Finally, handle the top-level directory itself
        current_mode = os.stat(path).st_mode
        os.chmod(path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                                stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                                stat.S_IROTH | stat.S_IXOTH)

    @staticmethod
    def is_in_interactive_shell() -> bool:
        return sys.stdin.isatty() and sys.stdout.isatty()

    @staticmethod
    def is_sbatch_available() -> bool:
        """sbatch is available and we are not inside a SLURM job."""
        return (shutil.which("sbatch") is not None) and ("SLURM_JOB_ID" not in os.environ)

    @staticmethod
    def get_exec_environ() -> Dict[str, str]:
        """
        Get environment variables for apptainer exec commands.
        If using local apptainer binary, add local apptainer bin dir to PATH.
        """
        env = os.environ.copy()
        if Config.APPTAINER_BIN == Config.LOCAL_APPTAINER_BIN:
            local_apptainer_bin_dir = os.path.dirname(Config.LOCAL_APPTAINER_BIN)
            env["PATH"] = f"{local_apptainer_bin_dir}:{env.get('PATH', '')}"
        return env

class CondaTainer:
    PREBUILT_BASE_IMAGE_PLATFORMS = { "x86_64" } # aarch64 is not available yet

    @staticmethod
    def ensure_apptainer():
        if Config.APPTAINER_BIN is None:
            Utils.print_error("Apptainer not found in PATH.")
            Utils.print_note(f"Please consider running: {Utils.blue_text('ml apptainer')}")
            Utils.print_note("If Apptainer is not available, please contact your system administrator.")
            return False
        return True

    @staticmethod
    def ensure_base_def():
        base_def_path = Config.BASE_IMAGE_DEF
        if os.path.isfile(base_def_path):
            return True

        Utils.print_message("Base image definition file not found.")

        choice = "cpu"
        if Utils.is_in_interactive_shell():
            Utils.print_message("Select base image type to download:")
            Utils.print_message("  1) CPU-only (default)")
            Utils.print_message("  2) NVIDIA GPU support")
            Utils.print_message("  3) AMD GPU support")
            user_input = input("Enter choice [1-3]: ").strip()
            if user_input == "2":
                choice = "nv"
            elif user_input == "3":
                choice = "amd"
            else:
                Utils.print_warning("Invalid choice. Defaulting to CPU-only base image.")
        else:
            Utils.print_warning("Non-interactive shell detected. Defaulting to CPU-only base image.")

        url_insert = ""
        if choice != "cpu":
            url_insert = f"_{choice}"

        url = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/base_image{url_insert}.def"
        if not Utils.download_file(url, base_def_path):
            Utils.print_error("Failed to download base image definition file.")
            return False
        return True

    @staticmethod
    def try_download_prebuilt_base_image() -> bool:
        arch = platform.machine()
        if arch not in CondaTainer.PREBUILT_BASE_IMAGE_PLATFORMS:
            Utils.print_warning(f"Pre-built base image not available for architecture: {arch}")
            return False

        url = f"https://github.com/Justype/condatainer/releases/download/v1.0.2/base_image_{arch}.sif"
        Utils.print_message(f"Attempting to download pre-built base image for {arch}...")
        if not Utils.download_executable(url, Config.BASE_IMAGE_SIF):
            Utils.print_warning("Failed to download pre-built base image.")
            return False
        Utils.print_success("Pre-built base image downloaded successfully.")
        return True

    @staticmethod
    def ensure_base_image():
        """
        Exit the program if the base image does not exist, after attempting to build it.
        """
        os.makedirs(Config.IMAGES_DIR, mode=0o775, exist_ok=True)
        os.makedirs(Config.REF_IMAGES_DIR, mode=0o775, exist_ok=True)

        if not CondaTainer.ensure_apptainer():
            exit(1)
        if os.path.isfile(Config.BASE_IMAGE_SIF):
            return
        if not CondaTainer.ensure_base_def():
            exit(1)

        if Config.SYSTEM_APPTAINER_BIN is None:
            Utils.print_error("System Apptainer is required to build the base image.")
            Utils.print_note(f"Please consider running: {Utils.blue_text('ml apptainer')}")
            Utils.print_note("If Apptainer is not available, please contact your system administrator.")
            exit(1)

        Utils.print_message("Base images not found. Building base images...")
        cmd = [
            Config.SYSTEM_APPTAINER_BIN, "build", "--fakeroot",
            Config.BASE_IMAGE_SIF, Config.BASE_IMAGE_DEF,
        ]
        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Building base images failed.")
            if Utils.is_in_interactive_shell() and platform.machine() in CondaTainer.PREBUILT_BASE_IMAGE_PLATFORMS:
                Utils.print_message("Do you want to try downloading pre-built base images (CPU only)? [y/N]: ", end="", flush=True)
                choice = input().strip().lower()
                if choice == "y":
                    if CondaTainer.try_download_prebuilt_base_image():
                        return
                    else:
                        Utils.print_error("Pre-built base image download failed.")
            exit(1)
        Utils.print_success("Base images built.")
        cmd = [ Config.APPTAINER_BIN, "cache", "clean", "--force" ]
        subprocess.run(cmd, capture_output=True)
        os.chmod(Config.BASE_IMAGE_SIF, 0o775)
        Utils.print_message("Apptainer cache cleaned.")

    @staticmethod
    def get_tmp_overlay_path(normalized_name_version: str) -> str:
        return os.path.join(Config.TMP_DIR, f"{normalized_name_version.replace('/', '--')}.img")

    @staticmethod
    def get_cnt_dir_path(normalized_name_version: str) -> str:
        return os.path.join(Config.TMP_DIR, normalized_name_version.replace('/', '--'), "cnt")

    @staticmethod
    def create_cnt_dir(normalized_name_version: str) -> str:
        cnt_dir = CondaTainer.get_cnt_dir_path(normalized_name_version)
        os.makedirs(cnt_dir, mode=0o775, exist_ok=True)
        return cnt_dir

    @staticmethod
    def create_tmp_overlay(normalized_name_version: str, force: bool = False) -> Optional[str]:
        Utils.print_debug(f"[CREATE] Creating temporary overlay for {normalized_name_version} (force={force})")
        tmp_overlay_path = CondaTainer.get_tmp_overlay_path(normalized_name_version)
        if os.path.isfile(tmp_overlay_path):
            if force:
                Utils.print_warning(f"Temporary overlay for {Utils.yellow_text(normalized_name_version)} already exists. Removing it due to --force.")
                os.remove(tmp_overlay_path)
            else:
                return None

        os.makedirs(os.path.dirname(tmp_overlay_path), mode=0o775, exist_ok=True)

        Utils.print_message(f"Creating temporary SquashFS overlay for {Utils.yellow_text(normalized_name_version)}...")
        cmd = [
            Config.APPTAINER_BIN, "overlay", "create",
            "--sparse", "--size", "15360", 
            tmp_overlay_path
        ]

        Utils.print_debug(f"[CREATE] Creating temporary overlay with command: {cmd}")

        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Creating temporary overlay failed.")
            Utils.print_note("Please contact your system admin.")
            Utils.print_note("You can try ModGen to create Lmod modules without apptainer and overlays.")
            return None
        Utils.print_message("Temporary overlay created.")
        return tmp_overlay_path

    @staticmethod
    def remove_tmp_overlay(normalized_name_version: str) -> bool:
        tmp_overlay_path = CondaTainer.get_tmp_overlay_path(normalized_name_version)
        if os.path.isfile(tmp_overlay_path):
            os.remove(tmp_overlay_path)
            Utils.print_message("Temporary overlay removed.")
        return True

    @staticmethod
    def get_installed_overlays() -> Dict[str, str]:
        """
        Get name-version -> file path mapping of installed overlays.
        """
        overlays = {}
        if not os.path.isdir(Config.IMAGES_DIR):
            return overlays

        overlay_files = [f for f in os.listdir(Config.IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
        for overlay in overlay_files:
            name_version = os.path.splitext(overlay)[0]
            name_version = name_version.replace("--", "/")
            overlays[name_version] = os.path.join(Config.IMAGES_DIR, overlay)

        ref_overlay_files = [f for f in os.listdir(Config.REF_IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
        for overlay in ref_overlay_files:
            name_version = os.path.splitext(overlay)[0]
            name_version = name_version.replace("--", "/")
            overlays[name_version] = os.path.join(Config.REF_IMAGES_DIR, overlay)
        return overlays

    @staticmethod
    def is_overlay_installed(name_version_or_path: str) -> bool:
        if name_version_or_path.endswith(('.sqf', '.img', '.squashfs')):
            return os.path.isfile(name_version_or_path)
        installed_overlays = CondaTainer.get_installed_overlays().keys()
        return name_version_or_path in installed_overlays

    @staticmethod
    def get_missing_overlays(name_versions_or_paths: List[str]) -> List[str]:
        missing = []
        installed_overlays = CondaTainer.get_installed_overlays().keys()
        for nv in name_versions_or_paths:
            if nv.endswith(('.sqf', '.img', '.squashfs')):
                if not os.path.isfile(nv):
                    missing.append(nv)
            elif nv not in installed_overlays:
                missing.append(nv)
        return missing

    @staticmethod
    def generate_bind_args(*paths: Optional[str]) -> List[str]:
        """
        Accept multiple paths and return a list of absolute paths
        with --bind parameters suitable for binding in Singularity.

        Rules:
        - Resolve to absolute paths
        - Keep only one if multiple paths are the same
        - Skip paths that are children of another path
        """
        # Resolve all paths to absolute, normalized Path objects
        abs_paths = [Path(p).resolve() for p in paths if p] + [Path.home(), Path(".").resolve()]

        if os.environ.get("SCRATCH"):
            abs_paths.append(Path(os.environ["SCRATCH"]).resolve())

        # Remove duplicates
        unique_paths = []
        for p in abs_paths:
            if p not in unique_paths:
                unique_paths.append(p)

        # Filter out child paths
        final_paths = []
        for p in unique_paths:
            if not any(parent != p and p.is_relative_to(parent) for parent in unique_paths):
                final_paths.append(p)

        final_params = []
        for p in final_paths:
            final_params.extend(["--bind", str(p)])
        return final_params

    @staticmethod
    def generate_gpu_args() -> List[str]:
        params = []
        if shutil.which("nvidia-smi") or any("nvidia" in path.lower() for path in os.listdir("/dev")):
            params.extend(["--nv"])
        if shutil.which("rocm-smi"):
            params.extend(["--rocm"])
        return params

class BuildObject:
    def __init__(self, name_version: str):
        self.name_version = Utils.normalize_name_version(name_version)
        slash_count = self.name_version.count('/')
        self.build_script_path = ""
        self.dependencies = []
        self.is_conda = False
        self.is_remote = False
        self.sbatch = False
        self.sbatch_flags = []
        self.is_def = slash_count == 0
        self.is_shell = slash_count == 1
        self.is_ref = slash_count > 1
        self.ncpus = Config.NCPUS
        self.interactive_inputs = []

        # related paths
        self.cnt_dir_path = CondaTainer.get_cnt_dir_path(self.name_version)
        self.tmp_overlay_path = CondaTainer.get_tmp_overlay_path(self.name_version)
        overlay_filename = f"{self.name_version.replace('/', '--')}.sqf"
        if self.is_ref:
            self.target_overlay_path = os.path.join(Config.REF_IMAGES_DIR, overlay_filename)
        else:
            self.target_overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)

        if self.is_installed:
            return

        local_scripts = Utils.get_local_build_scripts()
        remote_scripts = Utils.fetch_remote_build_scripts()
        if self.name_version in local_scripts:
            self.build_script_path = local_scripts[self.name_version]
            self.is_remote = False
        elif self.name_version in remote_scripts:
            if self.is_def:
                self.build_script_path = os.path.join(Config.BUILD_SCRIPTS_DIR, f"{self.name_version}.def")
                link = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/{self.name_version}.def"
            else:
                self.build_script_path = os.path.join(Config.TMP_DIR, self.name_version.replace('/', '--') + ".sh")
                link = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/{self.name_version}"
            if not Utils.download_executable(link, self.build_script_path):
                raise RuntimeError(f"Failed to download remote build script for {self.name_version}.")
            self.is_remote = True
        elif self.is_def:
            raise RuntimeError(f"Build script for {self.name_version} not found locally or remotely.")
        else:
            self.is_conda = True

        if not (self.is_conda or self.is_def):
            self.dependencies = Utils.get_dependencies_from_script(self.build_script_path)
            self.sbatch_flags = Utils.get_sbatch_args_from_build_script(self.build_script_path)
            interactive_prompts = Utils.get_interactive_prompts(self.build_script_path)
            if interactive_prompts and not Utils.is_in_interactive_shell():
                raise RuntimeError(f"Build script for {self.name_version} requires interactive input, but no TTY is available.")
            for prompt in interactive_prompts:
                Utils.print_note("Build script requires input: " +prompt.replace('\\n', '\n'))
                user_input = input("Enter here: ")
                if "\n" in user_input or "\r" in user_input:
                    Utils.print_warning("Multiline input detected. Only the first line will be used.")
                    user_input = user_input.splitlines()[0]
                self.interactive_inputs.append(user_input)
            for flag in self.sbatch_flags:
                if flag.startswith("--cpus-per-task="):
                    try:
                        self.ncpus = int(flag.split("=")[1])
                    except ValueError:
                        pass
            self.sbatch = len(self.sbatch_flags) > 0

    def __str__(self) -> str:
        if self.is_shell:
            build_type = "Shell Script"
        elif self.is_def:
            build_type = "Apptainer Definition File"
        elif self.is_conda:
            build_type = "Conda Package"
        else:
            build_type = "Unknown"

        return f"""BuildObject:
    name_version: {self.name_version}
    build_script_type: {build_type}
    build_script_path: {self.build_script_path}
    dependencies: {self.dependencies}
    sbatch_flags: {self.sbatch_flags}
    tmp_overlay_path: {self.tmp_overlay_path}
    target_overlay_path: {self.target_overlay_path}
    cnt_dir_path: {self.cnt_dir_path}"""

    @property
    def relative_path(self) -> str:
        return self.name_version

    @property
    def is_installed(self) -> bool:
        return CondaTainer.is_overlay_installed(self.name_version)

    def create_tmp_overlay(self, force = False) -> bool:
        if CondaTainer.create_tmp_overlay(self.name_version, force=force) is None:
            return False
        return True

    def create_cleanup(self, failed: bool = False):
        if self.is_remote and os.path.isfile(self.build_script_path):
            os.remove(self.build_script_path)
        if os.path.isfile(self.tmp_overlay_path):
            os.remove(self.tmp_overlay_path)
        cnt_base_dir = os.path.dirname(self.cnt_dir_path)
        shutil.rmtree(cnt_base_dir, ignore_errors=True)
        if failed:
            if os.path.isfile(self.target_overlay_path):
                os.remove(self.target_overlay_path)

    def get_missing_dependencies(self) -> List[str]:
        return CondaTainer.get_missing_overlays(self.dependencies)

    def print_create_error_message(self, message: str = ""):
        Utils.print_error(f"Failed to build overlay for {Utils.yellow_text(self.name_version)}" + (f": {message}" if message else "."))
        Utils.print_note("If file/folder creation failed, please chmod/chgroup or contact your system admin.")

    def _build_conda(self) -> bool:
        name, version = self.name_version.split('/')

        if os.path.exists(self.target_overlay_path):
            Utils.print_warning(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} already exists at {Utils.blue_text(self.target_overlay_path)}. Skipping creation.")
            return True
        if not self.create_tmp_overlay(force=False):
            Utils.print_error(f"Temporary overlay for {Utils.yellow_text(self.name_version)} already exists. Maybe a build is still running?")
            Utils.print_note(f"If you are sure no build is running, please remove the temporary overlay at {Utils.blue_text(self.tmp_overlay_path)} and try again.")
            return False

        Utils.print_message(f"Building SquashFS overlay at {Utils.blue_text(self.target_overlay_path)} with packages: {Utils.yellow_text(f'{name}={version}')}" )

        environ = Utils.get_exec_environ()
        cmd_create = [
            Config.APPTAINER_BIN, "exec",
            "--env", "TMPDIR=/ext3/tmp",
            "--overlay", self.tmp_overlay_path,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            mkdir -p $TMPDIR
            micromamba create -r /ext3/conda -c conda-forge -c bioconda -y -p /cnt/{self.relative_path} {name}={version}

            echo "Setting permissions..."
            find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
            find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
            mksquashfs /cnt {os.path.abspath(self.target_overlay_path)} -processors {self.ncpus} -keep-as-directory {Config.compress_args} -b 1M
            """
        ]

        Utils.print_debug(f"[BUILD] Creating overlay with command: {cmd_create}")
        try:
            subprocess.run(cmd_create, check=True, env=environ)
        except subprocess.CalledProcessError:
            self.print_create_error_message()
            self.create_cleanup(failed=True)
            return False

        Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} created at {Utils.blue_text(self.target_overlay_path)}. Removing temporary overlay...")
        os.chmod(self.target_overlay_path, 0o664)
        self.create_cleanup(failed=False)
        return True

    def _build_def(self) -> bool:
        if os.path.exists(self.target_overlay_path):
            Utils.print_warning(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} already exists at {Utils.blue_text(self.target_overlay_path)}. Skipping creation.")
            return True
        
        if Config.SYSTEM_APPTAINER_BIN is None:
            Utils.print_error("System Apptainer is required to build overlays from definition files.")
            Utils.print_note(f"Please consider running: {Utils.blue_text('ml apptainer')}")
            Utils.print_note("If Apptainer is not available, please contact your system administrator.")
            return False

        environ = Utils.get_exec_environ()
        cmd_create = [
            Config.SYSTEM_APPTAINER_BIN, "build", "--fakeroot",
            self.tmp_overlay_path, # although named as sqf, but it's actually an sif image here (will dump to sqf later)
            self.build_script_path,
        ]

        Utils.print_debug(f"[BUILD] Building Apptainer SIF with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True, env=environ)
        except subprocess.CalledProcessError:
            self.print_create_error_message()
            self.create_cleanup(failed=True)
            return False

        try:
            squashfs_id = next(
                int(line.split("|")[0])
                for line in subprocess.check_output(
                    ["apptainer", "sif", "list", self.tmp_overlay_path],
                    text=True,
                ).splitlines()
                if "Squashfs" in line
            )
        except Exception as e:
            self.print_create_error_message(f"Failed to get SquashFS ID from SIF: {e}")
            self.create_cleanup(failed=True)
            return False

        Utils.print_message(f"Dumping to SquashFS file at {Utils.blue_text(self.target_overlay_path)}...")
        environ = Utils.get_exec_environ()
        cmd_mksqf = [
            Config.SYSTEM_APPTAINER_BIN, "sif", "dump",
            str(squashfs_id), self.tmp_overlay_path
        ]
        Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_mksqf}")
        try:
            with open(self.target_overlay_path, 'wb') as out_f:
                subprocess.run(cmd_mksqf, check=True, env=environ, stdout=out_f, stderr=subprocess.PIPE)
        except subprocess.CalledProcessError:
            self.print_create_error_message()
            self.create_cleanup(failed=True)
            return False

        Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} created at {Utils.blue_text(self.target_overlay_path)}. Removing temporary overlay...")
        os.chmod(self.target_overlay_path, 0o664)
        self.create_cleanup(failed=False)
        return True

    def _build_script(self, build_deps = False) -> bool:
        if os.path.exists(self.target_overlay_path):
            Utils.print_warning(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} already exists at {Utils.blue_text(self.target_overlay_path)}. Skipping creation.")
            return True
        if not self.create_tmp_overlay(force=False):
            Utils.print_error(f"Temporary overlay for {Utils.yellow_text(self.name_version)} already exists. Maybe a build is still running?")
            Utils.print_note(f"If you are sure no build is running, please remove the temporary overlay at {Utils.blue_text(self.tmp_overlay_path)} and try again.")
            return False

        Utils.print_message(f"Building SquashFS overlay at {Utils.blue_text(self.target_overlay_path)} using build script {Utils.yellow_text(self.build_script_path)}" )

        missing_deps = self.get_missing_dependencies()
        if missing_deps:
            if build_deps:
                Utils.print_message(f"Building missing dependencies for {Utils.yellow_text(self.name_version)}: {', '.join(missing_deps)}")
                for dep in missing_deps:
                    dep_obj = BuildObject(dep)
                    if not dep_obj.build():
                        Utils.print_error(f"Failed to build dependency {Utils.yellow_text(dep)} for {Utils.yellow_text(self.name_version)}.")
                        return False
                Utils.print_success(f"All dependencies for {Utils.yellow_text(self.name_version)} built successfully.")
            else:
                Utils.print_error(f"Missing dependencies for {Utils.yellow_text(self.name_version)}: {', '.join(missing_deps)}. Please install them first.")
            return False

        env_settings = [
            "--env", f"app_name={self.name_version.split('/')[0]}",
            "--env", f"version={self.name_version.split('/')[1]}",
            "--env", f"app_name_version={self.name_version}",
            "--env", f"tmp_dir=/ext3/tmp",
            "--env", "TMPDIR=/ext3/tmp",
        ]

        if self.is_ref:
            os.makedirs(self.cnt_dir_path, mode=0o775, exist_ok=True)
            target_dir = os.path.join(self.cnt_dir_path, self.name_version)
            env_settings.extend(["--env", f"target_dir={target_dir}"])
        else:
            env_settings.extend(["--env", f"target_dir=/cnt/{self.relative_path}"])

        environ = Utils.get_exec_environ()
        cmd_create = [
            Config.APPTAINER_BIN, "exec",
            *env_settings,
            "--env", f"SLURM_CPUS_PER_TASK={self.ncpus}",
            "--env", "IN_CONDATINER=1",
            "--env", f"PATH={CondaTainer_Exec.get_path_env(self.dependencies)}",
            *CondaTainer_Exec.generate_overlay_args(self.dependencies),
            "--overlay", self.tmp_overlay_path,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *CondaTainer_Exec.get_overlay_env_configs(self.dependencies),
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            "/bin/bash", "-c",
            f"""
            mkdir -p $TMPDIR
            bash {self.build_script_path}
            if [ $? -ne 0 ]; then
                echo "Build script {self.build_script_path} failed."
                exit 1
            fi
            """
        ]

        Utils.print_debug(f"[BUILD] Running build script with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True, input=("\n".join(self.interactive_inputs) + "\n").encode(), env=environ)
        except subprocess.CalledProcessError:
            Utils.print_error(f"Build script {Utils.blue_text(self.build_script_path)} failed.")
            self.create_cleanup(failed=True)
            return False

        if self.is_ref:
            # Reference overlay: ensure target_dir has files
            if os.listdir(target_dir) == []:
                Utils.print_error(f"Overlay build script did not create any files in {Utils.blue_text(target_dir)}.")
                self.create_cleanup(failed=True)
                return False

            Utils.share_to_ugo_recursive(self.cnt_dir_path)

            Utils.print_message(f"Creating SquashFS file at {Utils.blue_text(self.target_overlay_path)}...")
            environ = Utils.get_exec_environ()
            cmd_mksqf = [
                Config.APPTAINER_BIN, "exec",
                "--overlay", self.tmp_overlay_path,
                "--bind", Config.CONDATINER_DIR,
                Config.BASE_IMAGE_SIF,
                "/bin/bash", "-c",
                f"""
                mksquashfs {self.cnt_dir_path} {os.path.abspath(self.target_overlay_path)} -processors {self.ncpus} -keep-as-directory {Config.compress_args} -b 1M
                """
            ]
            Utils.print_debug(f"[BUILD] Creating overlay with command: {cmd_mksqf}")
            try:
                subprocess.run(cmd_mksqf, check=True, env=environ)
            except subprocess.CalledProcessError:
                self.print_create_error_message()
                self.create_cleanup(failed=True)
                return False
        else:
            # app overlay
            Utils.print_message(f"Creating SquashFS file at {Utils.blue_text(self.target_overlay_path)}...")
            environ = Utils.get_exec_environ()
            cmd_mksqf = [
                Config.APPTAINER_BIN, "exec",
                "--overlay", self.tmp_overlay_path,
                "--bind", Config.CONDATINER_DIR,
                Config.BASE_IMAGE_SIF,
                "/bin/bash", "-c",
                f"""
                echo "Setting permissions..."
                find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
                find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
                mksquashfs /cnt {os.path.abspath(self.target_overlay_path)} -processors {self.ncpus} -keep-as-directory {Config.compress_args} -b 1M
                """
            ]

            Utils.print_debug(f"[BUILD] Creating overlay with command: {cmd_mksqf}")
            try:
                subprocess.run(cmd_mksqf, check=True, env=environ)
            except subprocess.CalledProcessError:
                self.print_create_error_message()
                self.create_cleanup(failed=True)
                return False

        env_dict = Utils.get_env_dict_from_build_script(self.build_script_path)
        if env_dict:
            env_file_path = os.path.splitext(self.target_overlay_path)[0] + ".env"
            with open(env_file_path, 'w') as f:
                for env in env_dict:
                    value = env_dict[env]["value"].replace('$app_root', f"/cnt/{self.relative_path}")
                    f.write(f"{env}={value}\n")
                    note = env_dict[env].get("note", "")
                    if note:
                        f.write(f"#ENVNOTE:{env}={note}\n")
            Utils.print_message(f"ENV file created at {Utils.blue_text(env_file_path)}")
            os.chmod(env_file_path, 0o664)

        Utils.print_success(f"Overlay created at {Utils.blue_text(self.target_overlay_path)}. Cleaning up...")
        os.chmod(self.target_overlay_path, 0o664)
        self.create_cleanup(failed=False)
        return True

    def build(self, build_deps = False) -> bool:
        try:
            if self.is_conda:
                return self._build_conda()
            elif self.is_def:
                return self._build_def()
            else:
                return self._build_script(build_deps=build_deps)
        except KeyboardInterrupt:
            Utils.print_message(f"Build for {Utils.yellow_text(self.name_version)} interrupted by user.")
            self.create_cleanup(failed=True)
            return False

    def _create_sbatch_script(self) -> bool:
        sbatch_script_path = os.path.join(Config.TMP_DIR, f"sbatch_build_{self.name_version.replace('/', '--')}.sh")
        os.makedirs(Config.LOGS_DIR, mode=0o775, exist_ok=True)
        try:
            with open(sbatch_script_path, 'w') as f:
                f.write("#!/bin/bash\n")
                for flag in self.sbatch_flags:
                    if flag.startswith("--output"):
                        flag = "--output=" + os.path.join(Config.LOGS_DIR, f"CondaTainer_{self.name_version.replace('/', '--')}.out")
                    f.write(f"#SBATCH {flag}\n")
                f.write("\n")
                if Config.debug:
                    f.write(f"/usr/bin/time -v {Config.SCRIPT_PATH} create {self.name_version}\n")
                else:
                    f.write(f"{Config.SCRIPT_PATH} create {self.name_version}\n")
                f.write("echo SLURM_JOB_ID $SLURM_JOB_ID\n")
                f.write("rm -f " + sbatch_script_path + "\n") # Self-delete script after run
            os.chmod(sbatch_script_path, 0o775)
            return True
        except Exception as e:
            Utils.print_error(f"Failed to create sbatch script for {self.name_version}: {e}")
            return False

    def _submit_sbatch(self, dep_ids: List[str]) -> Optional[str]:
        sbatch_script_path = os.path.join(Config.TMP_DIR, f"sbatch_build_{self.name_version.replace('/', '--')}.sh")
        slurm_job_id_regex = re.compile(r'Submitted batch job (\d+)')
        if not self._create_sbatch_script():
            return None

        cmd = ["sbatch", sbatch_script_path]
        if dep_ids:
            dep_str = ":".join(dep_ids)
            cmd.insert(1, f"--dependency=afterok:{dep_str}")
        Utils.print_debug(f"[SBATCH] Submitting sbatch job with command: {cmd}")
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            match = slurm_job_id_regex.search(result.stdout)
            if match:
                job_id = match.group(1)
                if dep_ids:
                    Utils.print_message(f"Submitted sbatch {Utils.blue_text(job_id)} for {Utils.yellow_text(self.name_version)} with dependencies on {Utils.blue_text(', '.join(dep_ids))}.")
                else:
                    Utils.print_message(f"Submitted sbatch {Utils.blue_text(job_id)} for {Utils.yellow_text(self.name_version)}.")
                return job_id
            else:
                Utils.print_error(f"Failed to parse sbatch submission output: {result.stdout}")
                return None
        except subprocess.CalledProcessError as e:
            Utils.print_error(f"Failed to submit sbatch job for {Utils.yellow_text(self.name_version)}: {e.stderr}")
            if os.path.isfile(sbatch_script_path):
                os.remove(sbatch_script_path)
            return None

class BuildGraph:
    """
    BuildGraph expands given BuildMetadata items to include all transitive
    dependencies, detects cycles, produces a topologically-sorted order
    (dependencies before dependents) and separates items into two ordered
    lists:
      - download_metadata: BuildMetadata with sbatch == False
      - build_metadata: BuildMetadata with sbatch == True
    """

    def __init__(self, build_metadata_list: List[BuildObject]):
        # Use instance attributes (avoid shared mutable class attributes)
        self.graph: Dict[str, BuildObject] = {}
        self.download_metadata: List[BuildObject] = [] # No sbatch
        self.build_metadata: List[BuildObject] = [] # With sbatch
        self._build_job_ids: Dict[str, str] = {}

        # Seed graph with provided metadata
        for metadata in build_metadata_list:
            self.graph[metadata.name_version] = metadata
            if metadata.is_installed:
                Utils.print_message(f"Overlay {Utils.yellow_text(metadata.name_version)} is already installed. Skipping.")

        # Topologically sort the graph and separate into download/build lists
        visiting = set()
        visited = set()
        order: List[str] = []

        def visit(node: str):
            if node in visited:
                return
            if node in visiting:
                raise RuntimeError(f"Circular dependency detected involving '{node}'")
            visiting.add(node)
            node_meta = self.graph.get(node)
            if node_meta is None:
                visiting.remove(node)
                # Missing node should not normally happen because we expanded graph, but guard against it.
                raise RuntimeError(f"Unknown dependency '{node}' encountered during graph traversal")
            for dep in node_meta.dependencies:
                if dep not in self.graph:
                    # Expand on-the-fly if needed
                    self.graph[dep] = BuildObject(dep)
                visit(dep)
            visiting.remove(node)
            visited.add(node)
            order.append(node)

        for n in list(self.graph.keys()):
            if n not in visited:
                visit(n)

        for name_version in order:
            meta = self.graph[name_version]
            if Config.use_sbatch and meta.sbatch and Utils.is_sbatch_available():
                self.build_metadata.append(meta)
            else:
                self.download_metadata.append(meta)

    def run(self) -> bool:
        if not self._run_local_step():
            return False
        if not self._run_sbatch_step():
            return False
        return True

    def _run_local_step(self) -> bool:
        for metadata in self.download_metadata:
            if metadata.is_installed:
                continue
            Utils.print_message(f"Processing overlay {Utils.yellow_text(metadata.name_version)} (no sbatch)...")
            if not metadata.build():
                return False
        return True

    def _run_sbatch_step(self) -> bool:
        for metadata in self.build_metadata:
            Utils.print_message(f"Processing overlay {Utils.yellow_text(metadata.name_version)} (with sbatch)...")
            dep_ids = []
            for dep in metadata.dependencies:
                if dep in self._build_job_ids:
                    dep_ids.append(self._build_job_ids[dep])
                elif CondaTainer.is_overlay_installed(dep):
                    continue
                else:
                    Utils.print_error(f"Dependency {Utils.yellow_text(dep)} for {Utils.yellow_text(metadata.name_version)} is not installed and was not submitted via sbatch.")
                    return False
            job_id = metadata._submit_sbatch(dep_ids)
            if job_id is None:
                return False
            self._build_job_ids[metadata.name_version] = job_id
        return True

class CondaTainer_Create:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Create.parser_create = parser.add_parser(
            "create", aliases=["install", "i"],
            help="Create a new SquashFS overlay using conda or available build scripts")
        CondaTainer_Create.parser_create.add_argument(
            "name_versions",
            nargs="*",
            help="Name/Version or Name=Version or Name@Version to create (e.g., bcftools/1.22)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-n", "--name",
            type=str,
            help="Custom name for the overlay file (If used, all packages will be included in a single overlay)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-p", "--prefix",
            type=str,
            help="Custom prefix for the overlay file"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-f", "--file",
            type=str,
            help="Conda environment yaml (use with --name or --prefix)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-fast",
            action="store_true",
            help="Use zstd compression level 3" + (" (default)" if Config.compress_args == Config.ZSTD_FAST else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-medium",
            action="store_true",
            help="Use zstd compression level 8" + (" (default)" if Config.compress_args == Config.ZSTD_MEDIUM else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd",
            action="store_true",
            help="Use zstd compression level 14" + (" (default)" if Config.compress_args == Config.ZSTD else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-high",
            action="store_true",
            help="Use zstd compression level 19" + (" (default)" if Config.compress_args == Config.ZSTD_HIGH else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--gzip",
            action="store_true",
            help="Use gzip compression" + (" (default)" if Config.compress_args == Config.GZIP else "")
        )
        CondaTainer_Create.parser_create.add_argument(
            "--lz4",
            action="store_true",
            help="Use LZ4 compression" + (" (default)" if Config.compress_args == Config.LZ4 else "")
        )

    @staticmethod
    def parse_create_args(args):
        if not args.name_versions and not args.file:
            CondaTainer_Create.parser_create.error("At least one of name_versions or --file must be provided.")
        if args.name_versions and args.prefix:
            CondaTainer_Create.parser_create.error("name/version arguments cannot be used with --prefix")
        if args.prefix and args.name:
            CondaTainer_Create.parser_create.error("Cannot use both --prefix and --name at the same time")
        if args.file and not (args.name or args.prefix):
            CondaTainer_Create.parser_create.error("When using --file, either --name or --prefix must be provided")
        if args.lz4:
            Config.compress_args = Config.LZ4
        elif args.zstd_fast:
            Config.compress_args = Config.ZSTD_FAST
        elif args.zstd_medium:
            Config.compress_args = Config.ZSTD_MEDIUM
        elif args.zstd:
            Config.compress_args = Config.ZSTD
        elif args.gzip:
            Config.compress_args = Config.GZIP

        if args.name_versions:
            args.name_versions = [Utils.normalize_name_version(nv) for nv in args.name_versions]

        CondaTainer.ensure_base_image()
        if args.prefix:
            abs_path = os.path.abspath(args.prefix) + ".sqf"
            if os.path.isfile(abs_path):
                Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(abs_path))} already exists at {Utils.blue_text(abs_path)}. Skipping creation.")
                return
            Utils.print_debug(f"[CREATE] Creating overlay with prefix: {args.prefix}")
            CondaTainer_Create.create_env_sqf(abs_path, args.file, None)
        elif args.name:
            if "--" in args.name or "/" in args.name:
                CondaTainer_Create.parser_create.error("--name cannot contain '/' or '--'")
            abs_path = os.path.join(Config.IMAGES_DIR, f"{args.name}.sqf")
            if os.path.isfile(abs_path):
                Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(abs_path))} already exists at {Utils.blue_text(abs_path)}. Skipping creation.")
                return
            Utils.print_debug(f"[CREATE] Creating overlay with name: {args.name}")
            CondaTainer_Create.create_env_sqf(abs_path, args.file, args.name_versions)
        else:
            build_objects = [BuildObject(nv) for nv in args.name_versions]
            for bo in build_objects:
                Utils.print_debug(f"[CREATE] BuildObject created:\n{bo}")
            build_graph = BuildGraph(build_objects)
            build_graph.run()

    @staticmethod
    def create_cleanup(normalized_name_version: str, failed: bool = False):
        cnt_dir = CondaTainer.get_cnt_dir_path(normalized_name_version)
        cnt_dir = os.path.dirname(cnt_dir)
        shutil.rmtree(cnt_dir, ignore_errors=True)
        CondaTainer.remove_tmp_overlay(normalized_name_version)
        if failed:
            CondaTainer.remove_tmp_overlay(normalized_name_version)

    @staticmethod
    def create_env_sqf(overlay_abs_path: str, file_path: Optional[str], name_versions: Optional[List[str]]) -> bool:
        normalized_name_version = Utils.normalize_name_version(os.path.splitext(os.path.basename(overlay_abs_path))[0])
        to_bind_paths = [Config.CONDATINER_DIR]

        if file_path is not None:
            if not file_path.endswith(('.yml', '.yaml')):
                Utils.print_error("The environment file must be in YAML format with .yml or .yaml extension.")
                return False
            abs_file_path = os.path.abspath(file_path)
            to_bind_paths.append(os.path.dirname(abs_file_path))

            install_command = f"micromamba create -r /ext3/conda -c conda-forge -c bioconda -y -p /cnt/{normalized_name_version} -f {abs_file_path}"
            copy_command = f"cp {abs_file_path} /cnt/{normalized_name_version}/env.yaml"
        elif name_versions:
            parsed_name_versions = [nv.replace('/', '=') for nv in name_versions]
            install_command = "micromamba create -r /ext3/conda -c conda-forge -c bioconda -y -p /cnt/" + normalized_name_version + " " + " ".join(parsed_name_versions)
            copy_command = ""
        else:
            Utils.print_error("Either an environment file or name/version specifications must be provided.")
            return False

        Utils.print_message(f"Building SquashFS overlay at {Utils.blue_text(overlay_abs_path)} from environment file {Utils.blue_text(file_path)}")

        if os.path.isfile(overlay_abs_path):
            Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} already exists at {Utils.blue_text(overlay_abs_path)}. Skipping creation.")
            return True
        tmp_overlay_path = CondaTainer.create_tmp_overlay(normalized_name_version)
        if tmp_overlay_path is None:
            Utils.print_error(f"Temporary overlay {Utils.blue_text(tmp_overlay_path)} already exists. Please remove it first.")
            return False

        try:
            environ = Utils.get_exec_environ()
            cmd_create = [
                Config.APPTAINER_BIN, "exec",
                "--env", "TMPDIR=/ext3/tmp",
                "--overlay", tmp_overlay_path,
                *CondaTainer.generate_bind_args(*to_bind_paths),
                *CondaTainer.generate_gpu_args(),
                Config.BASE_IMAGE_SIF,
                "/bin/bash", "-c",
                f"""
                mkdir -p $TMPDIR
                {install_command}
                {copy_command}
                echo "Setting permissions..."
                find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
                find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
                mksquashfs /cnt {os.path.abspath(overlay_abs_path)} -processors {Config.NCPUS} -keep-as-directory {Config.compress_args} -b 1M
                """
            ]

            Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_create}")

            try:
                subprocess.run(cmd_create, check=True, env=environ)
            except subprocess.CalledProcessError:
                Utils.print_error(f"Creating {Utils.blue_text(overlay_abs_path)} from {Utils.blue_text(file_path)} failed.")
                Utils.print_note("If file/folder creation failed, please contact your system admin.")
                Utils.print_note("If cannot resolve the environment file by libmamba, please please consider create img and manually install it with conda.")
                CondaTainer_Create.create_cleanup(normalized_name_version, failed=True)
                return False

            if file_path:
                Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} created from {Utils.blue_text(file_path)}. Removing temporary overlay...")
            elif name_versions:
                Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} created using {','.join(name_versions)}. Removing temporary overlay...")
            os.chmod(overlay_abs_path, 0o664)
            CondaTainer_Create.create_cleanup(normalized_name_version)
            return True
        except KeyboardInterrupt:
            Utils.print_message(f"Creation of overlay {Utils.yellow_text(overlay_abs_path)} interrupted by user.")
            CondaTainer_Create.create_cleanup(normalized_name_version, failed=True)
            raise

class CondaTainer_Exec:
    is_img_writable = False

    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Exec.parser_exec = parser.add_parser("exec", help="Execute a command using overlays")
        CondaTainer_Exec.parser_exec.add_argument(
            "-o", "--overlay",
            dest="overlays",
            action="append",
            help="Overlay (can be used multiple times)"
        )
        CondaTainer_Exec.parser_exec.add_argument(
            "-k", "--keep",
            action="store_true",
            help="Do not try to parse command to installed overlays"
        )
        CondaTainer_Exec.parser_exec.add_argument(
            "-w", "--writable-img",
            help="Make .img overlays writable (default: read-only)",
            action="store_true"
        )
        CondaTainer_Exec.parser_exec.add_argument(
            "commands",
            nargs=argparse.REMAINDER,
            help="The command to run inside the container (if not provided, defaults to bash shell)"
        )
        CondaTainer_Exec.parser_e = parser.add_parser("e", help="Run bash using writable overlays")
        CondaTainer_Exec.parser_e.add_argument(
            "overlays",
            nargs="*",
            help="Overlay files to mount (can be .sqf, .squashfs, or .img)"
        )

    @staticmethod
    def parse_exec_args(args):
        CondaTainer.ensure_base_image()
        CondaTainer_Exec.is_img_writable = args.writable_img

        installed_overlays = CondaTainer.get_installed_overlays()

        overlay_final = []
        command_final = []

        if not args.keep and not args.overlays and args.commands:
            Utils.print_debug("[EXEC] Parsing commands to separate overlays and command...")
            for command in args.commands:
                if command.endswith(('.sqf', '.img', '.squashfs')):
                    overlay_final.append(command)
                elif Utils.normalize_name_version(command) in installed_overlays:
                    Utils.print_warning(f"Convert command {Utils.yellow_text(command)} to overlay")
                    overlay_final.append(command)
                else:
                    command_final.append(command)
        else:
            command_final = args.commands if args.commands else []

        overlay_final.extend(args.overlays if args.overlays else [])
        command_final = command_final if command_final else ["bash"]

        for i in range(len(overlay_final)):
            if not overlay_final[i].endswith(('.sqf', '.img', '.squashfs')):
                overlay_final[i] = installed_overlays.get(Utils.normalize_name_version(overlay_final[i]), overlay_final[i])
            if not os.path.isfile(overlay_final[i]):
                Utils.print_error(f"Overlay file {overlay_final[i]} not found.")
                exit(1)

        if not CondaTainer_Exec.exec_command(overlay_final, command_final):
            exit(1)

    @staticmethod
    def parse_e_args(args):
        CondaTainer.ensure_base_image()
        CondaTainer_Exec.is_img_writable = True

        overlay_final = args.overlays if args.overlays else []
        command_final = ["bash"]

        installed_overlays = CondaTainer.get_installed_overlays()

        for i in range(len(overlay_final)):
            if not overlay_final[i].endswith(('.sqf', '.img', '.squashfs')):
                overlay_final[i] = installed_overlays.get(Utils.normalize_name_version(overlay_final[i]), overlay_final[i])
            if not os.path.isfile(overlay_final[i]):
                Utils.print_error(f"Overlay file {overlay_final[i]} not found.")
                exit(1)

        if all(not o.endswith('.img') for o in overlay_final):
            pwd = os.getcwd()
            local_env_path = os.path.join(pwd, "env.img")
            if os.path.isfile(local_env_path):
                Utils.print_message(f"Autoload env.img at {Utils.blue_text(local_env_path)}")
                overlay_final.append(local_env_path)

        if not CondaTainer_Exec.exec_command(overlay_final, command_final):
            exit(1)

    @staticmethod
    def get_overlay_abs_paths(paths_or_name_version: List[str]) -> List[str]:
        overlay_abs_paths = []
        if not paths_or_name_version:
            return overlay_abs_paths
        for path in paths_or_name_version:
            # If it's an actual file path (exists or looks like a file), handle that first
            if path.endswith((".sqf", ".img", ".squashfs")):
                if os.path.isfile(path):
                    overlay_abs_paths.append(os.path.abspath(path))
                    continue
                else:
                    CondaTainer_Exec.parser_exec.error(f"Overlay file {path} not found.")
                    return []

            # Treat non-file inputs as package specs. Accept both name=version and name/version
            # map normalized separator '/' into filename-safe '--'
            normalized_spec = Utils.normalize_name_version(path)
            formatted_filename = normalized_spec.replace("/", "--")
            overlay_filename = f"{formatted_filename}.sqf"
            n = normalized_spec.count('/')
            if n < 2:
                overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)
            elif n == 2:
                overlay_path = os.path.join(Config.REF_IMAGES_DIR, overlay_filename)
            else:
                CondaTainer_Exec.parser_exec.error(f"Invalid overlay format: {path}. Too many '/' characters.")
                return []

            if not os.path.isfile(overlay_path):
                Utils.print_error(f"Overlay {Utils.yellow_text(overlay_filename)} not found at {Utils.blue_text(overlay_path)}.")
                CondaTainer_Exec.parser_exec.error(f"Overlay {overlay_filename} not found.")
                return []
            overlay_abs_paths.append(overlay_path)
        return overlay_abs_paths

    @staticmethod
    def get_overlay_env_configs(paths_or_name_version: List[str]) -> List[str]:
        configs = { }
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            env_path = os.path.splitext(op)[0] + ".env"
            if not os.path.isfile(env_path):
                continue

            with open(env_path, 'r') as f:
                for line in f:
                    if line.startswith("#"):
                        continue
                    line = line.strip()
                    if line and '=' in line:
                        key, value = line.split('=', 1)
                        if key in configs:
                            Utils.print_message(f"Environment variable {key} is defined in multiple overlays. Using the value from {os.path.basename(op)}.")
                        configs[key] = value

        params = []
        for key, value in configs.items():
            params.extend(["--env", f"{key}={value}"])
        return params

    @staticmethod
    def get_overlay_env_notes(paths_or_name_version: List[str]) -> Dict[str, str]:
        notes = { }
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            env_path = os.path.splitext(op)[0] + ".env"
            if not os.path.isfile(env_path):
                continue

            with open(env_path, 'r') as f:
                for line in f:
                    if line.startswith("#ENVNOTE:"):
                        note_content = line[len("#ENVNOTE:"):].strip()
                        if '=' in note_content:
                            key, note = note_content.split('=', 1)
                            notes[key] = note
        return notes

    @staticmethod
    def get_path_env(paths_or_name_version: List[str]) -> str:
        paths = [ "/usr/sbin", "/usr/bin" ]
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for path in overlay_abs_paths:
            name = os.path.basename(path)
            name = os.path.splitext(name)[0]  # Remove extension
            name = name.replace("=", "/").replace("--", "/")
            if path.endswith(".img"):
                relative_path = f"/ext3/{name}/bin"
            elif path.endswith((".sqf", ".squashfs")):
                relative_path = f"/cnt/{name}/bin"
            else:
                Utils.print_warning(f"Unknown overlay file extension for {path}. Skipping PATH addition.")
                continue
            paths.insert(0, relative_path)
        return ":".join(paths)

    @staticmethod
    def generate_overlay_args(paths_or_name_version: List[str]) -> List[str]:
        mounts = []
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            if CondaTainer_Exec.is_img_writable and op.endswith(".img"):
                Utils.print_debug(f"[EXEC] Making overlay {Utils.blue_text(op)} writable.")
                mounts.extend(["--overlay", op])
            else:
                mounts.extend(["--overlay", op + ":ro"])
        if CondaTainer_Exec.is_img_writable:
            # Ensure only the last .img is writable
            n_img = len([o for o in overlay_abs_paths if o.endswith('.img')])
            if n_img > 1:
                for op in overlay_abs_paths:
                    if op.endswith('.img'):
                        n_img -= 1
                        if n_img >= 1:
                            mounts[mounts.index(op)] = op + ":ro"
        return mounts

    @staticmethod
    def exec_command(paths_or_name_versions: List[str], command: List[str], capture_output: bool = False) -> bool:
        path_env = CondaTainer_Exec.get_path_env(paths_or_name_versions)
        env_params = CondaTainer_Exec.get_overlay_env_configs(paths_or_name_versions)

        n_img = 0
        last_img = None
        img_env = []
        writable_path = None
        if paths_or_name_versions:
            for o in paths_or_name_versions:
                if o.endswith('.img'):
                    last_img = o
                    n_img += 1

        if last_img is not None and CondaTainer_Exec.is_img_writable:
            img_name = os.path.splitext(os.path.basename(last_img))[0]
            img_name = Utils.normalize_name_version(img_name)

            img_env.extend([
                "--env", "MAMBA_ROOT_PREFIX=/cnt_conda",
                "--env", f"CONDA_PREFIX=/ext3/{img_name}",
                "--env", f"CONDA_DEFINE_ENV={img_name}",
                "--env", f"CNT_CONDA_PREFIX=/ext3/{img_name}",
                "--env", f"RETICULATE_PYTHON=/ext3/{img_name}/bin/python",
            ])

        environ = Utils.get_exec_environ()

        exec_cmd = [
            Config.APPTAINER_BIN, "exec",
            *CondaTainer_Exec.generate_overlay_args(paths_or_name_versions),
            *env_params,
            "--env", f"PATH={path_env}",
            "--env", "PS1=CNT \\w> ",
            "--env", "IN_CONDATINER=1",
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *img_env,
            *CondaTainer.generate_gpu_args(),
            Config.BASE_IMAGE_SIF,
            *command
        ]

        Utils.print_debug(f"[EXEC] Executing command: {exec_cmd}")

        if n_img > 1 and CondaTainer_Exec.is_img_writable:
            Utils.print_warning("Multiple img provided, but only the last one will be mounted as writable.")

        if Utils.is_in_interactive_shell() and not capture_output:
            env_notes = CondaTainer_Exec.get_overlay_env_notes(paths_or_name_versions)

            if env_notes:
                env_max_len = max(len(key) for key in env_notes.keys())
                Utils.print_message("Overlay envs:")
                for key, note in env_notes.items():
                    print(f"  {Utils.yellow_text(key.ljust(env_max_len))}: {note}")
                if writable_path:
                    print(f"  {Utils.yellow_text('CNT_CONDA_PREFIX'.ljust(env_max_len))}: {Utils.blue_text(writable_path)}")
                print("")
            else:
                if writable_path:
                    print(f"Overlay env:\n  {Utils.yellow_text('CNT_CONDA_PREFIX')}: {Utils.blue_text(writable_path)}\n")
        try:
            subprocess.run(exec_cmd, check=True, capture_output=capture_output, env=environ)
        except subprocess.CalledProcessError:
            Utils.print_warning("Command execution failed inside the container.")
            return False

        return True

class CondaTainer_Avail:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Avail.parser_avail = parser.add_parser(
            "avail", aliases=["av"],
            help="Check available local and remote build scripts")
        CondaTainer_Avail.parser_avail.add_argument(
            "terms",
            type=str,
            nargs="*",
            help="Search terms (AND logic applied)"
        )
        CondaTainer_Avail.parser_avail.add_argument(
            "-i", "--install",
            "-a", "--add",
            dest = "install",
            action="store_true",
            help="Install the selected build scripts (used with terms)"
        )

    @staticmethod
    def parse_avail_args(args):
        if args.terms:
            args.terms = [Utils.normalize_name_version(term) for term in args.terms]

        local_packages = Utils.get_local_build_scripts()
        # Fetch remote metadata entries if configured
        remote_packages = {}
        if Config.REMOTE_METADATA_URL:
            remote_packages = Utils.fetch_remote_build_scripts()

        installed_overlays = CondaTainer.get_installed_overlays()

        added_packages = set()
        all_packages = []
        for p in local_packages.keys():
            if p in installed_overlays:
                if "/" in p:
                    all_packages.append(f"{p} (installed)")
                else:
                    all_packages.append(f"{p} (container, installed)")
            else:
                if "/" in p:
                    all_packages.append(p)
                else:
                    all_packages.append(f"{p} (container)")
            added_packages.add(p)
        # add remote-only packages with a marker
        for k in sorted(remote_packages.keys()):
            if k not in added_packages:
                if k in installed_overlays:
                    if "/" in k:
                        all_packages.append(f"{k} (remote, installed)")
                    else:
                        all_packages.append(f"{k} (remote, container, installed)")
                else:
                    if "/" in k:
                        all_packages.append(f"{k} (remote)")
                    else:
                        all_packages.append(f"{k} (remote, container)")
                added_packages.add(k)

        if args.terms:
            # match ONLY packages that contain *all* terms (logical AND)
            filtered_packages = [
                p for p in all_packages
                if all(re.search(re.escape(term), p, re.IGNORECASE) for term in args.terms)
            ]
        else:
            filtered_packages = all_packages

        if not filtered_packages:
            Utils.print_warning("No matching local or remote build scripts found.")
            return

        for pkg in sorted(filtered_packages):
            if args.terms:
                highlighted = pkg
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
                print(highlighted)
            else:
                print(pkg)

        uninstalled_packages = set()
        for pkg in filtered_packages:
            if "installed" in pkg:
                continue
            else:
                uninstalled_packages.add(pkg.split(' ')[0])

        if Utils.is_in_interactive_shell() and args.install and args.terms and uninstalled_packages:
            print("==================INSTALL==================")
            print("The following overlays will be installed:")
            for pkg in sorted(uninstalled_packages):
                print(f" - {pkg}")
            Utils.print_message("Do you want to install the above overlays? [y/N]: ", end="")
            choice = input().strip().lower()
            if choice != 'y':
                return

            CondaTainer.ensure_base_image()
            build_objects = [BuildObject(pkg) for pkg in uninstalled_packages]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All selected overlays installed/submitted.")
            else:
                Utils.print_error("Some overlays failed to install.")

class CondaTainer_List:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_List.parser_list = parser.add_parser(
            "list", aliases=["ls"],
            help="List installed overlays matching search terms")
        CondaTainer_List.parser_list.add_argument(
            "terms",
            type=str,
            nargs="*",
            help="Search terms (AND logic applied)"
        )
        CondaTainer_List.parser_list.add_argument(
            "-d", "--delete",
            "-r", "--remove",
            dest = "delete",
            action="store_true",
            help="Delete listed overlays after confirmation (used with terms)"
        )

    @staticmethod
    def parse_list_args(args):
        if args.terms:
            args.terms = [Utils.normalize_name_version(term) for term in args.terms]

        if os.path.isdir(Config.IMAGES_DIR):
            overlay_files = [f for f in os.listdir(Config.IMAGES_DIR) if f.endswith(('.sqf', '.img', '.squashfs'))]
            name_versions_dict = {}
            for overlay in overlay_files:
                name_version = os.path.splitext(overlay)[0]
                if '--' in name_version:
                    name, version = name_version.split('--', 1)
                    if args.terms:
                        if not all(re.search(re.escape(term), name_version, re.IGNORECASE) for term in args.terms):
                            continue
                    if name in name_versions_dict:
                        name_versions_dict[name].append(version)
                    else:
                        name_versions_dict[name] = [version]
                else:
                    if args.terms:
                        if not all(re.search(re.escape(term), name_version, re.IGNORECASE) for term in args.terms):
                            continue
                    name_versions_dict[name_version] = [f"(system app overlay)"]

            if name_versions_dict:
                name_col_width = max(len(name) for name in name_versions_dict.keys())
                print("Available app overlays:")
                for name in sorted(name_versions_dict.keys()):
                    print(f" {Utils.yellow_text(name.ljust(name_col_width))}: {', '.join(sorted(name_versions_dict[name]))}")

        if os.path.isdir(Config.REF_IMAGES_DIR):
            ref_overlay_files = [
                f for f in os.listdir(Config.REF_IMAGES_DIR) 
                    if f.endswith(('.sqf', '.img', '.squashfs')) and 
                    all(re.search(re.escape(term), f, re.IGNORECASE) for term in args.terms)]
            if ref_overlay_files:
                print("Available reference overlays:")
                for overlay in sorted(ref_overlay_files):
                    name_version = os.path.splitext(overlay)[0].replace('--', '/')
                    if args.terms:
                        colored_name_version = name_version
                        for term in args.terms:
                            colored_name_version = re.sub(
                                re.escape(term),
                                lambda m: Utils.yellow_text(m.group(0)),
                                colored_name_version,
                                flags=re.IGNORECASE
                            )
                        print(" " + colored_name_version)
                    else:
                        print(" " + name_version)

        if Utils.is_in_interactive_shell() and args.delete and args.terms:
            print("==================REMOVE==================")
            CondaTainer_Remove.parse_remove_args(args)

class CondaTainer_Remove:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Remove.parser_remove = parser.add_parser(
            "remove", aliases=["rm", "delete", "del"],
            help="Remove installed overlays matching search terms")
        CondaTainer_Remove.parser_remove.add_argument(
            "terms",
            type=str,
            nargs="+",
            help="Search terms (AND logic applied)"
        )

    @staticmethod
    def parse_remove_args(args):
        if args.terms:
            args.terms = [Utils.normalize_name_version(term) for term in args.terms]

        installed_overlays_dict = CondaTainer.get_installed_overlays()
        if not installed_overlays_dict:
            Utils.print_warning("No installed overlays found.")
            return

        filtered_overlays = []
        for overlay in installed_overlays_dict.keys():
            if args.terms:
                if all(re.search(re.escape(term), overlay, re.IGNORECASE) for term in args.terms):
                    filtered_overlays.append(overlay)
            else:
                filtered_overlays.append(overlay)

        if not filtered_overlays:
            Utils.print_warning("No matching installed overlays found.")
            return

        print("Overlays to be removed:")
        for overlay in sorted(filtered_overlays):
            highlighted = overlay
            if args.terms:
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
            print(f" - {highlighted}")

        Utils.print_message("Are you sure? Cannot be undone. [y/N]: ", end="")
        choice = input().strip().lower()
        if choice != 'y':
            return

        for overlay in filtered_overlays:
            overlay_path = installed_overlays_dict[overlay]
            try:
                os.remove(overlay_path)
                Utils.print_success(f"Overlay {Utils.yellow_text(overlay)} removed.")
                env_path = os.path.splitext(overlay_path)[0] + ".env"
                if os.path.isfile(env_path):
                    os.remove(env_path)
            except Exception as e:
                Utils.print_error(f"Failed to remove overlay {Utils.yellow_text(overlay)}: {str(e)}")

class CondaTainer_Info:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Info.parser_info = parser.add_parser("info", help="Show information about a specific overlay")
        CondaTainer_Info.parser_info.add_argument(
            "overlay",
            type=str,
            help="Overlay package (e.g., bcftools/1.22)"
        )

    @staticmethod
    def parse_info_args(args):
        installed_overlays_dict = CondaTainer.get_installed_overlays()
        overlay = Utils.normalize_name_version(args.overlay)
        if overlay in installed_overlays_dict.keys(): # installed overlay
            overlay_path = installed_overlays_dict[overlay]
        else: # external overlay
            overlay_path = os.path.abspath(args.overlay)
            if not os.path.isfile(overlay_path):
                Utils.print_error(f"Overlay file {Utils.blue_text(overlay_path)} not found.")
                return

        print(f"Information for overlay {Utils.yellow_text(os.path.basename(overlay_path))}:")
        # Additional info can be added here, e.g., size, creation date, etc.
        file_size = os.path.getsize(overlay_path)
        print(f"Size: {file_size / (1024 * 1024):.2f} MB")
        if overlay_path.endswith((".sqf", ".squashfs")):
            name = os.path.splitext(os.path.basename(overlay_path))[0]
            name = name.replace('--', '/').replace('=', '/')
            print(f"Potential mount path: {Utils.blue_text('/cnt/' + name)}")
        elif overlay_path.endswith(".img"):
            name = os.path.splitext(os.path.basename(overlay_path))[0]
            name = name.replace('--', '/').replace('=', '/')
            print(f"Potential mount path: {Utils.blue_text('/ext3/' + name)}")

        env_path = os.path.splitext(overlay_path)[0] + ".env"
        if os.path.isfile(env_path):
            print("Environment variables:")
            with open(env_path, 'r') as f:
                for line in f:
                    print(f"  - {line.strip()}")

class CondaTainer_Check:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Check.parser_check = parser.add_parser(
            "check", aliases=["c"],
            help="Check if the dependencies of a script are installed")
        CondaTainer_Check.parser_check.add_argument(
            "script",
            type=str,
            help="Path to the script to check"
        )
        CondaTainer_Check.parser_check.add_argument(
            "-a", "--auto-install",
            "-i", "--install",
            dest="auto_install",
            action="store_true",
            help="Automatically install missing dependencies"
        )

    @staticmethod
    def parse_check_args(args):
        script_path_or_name = args.script
        is_remote = False
        if not os.path.isfile(script_path_or_name):
            script_path_or_name = Utils.normalize_name_version(script_path_or_name)
            local_build_scripts = Utils.get_local_build_scripts()
            Utils.print_debug(f"[CHECK] Checking for build script {script_path_or_name} locally and remotely...")
            if script_path_or_name in local_build_scripts:
                script_path = local_build_scripts[script_path_or_name]
                Utils.print_message(f"Found local build script {Utils.blue_text(script_path)}")
            elif script_path_or_name in Utils.fetch_remote_build_scripts():
                Utils.print_message(f"Downloading build script for {script_path_or_name} from remote metadata...")
                is_remote = True
                url = Utils.fetch_remote_build_scripts()[script_path_or_name]
                script_path = os.path.join(Config.CONDATINER_DIR, f"{script_path_or_name.replace('/', '--')}.sh")
                if Utils.download_executable(url, script_path):
                    Utils.print_message(f"Downloaded build script to {Utils.blue_text(script_path)}")
                else:
                    Utils.print_error(f"Failed to download build script for {script_path_or_name} from {url}.")
                    return
            else:
                Utils.print_error(f"Build script for {script_path_or_name} not found.")
                return
        else:
            script_path = script_path_or_name

        deps = Utils.get_dependencies_from_script(script_path)
        for d in deps:
            Utils.print_message(f"Dependency: {Utils.yellow_text(d)}" + Utils.red_text(" (missing)" if not CondaTainer.is_overlay_installed(d) else ""))
        missing_deps = CondaTainer.get_missing_overlays(deps)

        if not missing_deps:
            Utils.print_message("All dependencies are installed.")
            if is_remote and os.path.isfile(script_path):
                os.remove(script_path)
            return

        if args.auto_install:
            Utils.print_message("Attempting to auto-install missing dependencies...")
            CondaTainer.ensure_base_image()
            build_objects = [BuildObject(pkg) for pkg in missing_deps]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All selected overlays installed/submitted.")
            else:
                Utils.print_error("Some overlays failed to install.")
        else:
            Utils.print_message(f"Run the command again with {Utils.blue_text('-a')} or {Utils.blue_text('--auto-install')} to install missing dependencies.")

        if is_remote and os.path.isfile(script_path):
            os.remove(script_path)

class CondaTainer_Run:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Run.parser_run = parser.add_parser(
            "run", aliases=["r"],
            help="Run a script and auto-solve the dependencies by #DEP tags")
        CondaTainer_Run.parser_run.add_argument(
            "script",
            type=str,
            help="Path to the script to run"
        )
        CondaTainer_Run.parser_run.add_argument(
            "-w", "--writable-img",
            help="Make .img overlays writable (default: read-only)",
            action="store_true"
        )
        CondaTainer_Run.parser_run.add_argument(
            "-a", "--auto-install",
            "-i", "--install",
            dest="auto_install",
            help="Automatically install missing dependencies",
            action="store_true"
        )

    @staticmethod
    def parse_args_in_script(script_path: str) -> List[str]:
        args = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Script file {script_path} not found.")
            return args

        with open(script_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith("#CNT"):
                    arg_line = line[len("#CNT"):].strip()
                    args.append(arg_line)
        return args

    @staticmethod
    def parse_run_args(args):
        CondaTainer.ensure_base_image()
        script_path = args.script
        if not os.path.isfile(script_path):
            CondaTainer_Run.parser_run.error(f"Script file {script_path} not found.")
        script_path = os.path.abspath(script_path)

        args_from_script = CondaTainer_Run.parse_args_in_script(script_path)
        merged = args_from_script + sys.argv[2:]
        args = CondaTainer_Run.parser_run.parse_args(merged)

        if Config.debug and args_from_script:
            Utils.print_debug(f"[RUN] Additional script arguments found: {args_from_script}")

        deps = Utils.get_dependencies_from_script(script_path)
        missing_deps = CondaTainer.get_missing_overlays(deps)

        if missing_deps:
            if not args.auto_install:
                Utils.print_message("Missing dependencies:")
                for md in missing_deps:
                    Utils.print_message(f"  - {Utils.yellow_text(md)}")

                Utils.print_message(f"Please run {Utils.blue_text(Config.SCRIPT_NAME + ' check -a')} to install missing dependencies.")
                return

            Utils.print_message("Attempting to auto-install missing dependencies...")
            for md in missing_deps:
                if md.endswith(('.sqf', '.img', '.squashfs')):
                    Utils.print_error(f"Custom overlay {Utils.yellow_text(md)} is missing. Cannot proceed with auto-installation.")
                    return

            build_objects = [BuildObject(pkg) for pkg in missing_deps]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All selected overlays installed/submitted.")
            else:
                Utils.print_error("Some overlays failed to install.")
                return

        if args.writable_img:
            CondaTainer_Exec.is_img_writable = True

        bash_command = [
            "module() { :; }", # disable module command
            "ml() { :; }",
            "export -f module ml",
        ]
        if os.access(script_path, os.X_OK):
            bash_command.append(script_path)
        else:
            bash_command.append(f"bash {script_path}")

        if not CondaTainer_Exec.exec_command(deps, [ "/bin/bash", "-c", "\n".join(bash_command)] ):
            exit(1)

class CondaTainer_Overlay:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Overlay.parser_overlay = parser.add_parser(
            "overlay", aliases=["o"],
            help="Create an empty overlay img")
        CondaTainer_Overlay.parser_overlay.add_argument(
            "-s", "--size",
            type=int,
            default=10240,
            help="Size of the overlay image in MiB"
        )
        CondaTainer_Overlay.parser_overlay.add_argument(
            "-f", "--file",
            type=str,
            help="Conda env YAML file"
        )
        CondaTainer_Overlay.parser_overlay.add_argument(
            "image",
            type=str,
            nargs="?",
            default="env.img",
            help="Path to create the overlay image"
        )

    @staticmethod
    def parse_overlay_args(args):
        CondaTainer.ensure_apptainer()
        overlay_path = os.path.abspath(args.image)
        size_mib = args.size

        if not overlay_path.endswith(".img"):
            if '.' in os.path.basename(overlay_path):
                CondaTainer_Overlay.parser_overlay.error("Overlay image must have a .img extension.")
            overlay_path += ".img"

        if os.path.isfile(overlay_path) or os.path.isdir(overlay_path):
            Utils.print_error(f"Path {overlay_path} already exists.")
            return

        if args.file:
            if not os.path.isfile(args.file):
                Utils.print_error(f"Conda env file {args.file} not found.")
                return

        Utils.print_message(f"Creating overlay image at {Utils.blue_text(overlay_path)} with size {Utils.yellow_text(str(size_mib) + ' MiB')}...")
        cmd_overlay = [
            Config.APPTAINER_BIN, "overlay", "create",
            "--size", str(size_mib), "--sparse",
            overlay_path
        ]

        try:
            subprocess.run(cmd_overlay, check=True)
            Utils.print_success(f"Overlay image created at {Utils.blue_text(overlay_path)}.")
        except subprocess.CalledProcessError:
            Utils.print_error("Failed to create overlay image.")
            return

        CondaTainer_Exec.is_img_writable = True
        if args.file:
            Utils.print_message(f"Initializing conda environment using {os.path.abspath(args.file)}...")
            if CondaTainer_Exec.exec_command([overlay_path], ["mm-create", "-f", os.path.abspath(args.file), "-y"], capture_output=True):
                CondaTainer_Exec.exec_command([overlay_path], ["mm-clean", "-a", "-y"], capture_output=True)
                Utils.print_success(f"Conda env is created inside {Utils.blue_text(overlay_path)}.")
            else:
                Utils.print_error(f"Failed to create conda env inside {Utils.blue_text(overlay_path)}.")
                exit(1)
        else:
            Utils.print_message("Initializing minimal conda environment with small package (zlib)...")
            if CondaTainer_Exec.exec_command([overlay_path], ["mm-create", "zlib", "-y"], capture_output=True):
                CondaTainer_Exec.exec_command([overlay_path], ["mm-clean", "-a", "-y"], capture_output=True)
                Utils.print_success(f"Conda env is created inside {Utils.blue_text(overlay_path)}.")
            else:
                Utils.print_error(f"Failed to create conda env inside {Utils.blue_text(overlay_path)}.")
                exit(1)

class CondaTainer_Apptainer:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Apptainer.parser_apptainer = parser.add_parser("apptainer", help="Get latest Apptainer executable from conda-forge")

        CondaTainer_Apptainer.parser_apptainer.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm installation"
        )

        CondaTainer_Apptainer.parser_apptainer.add_argument(
            "-f", "--force",
            action="store_true",
            help="Force re-installation even if Apptainer is already installed"
        )

    @staticmethod
    def parse_apptainer_args(args):
        if os.path.isdir(Config.LOCAL_APPTAINER_DIR) and not args.force:
            Utils.print_message(f"Apptainer executable already exists at {Config.LOCAL_APPTAINER_DIR}. Use -f or --force to re-install.")
            return

        if not args.yes:
            Utils.print_warning("You cannot build sif images with conda-forge Apptainer.")
            Utils.print_message("Are you sure you want to install? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Installation cancelled by user.")
                return

        CondaTainer_Apptainer.install_apptainer(args.force)

    @staticmethod
    def secure_local_micromamba():
        if os.path.exists(Config.LOCAL_MICROMAMBA_BIN):
            return True

        # Detect architecture
        machine = platform.machine()
        if machine in ("aarch64", "ppc64le", "arm64"):
            ARCH = machine
        else:
            ARCH = "64"

        release_url = f"https://github.com/mamba-org/micromamba-releases/releases/latest/download/micromamba-linux-{ARCH}"
        if Utils.download_executable(release_url, Config.LOCAL_MICROMAMBA_BIN):
            Utils.print_success(f"Micromamba downloaded to {Config.LOCAL_MICROMAMBA_BIN}.")
            return True
        else:
            Utils.print_error("Failed to download Micromamba.")
            return False

    @staticmethod
    def install_apptainer(force: bool = False):
        if not CondaTainer_Apptainer.secure_local_micromamba():
            Utils.print_error("Cannot proceed with Apptainer installation without Micromamba.")
            return

        if not force and os.path.isdir(Config.LOCAL_APPTAINER_DIR):
            Utils.print_message(f"Apptainer already exists at {Config.LOCAL_APPTAINER_DIR}. Use -f or --force to re-install.")
            return

        Utils.print_message("Installing Apptainer using Micromamba...")
        cmd_install = [
            Config.LOCAL_MICROMAMBA_BIN, 
            "-r", os.path.join(Config.CONDATINER_DIR, "micromamba_env"),
            "create", "-c", "conda-forge",
            "-y", "--no-allow-softlinks",
            "-p", Config.LOCAL_APPTAINER_DIR,
            "apptainer"
        ]

        Utils.print_debug(f"[APPTAINER] Installing Apptainer with command: {cmd_install}")

        try:
            subprocess.run(cmd_install, check=True)
            Utils.print_success(f"Apptainer installed to {Config.APPTAINER_BIN}.")
            Utils.print_message("Cleaning up Micromamba environment...")
            shutil.rmtree(os.path.join(Config.CONDATINER_DIR, "micromamba_env"), ignore_errors=True)
            shutil.rmtree(os.path.join(Config.LOCAL_APPTAINER_DIR, "conda-meta"), ignore_errors=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Failed to install Apptainer.")

class CondaTainer_Update:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Update.parser_update = parser.add_parser("self-update", help="Update CondaTainer to the latest version")
        CondaTainer_Update.parser_update.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm update"
        )

    @staticmethod
    def parse_update_args(args):
        if not args.yes:
            Utils.print_message("Are you sure to download and replace the current script from GitHub? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Update cancelled by user.")
                return

        Utils.print_message("Downloading the latest CondaTainer script...")
        if Utils.download_executable(Config.CONDATAINER_URL, Config.SCRIPT_PATH + ".tmp"):
            os.chmod(Config.SCRIPT_PATH + ".tmp", 0o775)
            shutil.move(Config.SCRIPT_PATH + ".tmp", Config.SCRIPT_PATH)
            Utils.print_success("CondaTainer updated.")
        else:
            Utils.print_error("Failed to download the latest CondaTainer script.")

class CondaTainer_ModGen:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_ModGen.parser_modgen = parser.add_parser("modgen", help="Get latest modgen executable from GitHub")
        CondaTainer_ModGen.parser_modgen.add_argument(
            "-y", "--yes",
            action="store_true",
            help="Automatically confirm installation"
        )
        CondaTainer_ModGen.parser_modgen.add_argument(
            "-f", "--force",
            action="store_true",
            help="Force overwrite if CondaTainer is already installed"
        )

    @staticmethod
    def parse_modgen_args(args):
        if not Utils.is_in_interactive_shell():
            return

        Utils.print_message(f"{Utils.blue_text('ModGen')}: Use conda and build scripts to create environment-modules or Lmod modules.")
        Utils.print_message(f"Which is another way to manage software environments compared to {Utils.blue_text('CondaTainer')}.")
        Utils.print_message(f"HPC systems often have numbers of prebuilt modules available via Lmod.")
        Utils.print_message(f"{Utils.blue_text('ModGen')} will take the advantage of existing modules and only install missing modules via micromamba.")
        print("", flush=True)

        target_path = os.path.join(os.path.dirname(Config.SCRIPT_PATH), "modgen")
        if os.path.isfile(target_path) and not args.force:
            Utils.print_message(f"ModGen is already installed at {Utils.blue_text(target_path)}.")
            Utils.print_message("Overwrite? [y/N]: ", end="", flush=True)
            if not args.yes:
                confirm = input()
                if confirm.lower() != 'y':
                    Utils.print_message("Installation cancelled by user.")
                    return

        if not args.force and not args.yes:
            Utils.print_message("Are you sure to install ModGen? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Installation cancelled by user.")
                return

        Utils.print_message("Downloading ModGen...")
        if Utils.download_executable(Config.MODGEN_URL, target_path):
            Utils.print_success("ModGen installed.")
        else:
            Utils.print_error("Failed to download ModGen.")

if __name__ == "__main__":
    try:
        main()
    except RuntimeError as rte:
        Utils.print_error(str(rte))
        sys.exit(1)
    except ValueError as e:
        Utils.print_error(str(e))
        sys.exit(1)
    except KeyboardInterrupt:
        sys.exit(1)
