#!/usr/bin/env python3
import os
import sys
import subprocess
import re
import shutil
import argparse
import json
import urllib.request
import platform
import stat
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple

os.umask(0o002)

class Config:
    VERSION = "1.0.5"

    # Global settings
    debug = False
    submit_job = True
    create_tmp_size = 20480 # in MiB

    # Remote settings
    GITHUB_REPO = "Justype/condatainer"
    REMOTE_METADATA_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/metadata/build-scripts.json.gz"
    REMOTE_HELPER_METADATA = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/metadata/helper-scripts.json.gz"
    CONDATAINER_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/bin/condatainer"
    GIT_RAW_URL_PREFIX = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/"

    # Folder paths
    SCRIPT_PATH = os.path.abspath(__file__)
    SCRIPT_NAME = os.path.basename(SCRIPT_PATH)
    PROGRAM_DIR = os.path.dirname(SCRIPT_PATH)
    CONDATINER_DIR = os.path.abspath(os.path.join(PROGRAM_DIR, ".."))

    BUILD_SCRIPTS_DIR = os.path.join(CONDATINER_DIR, "build-scripts")
    IMAGES_DIR = os.path.join(CONDATINER_DIR, "images")
    REF_IMAGES_DIR = os.path.join(CONDATINER_DIR, "ref-images")
    TMP_DIR = os.path.join(CONDATINER_DIR, "tmp")
    HELPER_SCRIPTS_DIR = os.path.join(CONDATINER_DIR, "helper-scripts")
    LOGS_DIR = os.path.join(os.path.expanduser("~"), "logs")

    # Local apptainer
    SYSTEM_APPTAINER_BIN = shutil.which("apptainer")
    BASE_IMAGE_DEF = os.path.join(BUILD_SCRIPTS_DIR, "base_image.def")
    BASE_IMAGE_SIF = os.path.join(IMAGES_DIR, "base_image.sif")
    BAD_CHARS_REGEX = re.compile(r'[<>:"/\\|?*\0\s\'`$&;|!\[\]#%@=+{}(),]')

    # Utils
    NCPUS = os.environ.get("SLURM_CPUS_PER_TASK", 4)
    GZIP_FAST = "-comp gzip -Xcompression-level 3"
    GZIP = "-comp gzip"
    ZSTD_FAST = "-comp zstd -Xcompression-level 3"
    ZSTD_MEDIUM = "-comp zstd -Xcompression-level 8"
    ZSTD = "-comp zstd -Xcompression-level 14"
    ZSTD_HIGH = "-comp zstd -Xcompression-level 18"
    LZ4 = "-comp lz4"
    compress_args = LZ4

    _base_image = BASE_IMAGE_SIF
    @staticmethod
    def change_base_image(new_image_path: str):
        installed_overlays = CondaTainer.get_installed_overlays()
        if new_image_path in installed_overlays:
            Config._base_image = installed_overlays[new_image_path]
        else:
            abs_new_image_path = os.path.abspath(new_image_path)
            if not os.path.isfile(abs_new_image_path):
                Utils.print_error(f"Base image file {Utils.blue_text(abs_new_image_path)} not found.")
                exit(1)
            if not Utils.is_apptainer_image(abs_new_image_path):
                Utils.print_error(f"Base image file {Utils.blue_text(abs_new_image_path)} is not a valid Apptainer image.")
                exit(1)
            Config._base_image = abs_new_image_path

    @staticmethod
    def adjust_compression_args_based_on_apptainer_version():
        """Change to ZSTD_MEDIUM if apptainer version >= 1.4.0"""
        if Config.SYSTEM_APPTAINER_BIN is None:
            return
        try:
            result = subprocess.run([Config.SYSTEM_APPTAINER_BIN, "--version"], capture_output=True, text=True)
            version_match = re.search(r"apptainer version (\d+)\.(\d+)", result.stdout)
            if version_match:
                major, minor = map(int, version_match.groups())
                if (major, minor) >= (1, 4):
                    Config.compress_args = Config.ZSTD_MEDIUM
                    Utils.print_debug(f"Apptainer version {major}.{minor} detected. Using ZSTD_MEDIUM compression.")
                else:
                    Utils.print_debug(f"Apptainer version {major}.{minor} detected. Using LZ4 compression.")
        except Exception:
            pass

def main():
    Config.adjust_compression_args_based_on_apptainer_version()
    parser = argparse.ArgumentParser(
        description="CondaTainer: Use Apptainer/Conda/SquashFS to manage tools for HPC users.",
        epilog=f"For full manual, see https://github.com/{Config.GITHUB_REPO}/blob/main/docs/manuals/condatainer.md")
    parser.add_argument("-v", "--version", action="version", version=Config.VERSION, help="Show program's version number and exit", default=argparse.SUPPRESS)
    parser.add_argument("--debug", action="store_true", help="Enable debug mode with verbose output")
    parser.add_argument("--local", dest="local", action="store_true", help="Disable job submission")
    subparsers = parser.add_subparsers(dest="action", metavar="COMMAND", required=True, help="Available actions")

    CondaTainer_Overlay.add_parser_arguments(subparsers)
    CondaTainer_Create.add_parser_arguments(subparsers)
    CondaTainer_Helper.add_parser_arguments(subparsers)
    CondaTainer_Avail.add_parser_arguments(subparsers)
    CondaTainer_List.add_parser_arguments(subparsers)
    CondaTainer_Remove.add_parser_arguments(subparsers)
    CondaTainer_Exec.add_parser_arguments(subparsers)
    CondaTainer_Check.add_parser_arguments(subparsers)
    CondaTainer_Run.add_parser_arguments(subparsers)
    CondaTainer_Info.add_parser_arguments(subparsers)
    CondaTainer_Update.add_parser_arguments(subparsers)
    CondaTainer_Completion.add_parser_arguments(subparsers)

    args = parser.parse_args()
    if args.debug:
        Config.debug = True
        Utils.print_debug("Debug mode enabled")
        Utils.print_debug(f"CondaTainer Version: {Config.VERSION}")
        Utils.print_debug(f"Apptainer Path: {Config.SYSTEM_APPTAINER_BIN}")
    if args.local:
        Config.submit_job = False
        Utils.print_debug("Local mode enabled (job submission disabled)")

    if args.action in ("create", "install", "i"):
        CondaTainer_Create.parse_create_args(args)
    elif args.action == "exec":
        CondaTainer_Exec.parse_exec_args(args)
    elif args.action == "e":
        CondaTainer_Exec.parse_e_args(args)
    elif args.action in ("check"):
        CondaTainer_Check.parse_check_args(args)
    elif args.action in ("run"):
        CondaTainer_Run.parse_run_args(args)
    elif args.action == "info":
        CondaTainer_Info.parse_info_args(args)
    elif args.action in ("avail", "av"):
        CondaTainer_Avail.parse_avail_args(args)
    elif args.action in ("list", "ls"):
        CondaTainer_List.parse_list_args(args)
    elif args.action in ("remove", "delete", "uninstall", "rm"):
        CondaTainer_Remove.parse_remove_args(args)
    elif args.action in ("overlay", "o"):
        CondaTainer_Overlay.parse_overlay_args(args)
    elif args.action in ("helper"):
        CondaTainer_Helper.parse_helper_args(args)
    elif args.action == "self-update":
        CondaTainer_Update.parse_update_args(args)
    elif args.action == "completion":
        CondaTainer_Completion.parse_completion_args(args)

class Utils:
    remote_build_scripts_links: Optional[Dict[str, str]] = None
    remote_helper_scripts_links: Optional[Dict[str, Dict[str, Dict[str, str]]]] = None
    local_build_scripts_paths: Optional[Dict[str, str]] = None

    @staticmethod
    def blue_text(text): return f"\033[94m{text}\033[0m"
    @staticmethod
    def red_text(text): return f"\033[91m{text}\033[0m"
    @staticmethod
    def yellow_text(text): return f"\033[93m{text}\033[0m"
    @staticmethod
    def green_text(text): return f"\033[92m{text}\033[0m"
    @staticmethod
    def cyan_text(text): return f"\033[96m{text}\033[0m"
    @staticmethod
    def magenta_text(text): return f"\033[95m{text}\033[0m"

    @staticmethod
    def print_message(message, end="\n", flush=True): print(f"[CNT] {message}", end=end, flush=flush)
    @staticmethod
    def print_debug(debug_object, end="\n", flush=True):
        if Config.debug:
            print(f"[CNT][{Utils.yellow_text('DEBUG')}]", end=" ", flush=True)
            print(debug_object, end=end, flush=flush)
    @staticmethod
    def print_note(message, end="\n", flush=True): print(f"[CNT][{Utils.blue_text('NOTE')}] {message}", end=end, flush=flush)
    @staticmethod
    def print_warning(message, end="\n", flush=True): print(f"[CNT][{Utils.yellow_text('WARNING')}] {message}", file=sys.stderr, end=end, flush=flush)
    @staticmethod
    def print_error(message, end="\n", flush=True): print(f"[CNT][{Utils.red_text('ERROR')}] {message}", file=sys.stderr, end=end, flush=flush)
    @staticmethod
    def print_success(message, end="\n", flush=True): print(f"[CNT][{Utils.green_text('SUCCESS')}] {message}", end=end, flush=flush)

    @staticmethod
    def normalize_name_version(name_version: str) -> str:
        """
        Normalize package spec formats so that `name/version`, `name=version`, `name@version`
        are treated the same. This converts slashes to equal signs and strips
        surrounding whitespace.
        """
        if not isinstance(name_version, str):
            return name_version
        return name_version.strip().replace('=', '/').replace('@', '/').replace('--', '/')

    @staticmethod
    def fetch_remote_build_scripts() -> dict:
        """
        Fetch JSON metadata from a remote http(s) URL

        Returns a name-version to link mapping dictionary.
        """
        url = Config.REMOTE_METADATA_URL
        if not url:
            return {}

        if Utils.remote_build_scripts_links is not None:
            return Utils.remote_build_scripts_links

        normalized = {}

        try:
            with urllib.request.urlopen(url) as resp:
                if url.endswith('.gz'):
                    import gzip
                    with gzip.GzipFile(fileobj=resp) as gz:
                        data = gz.read()
                    metadata = json.loads(data)
                else:
                    data = resp.read()
                    metadata = json.loads(data)

                for k, v in metadata.items():
                    key = Utils.normalize_name_version(k)
                    rel = v["relative_path"]
                    link = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/{rel}"
                    normalized[key] = link

        except Exception as e:
            Utils.print_error(e)
            Utils.print_warning(f"Failed to fetch remote metadata from {url}: {e}")
            return {}

        if normalized:
            Utils.remote_build_scripts_links = normalized

        return normalized

    @staticmethod
    def fetch_remote_helper_scripts() -> dict:
        """
        Fetch helper scripts metadata from remote helper metadata URL.
        Returns the parsed JSON (expected structure with top-level categories like 'slurm' and 'headless').
        """
        url = Config.REMOTE_HELPER_METADATA
        if not url:
            return {}

        if Utils.remote_helper_scripts_links is not None:
            return Utils.remote_helper_scripts_links

        try:
            with urllib.request.urlopen(url) as resp:
                if url.endswith('.gz'):
                    import gzip
                    with gzip.GzipFile(fileobj=resp) as gz:
                        data = gz.read()
                else:
                    data = resp.read()
                metadata = json.loads(data)
        except Exception as e:
            Utils.print_error(e)
            Utils.print_warning(f"Failed to fetch remote helper metadata from {url}: {e}")
            return {}

        if metadata:
            Utils.remote_helper_scripts_links = metadata

        return metadata

    @staticmethod
    def get_local_build_scripts():
        """
        Get a name-version to local script path mapping dictionary.
        """
        if Utils.local_build_scripts_paths is not None:
            return Utils.local_build_scripts_paths

        packages = {}
        if not os.path.isdir(Config.BUILD_SCRIPTS_DIR):
            return packages

        # os.walk mimics 'find' by visiting every subdirectory recursively
        for root, _, files in os.walk(Config.BUILD_SCRIPTS_DIR):
            for filename in files:
                # 1. skip non-build-script files
                if filename.endswith(('.py', '.sh')):
                    continue

                full_path = os.path.join(root, filename)

                # 2. skip template files
                if "template" in full_path:
                    continue

                # 3. generate key (relative path like 'apps/tool/v1')
                relative_key = os.path.relpath(full_path, Config.BUILD_SCRIPTS_DIR)

                if relative_key.endswith('.def'):
                    if relative_key.startswith(('base_image', 'base-overlay')):
                        continue  # skip base scripts
                    relative_key = relative_key[:-4]  # remove .def suffix

                packages[relative_key] = full_path

        Utils.local_build_scripts_paths = packages
        return packages

    @staticmethod
    def download_file(url: str, dest_path: str) -> bool:
        """
        Download a remote file to `dest_path`. Creates parent dirs. Returns True on success.
        """
        try:
            os.makedirs(os.path.dirname(dest_path), mode=0o775, exist_ok=True)
            with urllib.request.urlopen(url) as resp, open(dest_path, 'wb') as out_f:
                out_f.write(resp.read())
            return True
        except Exception as e:
            Utils.print_error(f"Failed to download file from {url}: {e}")
            return False

    @staticmethod
    def download_executable(url: str, dest_path: str) -> bool:
        """
        Download a remote build script to `dest_path`. Creates parent dirs and
        marks the file executable. Returns True on success.
        """
        try:
            return Utils.download_file(url, dest_path) and os.chmod(dest_path, 0o775) is None
        except Exception as e:
            Utils.print_error(f"Failed to download build script from {url}: {e}")
            return False

    @staticmethod
    def parse_size_to_mb(size) -> int:
        """
        Parse a size specifier and return size in MiB as int.

        Accepts integers or strings with optional units: M, G, MB, GB
        Units are case-insensitive. If no unit is provided, M is assumed.
        """
        if size is None:
            raise ValueError("Size is None")
        if isinstance(size, int):
            return int(size)
        s = str(size).strip()
        m = re.match(r'^(\d+)\s*([mMgG]|[mM][bB]|[gG][bB])?$', s)
        if not m:
            raise ValueError(f"Invalid size format: {size}. GB/MB; default to MB if no suffix.")
        num = int(m.group(1))
        unit = (m.group(2) or '').lower()
        if unit in ('g', 'gb'):
            return int(num * 1024)
        # default and 'm' or 'mb'
        return int(num)

    @staticmethod
    def get_dependencies_from_script(script_path: str) -> List[str]:
        """
        Get dependencies from a build script by parsing #DEP: lines.

        :param script_path: Description
        :type script_path: str
        :return: Description
        :rtype: List[str]
        """
        dependencies = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"[DEP] Build script not found at {script_path}")
            return dependencies

        module_load_regex = re.compile(r'^\s*(module\s+load)\s+(.+)$')

        with open(script_path, 'r') as f:
            for line in f:
                if line.startswith("#DEP:"):
                    dep_line = line[len("#DEP:"):].strip()
                    if Utils.is_overlay(dep_line):
                        dependencies.append(dep_line)
                    else:
                        dependencies.append(Utils.normalize_name_version(dep_line))
                else:
                    line = line.strip()
                    if module_load_regex.match(line):
                        parts = line.split()
                        if len(parts) >= 3:
                            for mod in parts[2:]:
                                dependencies.append(Utils.normalize_name_version(mod))
                    elif line.startswith("ml"):
                        parts = line.split()
                        if len(parts) >= 2:
                            for mod in parts[1:]:
                                if mod in ("purge", "list", "avail", "av"):
                                    break
                                elif mod == "load":
                                    continue
                                dependencies.append(Utils.normalize_name_version(mod))

        dependencies = list(dict.fromkeys(dependencies))  # Remove duplicates while preserving order

        return dependencies

    @staticmethod
    def get_whatis_url_from_build_script(script_path: str, normalized_name_version: str) -> Tuple[str, str]:
        """
        Parse #WHATIS and #URL lines from a build script.

        Example lines in script:
            #WHATIS:Cell Ranger GRCh38 2024-A index
            #URL:https://www.10xgenomics.com/support/software/cell-ranger/downloads#reference-downloads

        Returns:
            (whatis_text, url_text)
            If not found, empty strings are returned.
        """
        package_name, version = normalized_name_version.split('/', 1)
        whatis = f"Load module {package_name} version {version}"
        url = "Not available"

        if not os.path.isfile(script_path):
            Utils.print_error(f"[WHATIS] Build script not found at {script_path}.")
            return whatis, url

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#WHATIS:"):
                    whatis = line[len("#WHATIS:"):].strip()
                elif line.startswith("#URL:"):
                    url = line[len("#URL:"):].strip()

                if whatis and url:
                    break

        return whatis, url

    @staticmethod
    def get_env_dict_from_build_script(script_path) -> Dict[str, Dict[str, str]]:
        """
        Parse #ENV:KEY=VALUE and #ENVNOTE:KEY description lines from build script.
        Returns a dict:
            {
                "KEY": {"value": "VALUE", "note": "description"},
                ...
            }
        Example lines in script:
            #ENV:STAR_INDEX_DIR=$app_root/star
            #ENVNOTE:STAR_INDEX_DIR STAR index dir
        """
        env_dict: Dict[str, Dict[str, str]] = {}

        if not os.path.isfile(script_path):
            Utils.print_error(f"[ENV] Build script not found at {script_path}.")
            return env_dict

        with open(script_path, "r") as f:
            lines = f.readlines()
            env_indices = [i for i, line in enumerate(lines) if line.strip().startswith("#ENV:")]

            for env_index in env_indices:
                line = lines[env_index].strip()
                if line.startswith("#ENV:"):
                    # Parse KEY=VALUE
                    content = line[len("#ENV:"):].strip()
                    if "=" not in content:
                        continue
                    key, value = content.split("=", 1)
                    env_dict[key] = {"value": value, "note": ""}

                if env_index + 1 < len(lines):
                    next_line = lines[env_index + 1].strip()
                    if next_line.startswith("#ENVNOTE:"):
                        note = next_line[len("#ENVNOTE:"):].strip()
                        env_dict[key]["note"] = note

        return env_dict

    @staticmethod
    def get_sbatch_args_from_build_script(script_path) -> List[str]:
        """
        Parse #SBATCH: lines from build script.
        Returns a list of sbatch arguments.
        Example line in script:
            #SBATCH --cpus-per-task=4
        """
        sbatch_args = []

        if not os.path.isfile(script_path):
            Utils.print_error(f"[SBATCH] Build script not found at {script_path}.")
            return sbatch_args

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#SBATCH"):
                    arg = line[len("#SBATCH"):].strip()
                    sbatch_args.append(arg)

        return sbatch_args

    @staticmethod
    def get_interactive_prompts(script_path: str) -> List[str]:
        """
        Parse #INTERACTIVE: lines from build script.
        Returns a list of interactive prompt descriptions.
        Example line in script:
            #INTERACTIVE:Please enter the license key
        """
        prompts = []

        if not os.path.isfile(script_path):
            Utils.print_error(f"[INTERACTIVE] Build script not found at {script_path}.")
            return prompts

        with open(script_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#INTERACTIVE:"):
                    prompt = line[len("#INTERACTIVE:"):].strip()
                    prompts.append(prompt)

        return prompts

    @staticmethod
    def share_to_ugo_recursive(path: str):
        """
        Recursively set permissions:
            - Files: ug+rw,o+r
            - Folders: ug+rwx,o+rx
        """
        try:
            if os.path.isfile(path):
                current_mode = os.stat(path).st_mode
                # Add read/write for user & group, read for others
                os.chmod(path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP| stat.S_IROTH)
                return True

            for root, dirs, files in os.walk(path):
                # Set directories
                for d in dirs:
                    dir_path = os.path.join(root, d)
                    current_mode = os.stat(dir_path).st_mode
                    # Add read/write/execute for user & group
                    os.chmod(dir_path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                                                    stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                                                    stat.S_IROTH | stat.S_IXOTH)

                # Set files
                for f in files:
                    file_path = os.path.join(root, f)
                    current_mode = os.stat(file_path).st_mode
                    # Add read/write for user & group
                    os.chmod(file_path, current_mode | stat.S_IRUSR | stat.S_IWUSR |
                                                    stat.S_IRGRP | stat.S_IWGRP| stat.S_IROTH)

            # Finally, handle the top-level directory itself
            current_mode = os.stat(path).st_mode
            os.chmod(path, current_mode | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                                            stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                                            stat.S_IROTH | stat.S_IXOTH)
        except PermissionError:
            Utils.print_warning(f"Failed to set permissions for {path}")
            return False
        return True

    @staticmethod
    def is_in_interactive_shell() -> bool:
        return sys.stdin.isatty() and sys.stdout.isatty()

    @staticmethod
    def is_sbatch_available() -> bool:
        """sbatch is available and we are not inside a SLURM job."""
        return (shutil.which("sbatch") is not None) and ("SLURM_JOB_ID" not in os.environ)

    @staticmethod
    def is_sqf(path: str) -> bool:
        return path.endswith((".sqf", ".sqsh", ".squashfs"))

    @staticmethod
    def is_img(path: str) -> bool:
        return path.endswith((".img"))

    @staticmethod
    def is_sif(path: str) -> bool:
        return path.endswith((".sif"))

    @staticmethod
    def is_overlay(path: str) -> bool:
        return Utils.is_img(path) or Utils.is_sqf(path)

    @staticmethod
    def is_apptainer_image(path: str) -> bool:
        return Utils.is_sif(path) or Utils.is_sqf(path) or Utils.is_img(path)

class CondaTainer:
    PREBUILT_BASE_IMAGE_PLATFORMS = { "x86_64" } # aarch64 is not available yet

    @staticmethod
    def ensure_apptainer():
        if Config.SYSTEM_APPTAINER_BIN is None:
            Utils.print_error("Apptainer not found in PATH.")
            Utils.print_note(f"Please consider running: {Utils.blue_text('ml apptainer')}")
            Utils.print_note("If Apptainer is not available, please contact your system administrator.")
            return False
        return True

    @staticmethod
    def ensure_base_def():
        base_def_path = Config.BASE_IMAGE_DEF
        if os.path.isfile(base_def_path):
            return True

        Utils.print_message("Base image definition file not found.")

        url = f"https://raw.githubusercontent.com/{Config.GITHUB_REPO}/main/build-scripts/base_image.def"
        if not Utils.download_file(url, base_def_path):
            Utils.print_error("Failed to download base image definition file.")
            return False
        return True

    @staticmethod
    def try_download_prebuilt_base_image() -> bool:
        arch = platform.machine()
        if arch not in CondaTainer.PREBUILT_BASE_IMAGE_PLATFORMS:
            Utils.print_warning(f"Pre-built base image not available for architecture: {arch}")
            return False

        url = f"https://github.com/Justype/condatainer/releases/download/v1.0.5/base_image_{arch}.sif"
        Utils.print_message(f"Attempting to download pre-built base image for {arch}...")
        if not Utils.download_executable(url, Config.BASE_IMAGE_SIF):
            Utils.print_warning("Failed to download pre-built base image.")
            return False
        Utils.print_success("Pre-built base image downloaded.")
        return True

    @staticmethod
    def ensure_base_image():
        """
        Exit the program if the base image does not exist, after attempting to build it.
        """
        os.makedirs(Config.IMAGES_DIR, mode=0o775, exist_ok=True)
        os.makedirs(Config.REF_IMAGES_DIR, mode=0o775, exist_ok=True)

        if not CondaTainer.ensure_apptainer():
            exit(1)
        if os.path.isfile(Config.BASE_IMAGE_SIF):
            return

        if not Config.debug:
            Utils.print_message("Base images not found. Downloading base image...")
            if CondaTainer.try_download_prebuilt_base_image():
                return
        else:
            Utils.print_debug("Base image not found. Proceeding to build locally due to debug mode.")

        Utils.print_message("Trying to build base image locally...")

        if not CondaTainer.ensure_base_def():
            exit(1)

        cmd = [
            Config.SYSTEM_APPTAINER_BIN, "build", "--fakeroot",
            Config.BASE_IMAGE_SIF, Config.BASE_IMAGE_DEF,
        ]
        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Building base images failed.")
            exit(1)
        Utils.print_success("Base images built.")
        os.chmod(Config.BASE_IMAGE_SIF, 0o775)
        Utils.print_note("You can run " + Utils.blue_text('apptainer cache clean') + " to free up space.")

    @staticmethod
    def get_tmp_overlay_path(normalized_name_version: str) -> str:
        return os.path.join(Config.TMP_DIR, f"{normalized_name_version.replace('/', '--')}.img")

    @staticmethod
    def get_cnt_dir_path(normalized_name_version: str) -> str:
        return os.path.join(Config.TMP_DIR, normalized_name_version.replace('/', '--'), "cnt")

    @staticmethod
    def create_cnt_dir(normalized_name_version: str) -> str:
        cnt_dir = CondaTainer.get_cnt_dir_path(normalized_name_version)
        os.makedirs(cnt_dir, mode=0o775, exist_ok=True)
        return cnt_dir

    @staticmethod
    def create_tmp_overlay(normalized_name_version: str, force: bool = False) -> Optional[str]:
        Utils.print_debug(f"[CREATE] Creating temporary overlay for {normalized_name_version} (force={force})")
        tmp_overlay_path = CondaTainer.get_tmp_overlay_path(normalized_name_version)
        if os.path.isfile(tmp_overlay_path):
            if force:
                Utils.print_warning(f"Temporary overlay for {Utils.yellow_text(normalized_name_version)} already exists. Removing it due to --force.")
                os.remove(tmp_overlay_path)
            else:
                return None

        os.makedirs(os.path.dirname(tmp_overlay_path), mode=0o775, exist_ok=True)

        Utils.print_message(f"Creating temporary SquashFS overlay for {Utils.yellow_text(normalized_name_version)}...")
        cmd = [
            Config.SYSTEM_APPTAINER_BIN, "overlay", "create",
            "--sparse", "--size", str(Config.create_tmp_size),
            tmp_overlay_path
        ]

        Utils.share_to_ugo_recursive(tmp_overlay_path)
        Utils.print_debug(f"[CREATE] Creating temporary overlay with command: {cmd}")

        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError:
            Utils.print_error("Creating temporary overlay failed.")
            return None
        Utils.print_message("Temporary overlay created.")
        return tmp_overlay_path

    @staticmethod
    def remove_tmp_overlay(normalized_name_version: str) -> bool:
        tmp_overlay_path = CondaTainer.get_tmp_overlay_path(normalized_name_version)
        if os.path.isfile(tmp_overlay_path):
            os.remove(tmp_overlay_path)
            Utils.print_message("Temporary overlay removed.")
        return True

    @staticmethod
    def get_installed_overlays() -> Dict[str, str]:
        """
        Get name-version -> file path mapping of installed overlays.
        """
        overlays = {}
        if not os.path.isdir(Config.IMAGES_DIR):
            return overlays

        overlay_files = [f for f in os.listdir(Config.IMAGES_DIR) if Utils.is_overlay(f)]
        for overlay in overlay_files:
            name_version = os.path.splitext(overlay)[0]
            name_version = name_version.replace("--", "/")
            overlays[name_version] = os.path.join(Config.IMAGES_DIR, overlay)

        ref_overlay_files = [f for f in os.listdir(Config.REF_IMAGES_DIR) if Utils.is_overlay(f)]
        for overlay in ref_overlay_files:
            name_version = os.path.splitext(overlay)[0]
            name_version = name_version.replace("--", "/")
            overlays[name_version] = os.path.join(Config.REF_IMAGES_DIR, overlay)
        return overlays

    @staticmethod
    def is_overlay_installed(name_version_or_path: str) -> bool:
        if Utils.is_overlay(name_version_or_path):
            return os.path.isfile(name_version_or_path)
        installed_overlays = CondaTainer.get_installed_overlays().keys()
        return name_version_or_path in installed_overlays

    @staticmethod
    def get_missing_overlays(name_versions_or_paths: List[str]) -> List[str]:
        missing = []
        installed_overlays = CondaTainer.get_installed_overlays().keys()
        for nv in name_versions_or_paths:
            if Utils.is_overlay(nv):
                if not os.path.isfile(nv):
                    missing.append(nv)
            elif nv not in installed_overlays:
                missing.append(nv)
        return missing

    @staticmethod
    def generate_bind_args(*paths: Optional[str]) -> List[str]:
        """
        Accept multiple paths and return a list of absolute paths
        with --bind parameters suitable for binding in Singularity.

        Rules:
        - Resolve to absolute paths
        - Keep only one if multiple paths are the same
        - Skip paths that are children of another path
        """
        # Resolve all paths to absolute, normalized Path objects
        abs_paths = [Path(p).resolve() for p in paths if p] + [Path.home(), Path(".").resolve()]

        if os.environ.get("SCRATCH"):
            abs_paths.append(Path(os.environ["SCRATCH"]).resolve())

        # Remove duplicates
        unique_paths = []
        for p in abs_paths:
            if p not in unique_paths:
                unique_paths.append(p)

        # Filter out child paths
        final_paths = []
        for p in unique_paths:
            if not any(parent != p and p.is_relative_to(parent) for parent in unique_paths):
                final_paths.append(p)

        final_params = []
        for p in final_paths:
            final_params.extend(["--bind", str(p)])
        return final_params

    @staticmethod
    def generate_gpu_args() -> List[str]:
        params = []
        if shutil.which("nvidia-smi") or any("nvidia" in path.lower() for path in os.listdir("/dev")):
            params.extend(["--nv"])
        if shutil.which("rocm-smi"):
            params.extend(["--rocm"])
        return params

class BuildObject:
    def __init__(self, name_version: str, external = False):
        self.name_version = Utils.normalize_name_version(name_version)
        slash_count = self.name_version.count('/')
        self.build_source = ""
        self.dependencies = []
        self.is_conda = False
        self.is_remote = False
        self.sbatch = False
        self.sbatch_flags = []
        self.is_def = slash_count == 0
        self.is_shell = slash_count == 1
        self.is_ref = slash_count > 1
        self.ncpus = Config.NCPUS
        self.interactive_inputs = []

        # related paths
        self.cnt_dir_path = CondaTainer.get_cnt_dir_path(self.name_version)
        self.tmp_overlay_path = CondaTainer.get_tmp_overlay_path(self.name_version)
        overlay_filename = f"{self.name_version.replace('/', '--')}.sqf"
        if self.is_ref:
            self.target_overlay_path = os.path.join(Config.REF_IMAGES_DIR, overlay_filename)
        else:
            self.target_overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)

        if self.is_installed or external:
            return

        local_scripts = Utils.get_local_build_scripts()
        remote_scripts = Utils.fetch_remote_build_scripts()
        if self.name_version in local_scripts:
            self.build_source = local_scripts[self.name_version]
            self.is_remote = False
            if local_scripts[self.name_version].endswith('.def'):
                self.is_def = True
        elif self.name_version in remote_scripts:
            link = remote_scripts[self.name_version]
            if link.endswith('.def'):
                self.is_def = True
            self.build_source = os.path.join(Config.TMP_DIR, f"{self.name_version.replace('/', '--')}{'.def' if self.is_def else '.sh'}")
            if not Utils.download_executable(link, self.build_source):
                raise RuntimeError(f"Failed to download remote build script for {self.name_version}.")
            self.is_remote = True
        elif self.is_def: # no slash and not found remotely or locally
            raise RuntimeError(f"Build script for {self.name_version} not found locally or remotely.")
        else:
            self.is_conda = True

        self._check_dep_prompt_sbatch()

    @staticmethod
    def from_external_source(target_prefix: str, source: str, is_apptainer = False) -> 'BuildObject':
        """
        Create a BuildObject from an external source path.

        Parameters:
            target_prefix (str): The target prefix for the overlay.
            source (str): Path of the build script or Apptainer source/def.
            is_apptainer (bool): Whether the source is for Apptainer.

        Returns:
            BuildObject: The created BuildObject instance.
        """
        name_version = os.path.basename(target_prefix)
        name_version = Utils.normalize_name_version(name_version)
        build_obj = BuildObject(name_version, external=True)
        build_obj.build_source = source
        build_obj.is_def = True if is_apptainer else source.endswith('.def')
        build_obj.is_shell = False if is_apptainer else source.endswith(('.sh', '.bash'))
        build_obj.target_overlay_path = target_prefix + ".sqf"
        build_obj._check_dep_prompt_sbatch()

        Utils.print_debug(f"[EXTERNAL] Created BuildObject from external path: {build_obj}")

        return build_obj

    def _check_dep_prompt_sbatch(self):
        if not (self.is_conda or self.is_def):
            self.dependencies = Utils.get_dependencies_from_script(self.build_source)
            self.sbatch_flags = Utils.get_sbatch_args_from_build_script(self.build_source)
            self.interactive_prompts = Utils.get_interactive_prompts(self.build_source)
            if self.interactive_prompts and not Utils.is_in_interactive_shell():
                raise RuntimeError(f"Build script for {self.name_version} requires interactive input, but no TTY is available.")
            for prompt in self.interactive_prompts:
                Utils.print_note("Build script requires input: " +prompt.replace('\\n', '\n'))
                user_input = input("Enter here: ")
                if "\n" in user_input or "\r" in user_input:
                    Utils.print_warning("Multiline input detected. Only the first line will be used.")
                    user_input = user_input.splitlines()[0]
                self.interactive_inputs.append(user_input)
            for flag in self.sbatch_flags:
                if flag.startswith("--cpus-per-task="):
                    try:
                        self.ncpus = int(flag.split("=")[1])
                    except ValueError:
                        pass
            self.sbatch = len(self.sbatch_flags) > 0

    def __str__(self) -> str:
        if self.is_shell:
            build_type = "Shell Script"
        elif self.is_def:
            build_type = "Apptainer File"
        elif self.is_conda:
            build_type = "Conda Package"
        else:
            build_type = "Unknown"

        return f"""BuildObject:
    name_version: {self.name_version}
    build_source_type: {build_type}
    build_source: {self.build_source}
    dependencies: {self.dependencies}
    sbatch_flags: {self.sbatch_flags}
    tmp_overlay_path: {self.tmp_overlay_path}
    target_overlay_path: {self.target_overlay_path}
    cnt_dir_path: {self.cnt_dir_path}"""

    @property
    def relative_path(self) -> str:
        return self.name_version

    @property
    def is_installed(self) -> bool:
        return CondaTainer.is_overlay_installed(self.name_version)

    def create_tmp_overlay(self, force = False) -> bool:
        if CondaTainer.create_tmp_overlay(self.name_version, force=force) is None:
            return False
        return True

    def create_cleanup(self, failed: bool = False):
        if self.is_remote and os.path.isfile(self.build_source):
            os.remove(self.build_source)
        if os.path.isfile(self.tmp_overlay_path):
            os.remove(self.tmp_overlay_path)
        cnt_base_dir = os.path.dirname(self.cnt_dir_path)
        shutil.rmtree(cnt_base_dir, ignore_errors=True)
        if failed:
            if os.path.isfile(self.target_overlay_path):
                os.remove(self.target_overlay_path)

    def get_missing_dependencies(self) -> List[str]:
        return CondaTainer.get_missing_overlays(self.dependencies)

    def print_create_error_message(self, message: str = ""):
        Utils.print_error(f"Failed to build overlay for {Utils.yellow_text(self.name_version)}" + (f": {message}" if message else "."))
        Utils.print_note("If file/folder creation failed, please chmod/chgroup or contact your system admin.")

    def _build_conda(self) -> bool:
        name, version = self.name_version.split('/')

        if os.path.exists(self.target_overlay_path):
            Utils.print_warning(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} already exists at {Utils.blue_text(self.target_overlay_path)}. Skipping creation.")
            return True
        if not self.create_tmp_overlay(force=False):
            Utils.print_error(f"Temporary overlay for {Utils.yellow_text(self.name_version)} already exists. Maybe a build is still running?")
            Utils.print_note(f"If you are sure no build is running, please remove the temporary overlay at {Utils.blue_text(self.tmp_overlay_path)} and try again.")
            return False

        Utils.print_message(f"Building SquashFS overlay at {Utils.blue_text(self.target_overlay_path)} with packages: {Utils.yellow_text(f'{name}={version}')}" )

        cmd_create = [
            Config.SYSTEM_APPTAINER_BIN, "exec",
            "--env", "TMPDIR=/ext3/tmp",
            "--overlay", self.tmp_overlay_path,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *CondaTainer.generate_gpu_args(),
            Config._base_image,
            "/bin/bash", "-c",
            f"""
            mkdir -p $TMPDIR
            micromamba create -r /ext3/tmp -c conda-forge -c bioconda -q -y -p /cnt/{self.relative_path} {name}={version}

            echo "Setting permissions..."
            find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
            find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
            mksquashfs /cnt {os.path.abspath(self.target_overlay_path)} -processors {self.ncpus} -keep-as-directory {Config.compress_args} -b 1M
            """
        ]

        Utils.print_debug(f"[BUILD] Creating overlay with command: {cmd_create}")
        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            self.print_create_error_message()
            self.create_cleanup(failed=True)
            return False

        Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} created at {Utils.blue_text(self.target_overlay_path)}. Removing temporary overlay...")
        os.chmod(self.target_overlay_path, 0o664)
        self.create_cleanup(failed=False)
        return True

    def _build_def(self) -> bool:
        if os.path.exists(self.target_overlay_path):
            Utils.print_warning(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} already exists at {Utils.blue_text(self.target_overlay_path)}. Skipping creation.")
            return True

        cmd_create = [
            Config.SYSTEM_APPTAINER_BIN, "build", "--fakeroot",
            self.tmp_overlay_path, # although named as sqf, but it's actually an sif image here (will dump to sqf later)
            self.build_source,
        ]

        Utils.print_debug(f"[BUILD] Building Apptainer SIF with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True)
        except subprocess.CalledProcessError:
            self.print_create_error_message()
            self.create_cleanup(failed=True)
            return False

        try:
            squashfs_id = next(
                int(line.split("|")[0])
                for line in subprocess.check_output(
                    ["apptainer", "sif", "list", self.tmp_overlay_path],
                    text=True,
                ).splitlines()
                if "Squashfs/*System" in line
            )
        except Exception as e:
            self.print_create_error_message(f"Failed to get Squashfs/*System ID from SIF: {e}")
            self.create_cleanup(failed=True)
            return False

        Utils.print_message(f"Dumping to SquashFS file at {Utils.blue_text(self.target_overlay_path)}...")
        cmd_mksqf = [
            Config.SYSTEM_APPTAINER_BIN, "sif", "dump",
            str(squashfs_id), self.tmp_overlay_path
        ]
        Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_mksqf}")
        try:
            with open(self.target_overlay_path, 'wb') as out_f:
                subprocess.run(cmd_mksqf, check=True, stdout=out_f, stderr=subprocess.PIPE)
        except subprocess.CalledProcessError:
            self.print_create_error_message()
            self.create_cleanup(failed=True)
            return False

        Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} created at {Utils.blue_text(self.target_overlay_path)}. Removing temporary overlay...")
        os.chmod(self.target_overlay_path, 0o664)
        self.create_cleanup(failed=False)
        return True

    def _build_script(self, build_deps = False) -> bool:
        if os.path.exists(self.target_overlay_path):
            Utils.print_warning(f"Overlay {Utils.yellow_text(os.path.basename(self.target_overlay_path))} already exists at {Utils.blue_text(self.target_overlay_path)}. Skipping creation.")
            return True
        if not self.create_tmp_overlay(force=False):
            Utils.print_error(f"Temporary overlay for {Utils.yellow_text(self.name_version)} already exists. Maybe a build is still running?")
            Utils.print_note(f"If you are sure no build is running, please remove the temporary overlay at {Utils.blue_text(self.tmp_overlay_path)} and try again.")
            return False

        Utils.print_message(f"Building SquashFS overlay at {Utils.blue_text(self.target_overlay_path)} using build source {Utils.yellow_text(self.build_source)}" )

        missing_deps = self.get_missing_dependencies()
        if missing_deps:
            if build_deps:
                Utils.print_message(f"Building missing dependencies for {Utils.yellow_text(self.name_version)}: {', '.join(missing_deps)}")
                for dep in missing_deps:
                    dep_obj = BuildObject(dep)
                    if not dep_obj.build():
                        Utils.print_error(f"Failed to build dependency {Utils.yellow_text(dep)} for {Utils.yellow_text(self.name_version)}.")
                        return False
                Utils.print_success(f"All dependencies for {Utils.yellow_text(self.name_version)} built successfully.")
            else:
                Utils.print_error(f"Missing dependencies for {Utils.yellow_text(self.name_version)}: {', '.join(missing_deps)}. Please install them first.")
            return False

        name_version_parts = self.name_version.split('/')
        if len(name_version_parts) < 2:
            name = name_version_parts[0]
            version = "env"
        else:
            name = name_version_parts[0]
            version = name_version_parts[1]

        env_settings = [
            "--env", f"app_name={name}",
            "--env", f"version={version}",
            "--env", f"app_name_version={self.name_version}",
            "--env", f"tmp_dir=/ext3/tmp",
            "--env", "TMPDIR=/ext3/tmp",
        ]

        if self.is_ref:
            os.makedirs(self.cnt_dir_path, mode=0o775, exist_ok=True)
            target_dir = os.path.join(self.cnt_dir_path, self.name_version)
            env_settings.extend(["--env", f"target_dir={target_dir}"])
        else:
            env_settings.extend(["--env", f"target_dir=/cnt/{self.relative_path}"])

        cmd_create = [
            Config.SYSTEM_APPTAINER_BIN, "exec",
            *env_settings,
            "--env", f"SLURM_CPUS_PER_TASK={self.ncpus}",
            "--env", "IN_CONDATINER=1",
            "--env", f"PATH={CondaTainer_Exec.get_path_env(self.dependencies)}",
            *CondaTainer_Exec.generate_overlay_args(self.dependencies),
            "--overlay", self.tmp_overlay_path,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *CondaTainer_Exec.get_overlay_env_configs(self.dependencies),
            *CondaTainer.generate_gpu_args(),
            Config._base_image,
            "/bin/bash", "-c",
            f"""
            mkdir -p $TMPDIR
            bash {self.build_source}
            if [ $? -ne 0 ]; then
                echo "Build script {self.build_source} failed."
                exit 1
            fi
            """
        ]

        Utils.print_debug(f"[BUILD] Running build script with command: {cmd_create}")

        try:
            subprocess.run(cmd_create, check=True, input=("\n".join(self.interactive_inputs) + "\n").encode())
        except subprocess.CalledProcessError:
            Utils.print_error(f"Build script {Utils.blue_text(self.build_source)} failed.")
            self.create_cleanup(failed=True)
            return False

        if self.is_ref:
            # Reference overlay: ensure target_dir has files
            if os.listdir(target_dir) == []:
                Utils.print_error(f"Overlay build script did not create any files in {Utils.blue_text(target_dir)}.")
                self.create_cleanup(failed=True)
                return False

            Utils.share_to_ugo_recursive(self.cnt_dir_path)

            Utils.print_message(f"Creating SquashFS file at {Utils.blue_text(self.target_overlay_path)}...")
            cmd_mksqf = [
                Config.SYSTEM_APPTAINER_BIN, "exec",
                "--overlay", self.tmp_overlay_path,
                "--bind", Config.CONDATINER_DIR,
                Config._base_image,
                "/bin/bash", "-c",
                f"""
                mksquashfs {self.cnt_dir_path} {os.path.abspath(self.target_overlay_path)} -processors {self.ncpus} -keep-as-directory {Config.compress_args} -b 1M
                """
            ]
            Utils.print_debug(f"[BUILD] Creating overlay with command: {cmd_mksqf}")
            try:
                subprocess.run(cmd_mksqf, check=True)
            except subprocess.CalledProcessError:
                self.print_create_error_message()
                self.create_cleanup(failed=True)
                return False
        else:
            # app overlay
            Utils.print_message(f"Creating SquashFS file at {Utils.blue_text(self.target_overlay_path)}...")
            cmd_mksqf = [
                Config.SYSTEM_APPTAINER_BIN, "exec",
                "--overlay", self.tmp_overlay_path,
                "--bind", Config.CONDATINER_DIR,
                Config._base_image,
                "/bin/bash", "-c",
                f"""
                echo "Setting permissions..."
                find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
                find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
                mksquashfs /cnt {os.path.abspath(self.target_overlay_path)} -processors {self.ncpus} -keep-as-directory {Config.compress_args} -b 1M
                """
            ]

            Utils.print_debug(f"[BUILD] Creating overlay with command: {cmd_mksqf}")
            try:
                subprocess.run(cmd_mksqf, check=True)
            except subprocess.CalledProcessError:
                self.print_create_error_message()
                self.create_cleanup(failed=True)
                return False

        env_dict = Utils.get_env_dict_from_build_script(self.build_source)
        if env_dict:
            env_file_path = os.path.splitext(self.target_overlay_path)[0] + ".env"
            with open(env_file_path, 'w') as f:
                for env in env_dict:
                    value = env_dict[env]["value"].replace('$app_root', f"/cnt/{self.relative_path}")
                    f.write(f"{env}={value}\n")
                    note = env_dict[env].get("note", "")
                    if note:
                        f.write(f"#ENVNOTE:{env}={note}\n")
            Utils.print_message(f"ENV file created at {Utils.blue_text(env_file_path)}")
            os.chmod(env_file_path, 0o664)

        Utils.print_success(f"Overlay created at {Utils.blue_text(self.target_overlay_path)}. Cleaning up...")
        os.chmod(self.target_overlay_path, 0o664)
        self.create_cleanup(failed=False)
        return True

    def build(self, build_deps = False) -> bool:
        try:
            if self.is_conda:
                return self._build_conda()
            elif self.is_def:
                return self._build_def()
            else:
                return self._build_script(build_deps=build_deps)
        except KeyboardInterrupt:
            Utils.print_message(f"Build for {Utils.yellow_text(self.name_version)} interrupted by user.")
            self.create_cleanup(failed=True)
            return False

    def _create_sbatch_script(self) -> bool:
        sbatch_script_path = os.path.join(Config.TMP_DIR, f"sbatch_build_{self.name_version.replace('/', '--')}.sh")
        os.makedirs(Config.LOGS_DIR, mode=0o775, exist_ok=True)
        try:
            with open(sbatch_script_path, 'w') as f:
                f.write("#!/bin/bash\n")
                for flag in self.sbatch_flags:
                    if flag.startswith("--output"):
                        flag = "--output=" + os.path.join(Config.LOGS_DIR, f"CondaTainer_create_{self.name_version.replace('/', '--')}.out")
                    f.write(f"#SBATCH {flag}\n")
                f.write("\n")
                if Config.debug:
                    f.write(f"/usr/bin/time -v {Config.SCRIPT_PATH} create {self.name_version}\n")
                else:
                    f.write(f"{Config.SCRIPT_PATH} create {self.name_version}\n")
                f.write("echo SLURM_JOB_ID $SLURM_JOB_ID\n")
                f.write("rm -f " + sbatch_script_path + "\n") # Self-delete script after run
            os.chmod(sbatch_script_path, 0o775)
            return True
        except Exception as e:
            Utils.print_error(f"Failed to create sbatch script for {self.name_version}: {e}")
            return False

    def _submit_sbatch(self, dep_ids: List[str]) -> Optional[str]:
        sbatch_script_path = os.path.join(Config.TMP_DIR, f"sbatch_build_{self.name_version.replace('/', '--')}.sh")
        slurm_job_id_regex = re.compile(r'Submitted batch job (\d+)')
        if not self._create_sbatch_script():
            return None

        cmd = ["sbatch", sbatch_script_path]
        if dep_ids:
            dep_str = ":".join(dep_ids)
            cmd.insert(1, f"--dependency=afterok:{dep_str}")
        Utils.print_debug(f"[SBATCH] Submitting sbatch job with command: {cmd}")
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            match = slurm_job_id_regex.search(result.stdout)
            if match:
                job_id = match.group(1)
                if dep_ids:
                    Utils.print_message(f"Submitted sbatch {Utils.blue_text(job_id)} for {Utils.yellow_text(self.name_version)} with dependencies on {Utils.blue_text(', '.join(dep_ids))}.")
                else:
                    Utils.print_message(f"Submitted sbatch {Utils.blue_text(job_id)} for {Utils.yellow_text(self.name_version)}.")
                return job_id
            else:
                Utils.print_error(f"Failed to parse sbatch submission output: {result.stdout}")
                return None
        except subprocess.CalledProcessError as e:
            Utils.print_error(f"Failed to submit sbatch job for {Utils.yellow_text(self.name_version)}: {e.stderr}")
            if os.path.isfile(sbatch_script_path):
                os.remove(sbatch_script_path)
            return None

class BuildGraph:
    """
    BuildGraph expands given BuildMetadata items to include all transitive
    dependencies, detects cycles, produces a topologically-sorted order
    (dependencies before dependents) and separates items into two ordered
    lists:
      - download_metadata: BuildMetadata with sbatch == False
      - build_metadata: BuildMetadata with sbatch == True
    """

    def __init__(self, build_metadata_list: List[BuildObject]):
        # Use instance attributes (avoid shared mutable class attributes)
        self.graph: Dict[str, BuildObject] = {}
        self.download_metadata: List[BuildObject] = [] # No sbatch
        self.build_metadata: List[BuildObject] = [] # With sbatch
        self._build_job_ids: Dict[str, str] = {}

        # Seed graph with provided metadata
        for metadata in build_metadata_list:
            self.graph[metadata.name_version] = metadata
            if metadata.is_installed:
                Utils.print_message(f"Overlay {Utils.yellow_text(metadata.name_version)} is already installed. Skipping.")

        # Topologically sort the graph and separate into download/build lists
        visiting = set()
        visited = set()
        order: List[str] = []

        def visit(node: str):
            if node in visited:
                return
            if node in visiting:
                raise RuntimeError(f"Circular dependency detected involving '{node}'")
            visiting.add(node)
            node_meta = self.graph.get(node)
            if node_meta is None:
                visiting.remove(node)
                # Missing node should not normally happen because we expanded graph, but guard against it.
                raise RuntimeError(f"Unknown dependency '{node}' encountered during graph traversal")
            for dep in node_meta.dependencies:
                if dep not in self.graph:
                    # Expand on-the-fly if needed
                    self.graph[dep] = BuildObject(dep)
                visit(dep)
            visiting.remove(node)
            visited.add(node)
            order.append(node)

        for n in list(self.graph.keys()):
            if n not in visited:
                visit(n)

        for name_version in order:
            meta = self.graph[name_version]
            if Config.submit_job and meta.sbatch and Utils.is_sbatch_available():
                self.build_metadata.append(meta)
            else:
                self.download_metadata.append(meta)

    def run(self) -> bool:
        if not self._run_local_step():
            return False
        if not self._run_sbatch_step():
            return False
        # Check if any apptainer jobs
        if any(bo.is_def for bo in self.build_metadata):
            Utils.print_note("Apptainer is used. You can run " + Utils.blue_text('apptainer cache clean') + " to free up space.")
        return True

    def _run_local_step(self) -> bool:
        for metadata in self.download_metadata:
            if metadata.is_installed:
                continue
            Utils.print_message(f"Processing overlay {Utils.yellow_text(metadata.name_version)} (no sbatch)...")
            if not metadata.build():
                return False
        return True

    def _run_sbatch_step(self) -> bool:
        for metadata in self.build_metadata:
            Utils.print_message(f"Processing overlay {Utils.yellow_text(metadata.name_version)} (with sbatch)...")
            dep_ids = []
            for dep in metadata.dependencies:
                if dep in self._build_job_ids:
                    dep_ids.append(self._build_job_ids[dep])
                elif CondaTainer.is_overlay_installed(dep):
                    continue
                else:
                    Utils.print_error(f"Dependency {Utils.yellow_text(dep)} for {Utils.yellow_text(metadata.name_version)} is not installed and was not submitted via sbatch.")
                    return False
            job_id = metadata._submit_sbatch(dep_ids)
            if job_id is None:
                return False
            self._build_job_ids[metadata.name_version] = job_id
        return True

class CondaTainer_Create:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Create.parser_create = parser.add_parser(
            "create", aliases=["install", "i"],
            help="Create a new SquashFS overlay using available build scripts or Conda")
        CondaTainer_Create.parser_create.add_argument(
            "name_versions", nargs="*",
            help="Package specifications (e.g., name/version, name=version, or name@version)")
        CondaTainer_Create.parser_create.add_argument(
            "-n", "--name", type=str,
            help="Custom name for the resulting overlay file")
        CondaTainer_Create.parser_create.add_argument(
            "-p", "--prefix", type=str,
            help="Custom prefix path for the overlay file")
        CondaTainer_Create.parser_create.add_argument(
            "-f", "--file", type=str,
            help="Path to definition file (.yaml, .sh, .def)"
        )
        CondaTainer_Create.parser_create.add_argument(
            "-b", "--base-image", type=str,
            help="Base image to use instead of default")
        CondaTainer_Create.parser_create.add_argument(
            "-s", "--source", type=str,
            help="Remote source URI (e.g., docker://ubuntu:22.04)")
        CondaTainer_Create.parser_create.add_argument(
            "--temp-size", type=str, dest="size", default=None,
            help="Size of temporary overlay (default: 20G). Accepts GB/MB suffixes; assumes MB if omitted")
        # Compression args
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-fast", action="store_true",
            help="Use zstd compression level 3" + (" (default)" if Config.compress_args == Config.ZSTD_FAST else ""))
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-medium", action="store_true",
            help="Use zstd compression level 8" + (" (default)" if Config.compress_args == Config.ZSTD_MEDIUM else ""))
        CondaTainer_Create.parser_create.add_argument(
            "--zstd", action="store_true",
            help="Use zstd compression level 14" + (" (default)" if Config.compress_args == Config.ZSTD else ""))
        CondaTainer_Create.parser_create.add_argument(
            "--zstd-high", action="store_true",
            help="Use zstd compression level 19" + (" (default)" if Config.compress_args == Config.ZSTD_HIGH else ""))
        CondaTainer_Create.parser_create.add_argument(
            "--gzip", action="store_true",
            help="Use gzip compression" + (" (default)" if Config.compress_args == Config.GZIP else ""))
        CondaTainer_Create.parser_create.add_argument(
            "--lz4", action="store_true",
            help="Use LZ4 compression" + (" (default)" if Config.compress_args == Config.LZ4 else ""))

    @staticmethod
    def parse_create_args(args):
        if "IN_CONDATINER" in os.environ and Utils.is_in_interactive_shell():
            Utils.print_warning("You are running 'condatiner create' inside a CondaTainer overlay.")
            response = input("Are you sure you want to continue? [y/N]: ")
            if response.lower() != 'y':
                return
        if not args.name_versions and not args.file and not args.source:
            CondaTainer_Create.parser_create.error("At least one of name_versions or --file or --source must be provided.")
        if args.name_versions and args.prefix:
            CondaTainer_Create.parser_create.error("name/version arguments cannot be used with --prefix")
        if args.prefix and args.name:
            CondaTainer_Create.parser_create.error("Cannot use both --prefix and --name at the same time")
        if args.source and not (args.name or args.prefix):
            CondaTainer_Create.parser_create.error("When using --source, either --name or --prefix must be provided")
        if args.file and not args.prefix:
            CondaTainer_Create.parser_create.error("When using --file, --prefix must be provided")
        if args.lz4:
            Config.compress_args = Config.LZ4
        elif args.zstd_fast:
            Config.compress_args = Config.ZSTD_FAST
        elif args.zstd_medium:
            Config.compress_args = Config.ZSTD_MEDIUM
        elif args.zstd:
            Config.compress_args = Config.ZSTD
        elif args.gzip:
            Config.compress_args = Config.GZIP

        if args.base_image:
            Config.change_base_image(args.base_image)
        else:
            CondaTainer.ensure_base_image()
        if args.name_versions:
            args.name_versions = [Utils.normalize_name_version(nv) for nv in args.name_versions]
        if args.size:
            try:
                Config.create_tmp_size = Utils.parse_size_to_mb(args.size)
            except ValueError as ve:
                CondaTainer_Create.parser_create.error(str(ve))

        if args.source:
            if args.prefix:
                abs_prefix = os.path.abspath(args.prefix)
            elif args.name:
                normalized_name = Utils.normalize_name_version(args.name)
                n_slash = normalized_name.count('/')
                if n_slash > 1:
                    CondaTainer_Create.parser_create.error("--name cannot contain more than one '/'")
                normalized_name = normalized_name.replace('/', '--')
                abs_prefix = os.path.join(Config.IMAGES_DIR, f"{normalized_name}")
            else:
                return
            Utils.print_debug(f"[CREATE] Creating overlay from source: {args.source}")
            if not CondaTainer_Create.create_sqf_from_source(abs_prefix, args.source):
                exit(1)
        elif args.prefix:
            Utils.print_debug(f"[CREATE] Creating overlay with prefix: {args.prefix}")
            if not CondaTainer_Create.create_prefix_env_sqf(args.prefix, args.file):
                exit(1)
        elif args.name:
            normalized_name = Utils.normalize_name_version(args.name)
            n_slash = normalized_name.count('/')
            if n_slash > 1:
                CondaTainer_Create.parser_create.error("--name cannot contain more than one '/'")
            abs_path = os.path.join(Config.IMAGES_DIR, f"{args.name}.sqf")
            if os.path.isfile(abs_path):
                Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(abs_path))} already exists at {Utils.blue_text(abs_path)}. Skipping creation.")
                return
            Utils.print_debug(f"[CREATE] Creating overlay with name: {args.name}")
            if not CondaTainer_Create.create_env_sqf(abs_path, args.file, args.name_versions):
                exit(1)
        else:
            build_objects = [BuildObject(nv) for nv in args.name_versions]
            for bo in build_objects:
                Utils.print_debug(f"[CREATE] BuildObject created:\n{bo}")
            build_graph = BuildGraph(build_objects)
            if not build_graph.run():
                exit(1)

    @staticmethod
    def create_cleanup(normalized_name_version: str, failed: bool = False):
        cnt_dir = CondaTainer.get_cnt_dir_path(normalized_name_version)
        cnt_dir = os.path.dirname(cnt_dir)
        shutil.rmtree(cnt_dir, ignore_errors=True)
        CondaTainer.remove_tmp_overlay(normalized_name_version)
        if failed:
            CondaTainer.remove_tmp_overlay(normalized_name_version)

    @staticmethod
    def create_env_sqf(overlay_abs_path: str, file_path: Optional[str], name_versions: Optional[List[str]]) -> bool:
        """Create a SquashFS overlay from a conda environment file or name/version specifications."""
        normalized_name_version = Utils.normalize_name_version(os.path.splitext(os.path.basename(overlay_abs_path))[0])
        to_bind_paths = [Config.CONDATINER_DIR]

        if file_path is not None:
            if not file_path.endswith(('.yml', '.yaml')):
                Utils.print_error("The environment file must be in YAML format with .yml or .yaml extension.")
                return False
            abs_file_path = os.path.abspath(file_path)
            to_bind_paths.append(os.path.dirname(abs_file_path))

            install_command = f"micromamba create -r /ext3/tmp -c conda-forge -c bioconda -q -y -p /cnt/{normalized_name_version} -f {abs_file_path}"
            copy_command = f"cp {abs_file_path} /cnt/{normalized_name_version}/env.yaml"
        elif name_versions:
            parsed_name_versions = [nv.replace('/', '=') for nv in name_versions]
            install_command = "micromamba create -r /ext3/tmp -c conda-forge -c bioconda -q -y -p /cnt/" + normalized_name_version + " " + " ".join(parsed_name_versions)
            copy_command = ""
        else:
            Utils.print_error("Either an environment file or name/version specifications must be provided.")
            return False

        Utils.print_message(f"Building SquashFS overlay at {Utils.blue_text(overlay_abs_path)} from environment file {Utils.blue_text(file_path)}")

        if os.path.isfile(overlay_abs_path):
            Utils.print_message(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} already exists at {Utils.blue_text(overlay_abs_path)}. Skipping creation.")
            return True
        tmp_overlay_path = CondaTainer.create_tmp_overlay(normalized_name_version)
        if tmp_overlay_path is None:
            Utils.print_error(f"Temporary overlay {Utils.blue_text(tmp_overlay_path)} already exists. Please remove it first.")
            return False

        try:
            cmd_create = [
                Config.SYSTEM_APPTAINER_BIN, "exec",
                "--env", "TMPDIR=/ext3/tmp",
                "--overlay", tmp_overlay_path,
                *CondaTainer.generate_bind_args(*to_bind_paths),
                *CondaTainer.generate_gpu_args(),
                Config.BASE_IMAGE_SIF,
                "/bin/bash", "-c",
                f"""
                mkdir -p $TMPDIR
                {install_command}
                {copy_command}
                echo "Setting permissions..."
                find /cnt -type f -exec chmod ug+rw,o+r {{}} \\;
                find /cnt -type d -exec chmod ug+rwx,o+rx {{}} \\;
                mksquashfs /cnt {os.path.abspath(overlay_abs_path)} -processors {Config.NCPUS} -keep-as-directory {Config.compress_args} -b 1M
                """
            ]

            Utils.print_debug(f"[CREATE] Creating overlay with command: {cmd_create}")

            try:
                subprocess.run(cmd_create, check=True)
            except subprocess.CalledProcessError:
                Utils.print_error(f"Creating {Utils.blue_text(overlay_abs_path)} from {Utils.blue_text(file_path)} failed.")
                Utils.print_note("If file/folder creation failed, please contact your system admin.")
                Utils.print_note("If cannot resolve the environment file by libmamba, please please consider create img and manually install it with conda.")
                CondaTainer_Create.create_cleanup(normalized_name_version, failed=True)
                return False

            if file_path:
                Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} created from {Utils.blue_text(file_path)}. Removing temporary overlay...")
            elif name_versions:
                Utils.print_success(f"Overlay {Utils.yellow_text(os.path.basename(overlay_abs_path))} created using {','.join(name_versions)}. Removing temporary overlay...")
            os.chmod(overlay_abs_path, 0o664)
            CondaTainer_Create.create_cleanup(normalized_name_version)
            return True
        except KeyboardInterrupt:
            Utils.print_message(f"Creation of overlay {Utils.yellow_text(overlay_abs_path)} interrupted by user.")
            CondaTainer_Create.create_cleanup(normalized_name_version, failed=True)
            raise

    @staticmethod
    def create_prefix_env_sqf(overlay_prefix: str, file_path: str) -> bool:
        abs_path = os.path.abspath(overlay_prefix) + ".sqf"
        if file_path.endswith(('.yml', '.yaml')):
            return CondaTainer_Create.create_env_sqf(abs_path, file_path, None)

        elif file_path.endswith(('.sh', '.bash', '.def')):
            if not os.path.isfile(file_path):
                Utils.print_error(f"Build script file {file_path} not found.")
                return False

            build_obj = BuildObject.from_external_source(overlay_prefix, os.path.abspath(file_path))
            if build_obj is None:
                Utils.print_error(f"Failed to create BuildObject from {file_path}.")
                return False

            build_graph = BuildGraph([build_obj])
            return build_graph.run()

        else:
            Utils.print_error("The build file must be a .sh/.bash/.def script or .yml/.yaml environment file.")
            return False

    @staticmethod
    def create_sqf_from_source(overlay_abs_prefix: str, source: str) -> bool:
        build_obj = BuildObject.from_external_source(overlay_abs_prefix, source, is_apptainer=True)
        if build_obj is None:
            Utils.print_error(f"Failed to create BuildObject from source {source}.")
            return False

        build_graph = BuildGraph([build_obj])
        return build_graph.run()

class CondaTainer_Helper:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Helper.parser_helper = parser.add_parser(
            "helper", help="Run or update helper scripts from helper-scripts/")
        CondaTainer_Helper.parser_helper.add_argument(
            "-u", "--update", action="store_true",
            help="Update helper scripts from remote metadata (if no script provided, update all for chosen mode)")
        CondaTainer_Helper.parser_helper.add_argument(
            "-p", "--path", action="store_true",
            help="Print the absolute path of the helper folder or specific script")
        CondaTainer_Helper.parser_helper.add_argument(
            "script_name", nargs="?",
            help="Name of helper script to run or update")
        CondaTainer_Helper.parser_helper.add_argument(
            "script_args", nargs=argparse.REMAINDER,
            help="Arguments passed to the helper script")

    @staticmethod
    def parse_helper_args(args):
        # --- Path Mode ---
        if args.path:
            if args.script_name:
                local_path = os.path.join(Config.HELPER_SCRIPTS_DIR, args.script_name)
                if os.path.isfile(local_path):
                    print(os.path.abspath(local_path))
                else:
                    Utils.print_error(f"Helper script '{args.script_name}' not found locally.")
                    exit(1)
            else:
                if not os.path.isdir(Config.HELPER_SCRIPTS_DIR):
                    os.makedirs(Config.HELPER_SCRIPTS_DIR, mode=0o775, exist_ok=True)
                print(os.path.abspath(Config.HELPER_SCRIPTS_DIR))
            return

        # --- Update Mode ---
        if args.update:
            meta = Utils.fetch_remote_helper_scripts()
            if not meta:
                Utils.print_error("No remote helper metadata found.")
                exit(1)

            # Choose category based on sbatch availability for metadata lookup
            use_sbatch = Config.submit_job and Utils.is_sbatch_available()
            category = "slurm" if use_sbatch else "headless"
            Utils.print_debug(f"Helper category selected: {category}")
            if use_sbatch and Utils.is_in_interactive_shell():
                Utils.print_note("If you don't want sbatch scripts, please run " + Utils.yellow_text(Config.SCRIPT_NAME + " --local helper -u") + " next time.")
                import time
                time.sleep(1)

            entries = meta.get(category, {})
            os.makedirs(Config.HELPER_SCRIPTS_DIR, mode=0o775, exist_ok=True)

            if args.script_name:
                if args.script_name in entries:
                    entries = {args.script_name: entries[args.script_name]}
                else:
                    Utils.print_error(f"Helper script '{args.script_name}' not found in remote metadata for category '{category}'.")
                    exit(1)
            else:
                Utils.print_message(f"Updating all helper scripts for {category}...")

            for name, v in entries.items():
                rel = v.get("path")
                if not rel:
                    continue
                raw = Config.GIT_RAW_URL_PREFIX + rel
                dest_name = os.path.basename(rel)
                dest = os.path.join(Config.HELPER_SCRIPTS_DIR, dest_name)
                Utils.print_message(f"Updating {category}/{name}")
                if not Utils.download_executable(raw, dest):
                    Utils.print_warning(f"Failed to update {category}/{name}")

            Utils.print_success("Helper update finished.")
            return

        # --- Run Mode ---
        if not args.script_name:
            Utils.print_error("No helper script name provided. Use --update to update scripts.")
            exit(1)

        local_path = os.path.join(Config.HELPER_SCRIPTS_DIR, args.script_name)

        # Strictly check local existence
        if not os.path.isfile(local_path):
            Utils.print_error(f"Helper script '{args.script_name}' not found locally at {local_path}.")
            Utils.print_note(f"Please run {Utils.blue_text(Config.SCRIPT_NAME + ' helper --update')} to fetch available helper scripts.")
            exit(1)

        # Ensure executable permission
        try:
            current_mode = os.stat(local_path).st_mode
            if not (current_mode & stat.S_IXUSR):
                os.chmod(local_path, current_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
        except Exception:
            pass

        cmd = [local_path] + (args.script_args or [])
        Utils.print_debug(f"Running helper command: {cmd}")

        try:
            # check=False allows the script's exit code to pass through without crashing python
            subprocess.run(cmd, check=False)
        except Exception as e:
            Utils.print_error(f"Failed to run helper script: {e}")

class CondaTainer_Exec:
    is_img_writable = False

    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Exec.parser_exec = parser.add_parser("exec", help="Execute a command using overlays")
        CondaTainer_Exec.parser_exec.add_argument(
            "-o", "--overlay", dest="overlays", action="append",
            help="Overlay file to mount (can be used multiple times)")
        CondaTainer_Exec.parser_exec.add_argument(
            "-k", "--keep", action="store_true",
            help="Disable automatic command parsing to installed overlays")
        CondaTainer_Exec.parser_exec.add_argument(
            "-w", "--writable-img", action="store_true",
            help="Mount .img overlays as writable (default: read-only)")
        CondaTainer_Exec.parser_exec.add_argument(
            "--env", dest="env_settings", action="append",
            help="Set environment variable 'KEY=VALUE' (can be used multiple times)")
        CondaTainer_Exec.parser_exec.add_argument(
            "-b", "--base-image", dest="base_image",
            help="Base image to use instead of default")
        CondaTainer_Exec.parser_exec.add_argument(
            "--bind", dest="bind_paths", action="append",
            help="Bind path 'HOST:CONTAINER' (can be used multiple times)")
        CondaTainer_Exec.parser_exec.add_argument(
            "--fakeroot", action="store_true",
            help="Run container with fakeroot privileges")
        CondaTainer_Exec.parser_exec.add_argument(
            "commands", nargs=argparse.REMAINDER,
            help="Command to run inside the container (default: bash)")

        # 'e' Parser (Quick Exec)
        CondaTainer_Exec.parser_e = parser.add_parser("e", help="Run bash using writable overlays")
        CondaTainer_Exec.parser_e.add_argument(
            "-r", "--read-only", dest="writable_img", action="store_false",
            help="Mount .img overlays as read-only (default: writable)")
        CondaTainer_Exec.parser_e.add_argument(
            "-b", "--base-image", dest="base_image",
            help="Base image to use instead of default")
        CondaTainer_Exec.parser_e.add_argument(
            "-n", "--no-autoload", action="store_true",
            help="Disable autoloading 'env.img' from current directory")
        CondaTainer_Exec.parser_e.add_argument(
            "--fakeroot", action="store_true",
            help="Run container with fakeroot privileges")
        CondaTainer_Exec.parser_e.add_argument(
            "overlays", nargs="*",
            help="Overlay files to mount (defaults to env.img)")

    @staticmethod
    def parse_exec_args(args):
        CondaTainer.ensure_base_image()
        CondaTainer_Exec.is_img_writable = args.writable_img

        installed_overlays = CondaTainer.get_installed_overlays()

        if args.base_image:
            Config.change_base_image(args.base_image)

        overlay_final = []
        command_final = []

        if not args.keep and not args.overlays and args.commands:
            Utils.print_debug("[EXEC] Parsing commands to separate overlays and command...")
            for command in args.commands:
                if Utils.is_overlay(command):
                    overlay_final.append(command)
                elif Utils.normalize_name_version(command) in installed_overlays:
                    Utils.print_warning(f"Convert command {Utils.yellow_text(command)} to overlay")
                    overlay_final.append(command)
                else:
                    command_final.append(command)
        else:
            command_final = args.commands if args.commands else []

        overlay_final.extend(args.overlays if args.overlays else [])
        command_final = command_final if command_final else ["bash"]

        for i in range(len(overlay_final)):
            if not Utils.is_overlay(overlay_final[i]):
                overlay_final[i] = installed_overlays.get(Utils.normalize_name_version(overlay_final[i]), overlay_final[i])
            if not os.path.isfile(overlay_final[i]):
                Utils.print_error(f"Overlay file {overlay_final[i]} not found.")
                exit(1)

        if not CondaTainer_Exec.exec_command(overlay_final, command_final, args.env_settings, args.bind_paths, args.fakeroot):
            exit(1)

    @staticmethod
    def parse_e_args(args):
        CondaTainer.ensure_base_image()
        CondaTainer_Exec.is_img_writable = args.writable_img

        overlay_final = args.overlays if args.overlays else []
        command_final = ["bash"]

        installed_overlays = CondaTainer.get_installed_overlays()

        if args.base_image:
            Config.change_base_image(args.base_image)

        for i in range(len(overlay_final)):
            if not Utils.is_overlay(overlay_final[i]):
                overlay_final[i] = installed_overlays.get(Utils.normalize_name_version(overlay_final[i]), overlay_final[i])
            if not os.path.isfile(overlay_final[i]):
                Utils.print_error(f"Overlay file {overlay_final[i]} not found.")
                exit(1)

        if all(not Utils.is_img(o) for o in overlay_final) and not args.no_autoload:
            pwd = os.getcwd()
            local_env_path = os.path.join(pwd, "env.img")
            if os.path.isfile(local_env_path):
                Utils.print_message(f"Autoload env.img at {Utils.blue_text(local_env_path)}")
                overlay_final.append(local_env_path)

        if not CondaTainer_Exec.exec_command(overlay_final, command_final, is_fakeroot=args.fakeroot):
            exit(1)

    @staticmethod
    def get_overlay_abs_paths(paths_or_name_version: List[str]) -> List[str]:
        overlay_abs_paths = []
        if not paths_or_name_version:
            return overlay_abs_paths
        for path in paths_or_name_version:
            # If it's an actual file path (exists or looks like a file), handle that first
            if Utils.is_overlay(path):
                if os.path.isfile(path):
                    overlay_abs_paths.append(os.path.abspath(path))
                    continue
                else:
                    CondaTainer_Exec.parser_exec.error(f"Overlay file {path} not found.")
                    return []

            # Treat non-file inputs as package specs. Accept both name=version and name/version
            # map normalized separator '/' into filename-safe '--'
            normalized_spec = Utils.normalize_name_version(path)
            formatted_filename = normalized_spec.replace("/", "--")
            overlay_filename = f"{formatted_filename}.sqf"
            n = normalized_spec.count('/')
            if n < 2:
                overlay_path = os.path.join(Config.IMAGES_DIR, overlay_filename)
            elif n == 2:
                overlay_path = os.path.join(Config.REF_IMAGES_DIR, overlay_filename)
            else:
                CondaTainer_Exec.parser_exec.error(f"Invalid overlay format: {path}. Too many '/' characters.")
                return []

            if not os.path.isfile(overlay_path):
                Utils.print_error(f"Overlay {Utils.yellow_text(overlay_filename)} not found at {Utils.blue_text(overlay_path)}.")
                CondaTainer_Exec.parser_exec.error(f"Overlay {overlay_filename} not found.")
                return []
            overlay_abs_paths.append(overlay_path)
        return overlay_abs_paths

    @staticmethod
    def get_overlay_env_configs(paths_or_name_version: List[str]) -> List[str]:
        configs = { }
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            env_path = os.path.splitext(op)[0] + ".env"
            if not os.path.isfile(env_path):
                continue

            with open(env_path, 'r') as f:
                for line in f:
                    if line.startswith("#"):
                        continue
                    line = line.strip()
                    if line and '=' in line:
                        key, value = line.split('=', 1)
                        if key in configs:
                            Utils.print_message(f"Environment variable {key} is defined in multiple overlays. Using the value from {os.path.basename(op)}.")
                        configs[key] = value

        params = []
        for key, value in configs.items():
            params.extend(["--env", f"{key}={value}"])
        return params

    @staticmethod
    def only_allow_one_img(paths_or_name_version: List[str]) -> bool:
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        n_img = len([o for o in overlay_abs_paths if Utils.is_img(o)])
        return n_img <= 1

    @staticmethod
    def put_img_to_last(paths_or_name_version: List[str]) -> List[str]:
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        img_paths = [o for o in overlay_abs_paths if Utils.is_img(o)]
        other_paths = [o for o in overlay_abs_paths if not Utils.is_img(o)]
        return other_paths + img_paths

    @staticmethod
    def inspect_image_uid_status(img_path: str, verboase = True) -> int:
        """
        Use debugfs to check if the 'upper' directory inside the ext3/4 image file
        is owned by user whose UID is not equal to current user

        - 0 - root owned
        - 1 - same UID
        - 2 - different UID
        - 9 - failed to check
        """
        if not Utils.is_img(img_path) and not os.path.isfile(img_path):
            return 9
        try:
            cmd = ["debugfs", "-R", "stat upper", img_path]
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            match = re.search(r"User:\s+(\d+)", result.stdout)
            current_uid = os.getuid()
            if match:
                uid = int(match.group(1))
                if uid == 0:
                    return 0
                elif uid == current_uid:
                    return 1
                else:
                    return 2
            return 9
        except subprocess.CalledProcessError:
            Utils.print_warning(f"Failed to check fakeroot status of image {img_path}. Assuming fakeroot.")
            return 9

    @staticmethod
    def get_overlay_env_notes(paths_or_name_version: List[str]) -> Dict[str, str]:
        notes = { }
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            env_path = os.path.splitext(op)[0] + ".env"
            if not os.path.isfile(env_path):
                continue

            with open(env_path, 'r') as f:
                for line in f:
                    if line.startswith("#ENVNOTE:"):
                        note_content = line[len("#ENVNOTE:"):].strip()
                        if '=' in note_content:
                            key, note = note_content.split('=', 1)
                            notes[key] = note
        return notes

    @staticmethod
    def get_path_env(paths_or_name_version: List[str]) -> str:
        paths = [ "/usr/sbin", "/usr/bin" ]
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for path in overlay_abs_paths:
            name = os.path.splitext(os.path.basename(path))[0]
            name = Utils.normalize_name_version(name)
            n_slash = name.count('/')
            if n_slash > 1: # skip ref
                continue
            if Utils.is_img(path):
                relative_path = "/ext3/env/bin"
            elif Utils.is_sqf(path):
                relative_path = f"/cnt/{name}/bin"
            else:
                Utils.print_warning(f"Unknown overlay file extension for {path}. Skipping PATH addition.")
                continue
            paths.insert(0, relative_path)
        return ":".join(paths)

    @staticmethod
    def generate_overlay_args(paths_or_name_version: List[str]) -> List[str]:
        mounts = []
        overlay_abs_paths = CondaTainer_Exec.get_overlay_abs_paths(paths_or_name_version)
        for op in overlay_abs_paths:
            if CondaTainer_Exec.is_img_writable and Utils.is_img(op):
                Utils.print_debug(f"[EXEC] Making overlay {Utils.blue_text(op)} writable.")
                mounts.extend(["--overlay", op])
            else:
                mounts.extend(["--overlay", op + ":ro"])
        return mounts

    @staticmethod
    def exec_command(
            paths_or_name_versions: List[str],
            command: List[str],
            env_settings: Optional[List[str]] = None,
            bind_paths: Optional[List[str]] = None,
            is_fakeroot: bool = False,
            capture_output: bool = False) -> bool:

        if not CondaTainer_Exec.only_allow_one_img(paths_or_name_versions):
            Utils.print_error("Only one .img overlay can be used at a time.")
            return False
        paths_or_name_versions = CondaTainer_Exec.put_img_to_last(paths_or_name_versions)
        path_env = CondaTainer_Exec.get_path_env(paths_or_name_versions)
        env_params = CondaTainer_Exec.get_overlay_env_configs(paths_or_name_versions)
        fakeroot_param = [ "--fakeroot" ] if is_fakeroot else []

        last_img = None
        img_env = []
        if paths_or_name_versions:
            for o in paths_or_name_versions:
                if Utils.is_img(o):
                    last_img = o

        if last_img is not None:
            if "IN_CONDATINER" in os.environ:
                Utils.print_warning("You are trying to mount an .img overlay inside an existing CondaTainer environment. This may lead to unexpected behavior.")

            img_name = os.path.splitext(os.path.basename(last_img))[0]
            img_name = Utils.normalize_name_version(img_name)
            img_env.extend([
                "--env", "MAMBA_ROOT_PREFIX=/ext3/env",
                "--env", "CONDA_PREFIX=/ext3/env",
                "--env", "CONDA_DEFINE_ENV=env",
                "--env", "RETICULATE_PYTHON=/ext3/env/bin/python",
            ])

            if CondaTainer_Exec.is_img_writable:
                if not is_fakeroot:
                    uid_status = CondaTainer_Exec.inspect_image_uid_status(last_img)
                    if uid_status == 0:
                        Utils.print_note(f"Root overlay {Utils.blue_text(os.path.basename(last_img))}. --fakeroot added automatically")
                        fakeroot_param = [ "--fakeroot" ]
                    elif uid_status == 2:
                        Utils.print_warning(f"{Utils.blue_text(os.path.basename(last_img))}'s inner UID is different. --fakeroot added automatically")
                        fakeroot_param = [ "--fakeroot" ]

                img_env.extend([
                    "--env", "CNT_CONDA_PREFIX=/ext3/env",
                ])

        additional_env = []
        if env_settings:
            for es in env_settings:
                if '=' in es:
                    additional_env.extend(["--env", es])
                else:
                    Utils.print_warning(f"Invalid env setting {es}. It should be in KEY=VALUE format. Skipping.")
        env_params.extend(additional_env)
        additional_binds = []
        if bind_paths:
            for bp in bind_paths:
                additional_binds.append("--bind")
                additional_binds.append(bp)

        exec_cmd = [
            Config.SYSTEM_APPTAINER_BIN, "exec",
            *CondaTainer_Exec.generate_overlay_args(paths_or_name_versions),
            *env_params,
            "--env", f"PATH={path_env}",
            "--env", "LC_ALL=C.UTF-8",
            "--env", "LANG=C.UTF-8",
            "--env", "PS1=CNT \\[\\e[0;34m\\]\\w\\[\\e[0m\\]> ",
            "--env", "IN_CONDATINER=1",
            *img_env,
            *CondaTainer.generate_bind_args(Config.CONDATINER_DIR),
            *additional_binds,
            *fakeroot_param,
            *CondaTainer.generate_gpu_args(),
            Config._base_image,
            *command
        ]

        Utils.print_debug(f"[EXEC] Executing command: {exec_cmd}")

        if Utils.is_in_interactive_shell() and not capture_output:
            env_notes = CondaTainer_Exec.get_overlay_env_notes(paths_or_name_versions)

            if env_notes:
                env_max_len = max(len(key) for key in env_notes.keys())
                Utils.print_message("Overlay envs:")
                for key, note in env_notes.items():
                    print(f"  {Utils.yellow_text(key.ljust(env_max_len))}: {note}")
                if last_img is not None and CondaTainer_Exec.is_img_writable:
                    print(f"  {Utils.yellow_text('CNT_CONDA_PREFIX'.ljust(env_max_len))}: {Utils.blue_text('/ext3/env')}")
                print("")
            else:
                if last_img is not None and CondaTainer_Exec.is_img_writable:
                    print(f"Overlay env:\n  {Utils.yellow_text('CNT_CONDA_PREFIX')}: {Utils.blue_text('/ext3/env')}\n")
        try:
            subprocess.run(exec_cmd, check=True, capture_output=capture_output)
        except subprocess.CalledProcessError:
            if last_img is not None and Utils.is_in_interactive_shell() and not capture_output:
                Utils.print_error("Command execution failed inside the container with writable image.")
                Utils.print_note(f"Please go to https://github.com/{Config.GITHUB_REPO}/blob/main/docs/qa/exec.md for troubleshooting.")
            return False

        return True

class CondaTainer_Avail:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Avail.parser_avail = parser.add_parser(
            "avail", aliases=["av"],
            help="Check available local and remote build scripts")
        CondaTainer_Avail.parser_avail.add_argument(
            "terms", type=str, nargs="*",
            help="Search terms (AND logic applied)")
        CondaTainer_Avail.parser_avail.add_argument(
            "-i", "--install", "-a", "--add",
            dest = "install", action="store_true",
            help="Install the selected build scripts (used with terms)")

    @staticmethod
    def parse_avail_args(args):
        if args.terms:
            args.terms = [Utils.normalize_name_version(term) for term in args.terms]

        local_packages = Utils.get_local_build_scripts()
        # Fetch remote metadata entries if configured
        remote_packages = {}
        if Config.REMOTE_METADATA_URL:
            remote_packages = Utils.fetch_remote_build_scripts()

        installed_overlays = CondaTainer.get_installed_overlays()

        added_packages = set()
        all_packages = []
        for k, v in local_packages.items():
            if k in installed_overlays:
                if v.endswith(".def"):
                    all_packages.append(f"{k} (installed, container)")
                else:
                    all_packages.append(f"{k} (installed)")
            else:
                if v.endswith(".def"):
                    all_packages.append(f"{k} (container)")
                else:
                    all_packages.append(k)
            added_packages.add(k)
        # add remote-only packages with a marker
        for k, v in sorted(remote_packages.items()):
            if k not in added_packages:
                if k in installed_overlays:
                    if v.endswith(".def"):
                        all_packages.append(f"{k} (remote, container, installed)")
                    else:
                        all_packages.append(f"{k} (remote, installed)")
                else:
                    if v.endswith(".def"):
                        all_packages.append(f"{k} (remote, container)")
                    else:
                        all_packages.append(f"{k} (remote)")
                added_packages.add(k)

        if args.terms:
            # match ONLY packages that contain *all* terms (logical AND)
            filtered_packages = [
                p for p in all_packages
                if all(re.search(re.escape(term), p, re.IGNORECASE) for term in args.terms)
            ]
        else:
            filtered_packages = all_packages

        if not filtered_packages:
            Utils.print_warning("No matching local or remote build scripts found.")
            return

        for pkg in sorted(filtered_packages):
            if args.terms:
                highlighted = pkg
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
                print(highlighted)
            else:
                print(pkg)

        uninstalled_packages = set()
        for pkg in filtered_packages:
            if "installed" in pkg:
                continue
            else:
                uninstalled_packages.add(pkg.split(' ')[0])

        if Utils.is_in_interactive_shell() and args.install and args.terms and uninstalled_packages:
            print("==================INSTALL==================")
            print("The following overlays will be installed:")
            for pkg in sorted(uninstalled_packages):
                print(f" - {pkg}")
            Utils.print_message("Do you want to install the above overlays? [y/N]: ", end="")
            choice = input().strip().lower()
            if choice != 'y':
                return

            CondaTainer.ensure_base_image()
            build_objects = [BuildObject(pkg) for pkg in uninstalled_packages]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All selected overlays installed/submitted.")
            else:
                Utils.print_error("Some overlays failed to install.")

class CondaTainer_List:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_List.parser_list = parser.add_parser(
            "list", aliases=["ls"],
            help="List installed overlays matching search terms")
        CondaTainer_List.parser_list.add_argument(
            "terms", type=str, nargs="*",
            help="Search terms (AND logic applied)")
        CondaTainer_List.parser_list.add_argument(
            "-d", "--delete", "-r", "--remove",
            dest = "delete", action="store_true",
            help="Delete listed overlays after confirmation (used with terms)")

    @staticmethod
    def parse_list_args(args):
        if args.terms:
            args.terms = [Utils.normalize_name_version(term) for term in args.terms]

        if os.path.isdir(Config.IMAGES_DIR):
            overlay_files = [f for f in os.listdir(Config.IMAGES_DIR) if Utils.is_overlay(f)]
            name_versions_dict = {}
            for overlay in overlay_files:
                name_version = os.path.splitext(overlay)[0]
                if '--' in name_version:
                    name, version = name_version.split('--', 1)
                    if args.terms:
                        if not all(re.search(re.escape(term), name_version, re.IGNORECASE) for term in args.terms):
                            continue
                    if name in name_versions_dict:
                        name_versions_dict[name].append(version)
                    else:
                        name_versions_dict[name] = [version]
                else:
                    if args.terms:
                        if not all(re.search(re.escape(term), name_version, re.IGNORECASE) for term in args.terms):
                            continue
                    name_versions_dict[name_version] = [f"(system app overlay)"]

            if name_versions_dict:
                name_col_width = max(len(name) for name in name_versions_dict.keys())
                print("Available app overlays:")
                for name in sorted(name_versions_dict.keys()):
                    print(f" {Utils.yellow_text(name.ljust(name_col_width))}: {', '.join(sorted(name_versions_dict[name]))}")

        if os.path.isdir(Config.REF_IMAGES_DIR):
            ref_overlay_files = [
                f for f in os.listdir(Config.REF_IMAGES_DIR)
                    if Utils.is_overlay(f) and
                    all(re.search(re.escape(term), f, re.IGNORECASE) for term in args.terms)]
            if ref_overlay_files:
                print("Available reference overlays:")
                for overlay in sorted(ref_overlay_files):
                    name_version = os.path.splitext(overlay)[0].replace('--', '/')
                    if args.terms:
                        colored_name_version = name_version
                        for term in args.terms:
                            colored_name_version = re.sub(
                                re.escape(term),
                                lambda m: Utils.yellow_text(m.group(0)),
                                colored_name_version,
                                flags=re.IGNORECASE
                            )
                        print(" " + colored_name_version)
                    else:
                        print(" " + name_version)

        if Utils.is_in_interactive_shell() and args.delete and args.terms:
            print("==================REMOVE==================")
            CondaTainer_Remove.parse_remove_args(args)

class CondaTainer_Remove:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Remove.parser_remove = parser.add_parser(
            "remove", aliases=["rm", "delete"],
            help="Remove installed overlays matching search terms")
        CondaTainer_Remove.parser_remove.add_argument(
            "terms", type=str, nargs="+",
            help="Names or Search terms (AND logic applied)")

    @staticmethod
    def parse_remove_args(args):
        if args.terms:
            args.terms = [Utils.normalize_name_version(term) for term in args.terms]

        installed_overlays_dict = CondaTainer.get_installed_overlays()

        if not installed_overlays_dict:
            Utils.print_warning("No installed overlays found.")
            return

        if args.terms[0] in installed_overlays_dict:
            # Exact match found, names mode
            filtered_overlays = []
            for term in args.terms:
                if term in installed_overlays_dict:
                    filtered_overlays.append(term)
                else:
                    Utils.print_warning(f"Overlay {Utils.yellow_text(term)} not found among installed overlays.")
        else:
            filtered_overlays = []
            for overlay in installed_overlays_dict.keys():
                if args.terms:
                    if all(re.search(re.escape(term), overlay, re.IGNORECASE) for term in args.terms):
                        filtered_overlays.append(overlay)
                else:
                    filtered_overlays.append(overlay)

            if not filtered_overlays:
                Utils.print_warning("No matching installed overlays found.")
                return

        print("Overlays to be removed:")
        for overlay in sorted(filtered_overlays):
            highlighted = overlay
            if args.terms:
                for term in args.terms:
                    highlighted = re.sub(
                        re.escape(term),
                        lambda m: Utils.yellow_text(m.group(0)),
                        highlighted,
                        flags=re.IGNORECASE
                    )
            print(f" - {highlighted}")

        Utils.print_message("Are you sure? Cannot be undone. [y/N]: ", end="")
        choice = input().strip().lower()
        if choice != 'y':
            return

        for overlay in filtered_overlays:
            overlay_path = installed_overlays_dict[overlay]
            try:
                os.remove(overlay_path)
                Utils.print_success(f"Overlay {Utils.yellow_text(overlay)} removed.")
                env_path = os.path.splitext(overlay_path)[0] + ".env"
                if os.path.isfile(env_path):
                    os.remove(env_path)
            except Exception as e:
                Utils.print_error(f"Failed to remove overlay {Utils.yellow_text(overlay)}: {str(e)}")

class CondaTainer_Info:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Info.parser_info = parser.add_parser("info", help="Show information about a specific overlay")
        CondaTainer_Info.parser_info.add_argument(
            "overlay", type=str,
            help="Overlay package (e.g., bcftools/1.22)")

    @staticmethod
    def get_file_btime(file_path: str) -> Optional[datetime]:
        try:
            result = subprocess.check_output(
                ['stat', '-c', '%W', file_path],
                text=True
            ).strip()

            if result in ('0', '-'):
                return None

            return datetime.fromtimestamp(int(result))

        except (subprocess.CalledProcessError, ValueError):
            return None

    @staticmethod
    def get_file_mtime(file_path: str) -> Optional[datetime]:
        try:
            result = subprocess.check_output(
                ['stat', '-c', '%Y', file_path],
                text=True
            ).strip()

            return datetime.fromtimestamp(int(result))

        except (subprocess.CalledProcessError, ValueError):
            return None

    @staticmethod
    def get_file_atime(file_path: str) -> Optional[datetime]:
        try:
            result = subprocess.check_output(
                ['stat', '-c', '%X', file_path],
                text=True
            ).strip()

            return datetime.fromtimestamp(int(result))

        except (subprocess.CalledProcessError, ValueError):
            return None

    @staticmethod
    def get_compression_type(file_path) -> str:
        try:
            result = subprocess.check_output(
                ['file', file_path],
                text=True
            ).strip()

            match = re.search(r',\s+(\w+)\s+compressed', result)
            if match:
                return match.group(1)
            else:
                return 'not available'

        except subprocess.CalledProcessError:
            return 'not available'

    @staticmethod
    def parse_info_args(args):
        installed_overlays_dict = CondaTainer.get_installed_overlays()
        overlay = Utils.normalize_name_version(args.overlay)
        if overlay in installed_overlays_dict.keys(): # installed overlay
            overlay_path = installed_overlays_dict[overlay]
        else: # external overlay
            overlay_path = os.path.abspath(args.overlay)
            if not os.path.isfile(overlay_path):
                Utils.print_error(f"Overlay file {Utils.blue_text(overlay_path)} not found.")
                exit(1)

        print(f"Information for {Utils.yellow_text(os.path.basename(overlay_path))}:")
        # Additional info can be added here, e.g., size, creation date, etc.
        print(f"Writable: {'Yes' if Utils.is_img(overlay_path) else 'No'}")

        file_size = os.path.getsize(overlay_path)
        if file_size < 1024:
            print(f"Size: {file_size} Bytes")
        elif file_size < 1_048_576:
            print(f"Size: {file_size / 1024:.2f} KiB")
        elif file_size < 1_073_741_824:
            print(f"Size: {file_size / 1_048_576:.2f} MiB")
        else:
            print(f"Size: {file_size / 1_073_741_824:.2f} GiB")

        print(f"Compression:   {CondaTainer_Info.get_compression_type(overlay_path)}")

        btime_dt = CondaTainer_Info.get_file_btime(overlay_path)
        if btime_dt is not None:
            print(f"Creation time: {btime_dt:%Y-%m-%d %H:%M:%S}")
        else:
            print("Creation time: not available")
        mtime_dt = CondaTainer_Info.get_file_mtime(overlay_path)
        if mtime_dt is not None:
            print(f"Last modified: {mtime_dt:%Y-%m-%d %H:%M:%S}")
        else:
            print("Last modified: not available")
        atime_dt = CondaTainer_Info.get_file_atime(overlay_path)
        if atime_dt is not None:
            print(f"Last accessed: {atime_dt:%Y-%m-%d %H:%M:%S}")
        else:
            print("Last accessed: not available")

        if Utils.is_sqf(overlay_path):
            name = os.path.splitext(os.path.basename(overlay_path))[0]
            name = name.replace('--', '/').replace('=', '/')
            print(f"Mount path:    /cnt/{name}")
        elif Utils.is_img(overlay_path):
            status = CondaTainer_Exec.inspect_image_uid_status(overlay_path, verboase=False)
            if status == 0:
                print("Files owner:   root owned (--fakeroot required)")
            elif status == 1:
                print("Files owner:   current UID")
            elif status == 2:
                print("Files owner:   different UID (chown required)")
            else:
                print("Files owner:   unknown")
            print(f"Mount path:    /ext3/env")

        env_path = os.path.splitext(overlay_path)[0] + ".env"
        if os.path.isfile(env_path):
            print("Environment variables:")
            with open(env_path, 'r') as f:
                for line in f:
                    print(f"  - {line.strip()}")

class CondaTainer_Check:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Check.parser_check = parser.add_parser(
            "check",
            help="Check if the dependencies of a script are installed")
        CondaTainer_Check.parser_check.add_argument(
            "script", type=str,
            help="Path to the script to check")
        CondaTainer_Check.parser_check.add_argument(
            "-a", "--auto-install", "-i", "--install",
            dest="auto_install", action="store_true",
            help="Automatically install missing dependencies")

    @staticmethod
    def parse_check_args(args):
        script_path_or_name = args.script
        is_remote = False
        if not os.path.isfile(script_path_or_name):
            script_path_or_name = Utils.normalize_name_version(script_path_or_name)
            local_build_scripts = Utils.get_local_build_scripts()
            Utils.print_debug(f"[CHECK] Checking for build script {script_path_or_name} locally and remotely...")
            if script_path_or_name in local_build_scripts:
                script_path = local_build_scripts[script_path_or_name]
                Utils.print_message(f"Found local build script {Utils.blue_text(script_path)}")
            elif script_path_or_name in Utils.fetch_remote_build_scripts():
                Utils.print_message(f"Downloading build script for {script_path_or_name} from remote metadata...")
                is_remote = True
                url = Utils.fetch_remote_build_scripts()[script_path_or_name]
                script_path = os.path.join(Config.CONDATINER_DIR, f"{script_path_or_name.replace('/', '--')}.sh")
                if Utils.download_executable(url, script_path):
                    Utils.print_message(f"Downloaded build script to {Utils.blue_text(script_path)}")
                else:
                    Utils.print_error(f"Failed to download build script for {script_path_or_name} from {url}.")
                    exit(1)
            else:
                Utils.print_error(f"Build script for {script_path_or_name} not found.")
                exit(1)
        else:
            script_path = script_path_or_name

        deps = Utils.get_dependencies_from_script(script_path)
        for d in deps:
            Utils.print_message(f"Dependency: {Utils.yellow_text(d)}" + Utils.red_text(" (missing)" if not CondaTainer.is_overlay_installed(d) else ""))
        missing_deps = CondaTainer.get_missing_overlays(deps)

        if not missing_deps:
            Utils.print_message("All dependencies are installed.")
            if is_remote and os.path.isfile(script_path):
                os.remove(script_path)
            return

        if args.auto_install:
            Utils.print_message("Attempting to auto-install missing dependencies...")
            CondaTainer.ensure_base_image()
            build_objects = [BuildObject(pkg) for pkg in missing_deps]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All selected overlays installed/submitted.")
            else:
                Utils.print_error("Some overlays failed to install.")
        else:
            Utils.print_message(f"Run the command again with {Utils.blue_text('-a')} or {Utils.blue_text('--auto-install')} to install missing dependencies.")

        if is_remote and os.path.isfile(script_path):
            os.remove(script_path)

class CondaTainer_Run:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Run.parser_run = parser.add_parser(
            "run",
            help="Run a script and auto-solve the dependencies by #DEP tags")
        CondaTainer_Run.parser_run.add_argument(
            "script", type=str,
            help="Path to the script to run")
        CondaTainer_Run.parser_run.add_argument(
            "-w", "--writable-img", action="store_true",
            help="Make .img overlays writable (default: read-only)")
        CondaTainer_Run.parser_run.add_argument(
            "-b", "--base-image", type=str,
            help="Base image to use instead of default")
        CondaTainer_Run.parser_run.add_argument(
            "-a", "--auto-install", "-i", "--install",
            dest="auto_install", action="store_true",
            help="Automatically install missing dependencies")

    @staticmethod
    def parse_args_in_script(script_path: str) -> List[str]:
        args = []
        if not os.path.isfile(script_path):
            Utils.print_error(f"Script file {script_path} not found.")
            return args

        with open(script_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith("#CNT"):
                    arg_line = line[len("#CNT"):].strip()
                    args.append(arg_line)
        return args

    @staticmethod
    def parse_run_args(args):
        CondaTainer.ensure_base_image()
        script_path = args.script
        if not os.path.isfile(script_path):
            CondaTainer_Run.parser_run.error(f"Script file {script_path} not found.")
        script_path = os.path.abspath(script_path)

        args_from_script = CondaTainer_Run.parse_args_in_script(script_path)
        merged = args_from_script + sys.argv[2:]
        args = CondaTainer_Run.parser_run.parse_args(merged)

        if Config.debug and args_from_script:
            Utils.print_debug(f"[RUN] Additional script arguments found: {args_from_script}")

        if args.base_image:
            Config.change_base_image(args.base_image)

        deps = Utils.get_dependencies_from_script(script_path)
        missing_deps = CondaTainer.get_missing_overlays(deps)

        if missing_deps:
            if not args.auto_install:
                Utils.print_message("Missing dependencies:")
                for md in missing_deps:
                    Utils.print_message(f"  - {Utils.yellow_text(md)}")

                Utils.print_message(f"Please run {Utils.blue_text(Config.SCRIPT_NAME + ' check -a')} to install missing dependencies.")
                return

            Utils.print_message("Attempting to auto-install missing dependencies...")
            for md in missing_deps:
                if Utils.is_overlay(md):
                    Utils.print_error(f"Custom overlay {Utils.yellow_text(md)} is missing. Cannot proceed with auto-installation.")
                    exit(1)

            build_objects = [BuildObject(pkg) for pkg in missing_deps]
            build_graph = BuildGraph(build_objects)
            if build_graph.run():
                Utils.print_success("All selected overlays installed/submitted.")
            else:
                Utils.print_error("Some overlays failed to install.")
                exit(1)

        if args.writable_img:
            CondaTainer_Exec.is_img_writable = True

        execution_command_list = [
            "module() { :; }", # disable module command
            "ml() { :; }",
            "export -f module ml",
        ]
        if os.access(script_path, os.X_OK):
            execution_command_list.append(script_path)
        else:
            execution_command_list.append(f"bash {script_path}")

        if not CondaTainer_Exec.exec_command(deps, [ "/bin/bash", "-c", "\n".join(execution_command_list)] ):
            exit(1)

class CondaTainer_Overlay:
    @staticmethod
    def add_parser_arguments(parser):
        parser_overlay = parser.add_parser("overlay", help="Manage overlay images (create, chown, resize)")
        subparsers = parser_overlay.add_subparsers(
            dest="overlay_action",
            metavar="ACTION",
            required=True,
            help="Overlay actions"
        )

        parser_create = subparsers.add_parser("create", help="Create a new empty overlay image")
        CondaTainer_Overlay._add_create_args(parser_create)

        parser_chown = subparsers.add_parser("chown", help="Change ownership (UID:GID) of files inside an overlay")
        parser_chown.add_argument(
            "image", type=str,
            help="Path to the overlay image")
        parser_chown.add_argument(
            "-u", "--uid", type=int, default=os.getuid(),
            help=f"User ID to set (default: current user {os.getuid()})")
        parser_chown.add_argument(
            "-g", "--gid", type=int, default=os.getgid(),
            help=f"Group ID to set (default: current group {os.getgid()})")
        parser_chown.add_argument(
            "--root", action="store_true",
            help="Set UID and GID to 0 (root); will override -u and -g options")
        parser_chown.add_argument(
            "-p", "--path", type=str, default="/ext3",
            help="Path inside the overlay to change (default: /ext3)")

        parser_resize = subparsers.add_parser("resize", help="Resize an existing overlay in-place")
        parser_resize.add_argument("image", type=str, help="Overlay image to resize")
        parser_resize.add_argument("-s", "--size", type=str, required=True, help="New size (GB/MB; default to MB if no suffix.)")

        parser_o = parser.add_parser("o", help="Shortcut for 'overlay create'")
        CondaTainer_Overlay._add_create_args(parser_o)

    @staticmethod
    def _add_create_args(parser):
        """Helper to add create arguments to both 'overlay create' and 'o'"""
        parser.add_argument(
            "-s", "--size", type=str, default="10G",
            help="Set overlay size (default: 10G). Accepts GB/MB suffixes; assumes MB if omitted")
        parser.add_argument(
            "-f", "--file", type=str,
            help="Initialize with Conda environment file (.yaml/.yml)")
        parser.add_argument(
            "--fakeroot", action="store_true",
            help="Create a fakeroot-compatible overlay")
        parser.add_argument(
            "--sparse", action="store_true",
            help="Create a sparse overlay image (default: false)")
        parser.add_argument(
            "image", type=str, nargs="?", default="env.img",
            help="Path to the output overlay image (default: env.img)")

    @staticmethod
    def parse_overlay_args(args):
        if args.action == "o":
            CondaTainer_Overlay.run_create(args)
        elif args.action == "overlay":
            if args.overlay_action == "create":
                CondaTainer_Overlay.run_create(args)
            elif args.overlay_action == "chown":
                CondaTainer_Overlay.run_chown(args)
            elif args.overlay_action == "resize":
                CondaTainer_Overlay.run_resize(args)

    @staticmethod
    def run_create(args):
        CondaTainer.ensure_base_image()
        overlay_path = os.path.abspath(args.image)
        try:
            size_mib = Utils.parse_size_to_mb(args.size)
        except ValueError as ve:
            Utils.print_error(str(ve))
            exit(1)
        is_fakeroot = args.fakeroot
        overlay_adj = " "
        fakeroot_arg = []
        if is_fakeroot:
            overlay_adj += "fakeroot "
            fakeroot_arg = [ "--fakeroot" ]
        sparse_arg = []
        if args.sparse:
            overlay_adj += "sparse "
            sparse_arg = [ "--sparse" ]

        if not Utils.is_img(overlay_path):
            if '.' in os.path.basename(overlay_path):
                Utils.print_error("Overlay image must have a .img extension.")
                exit(1)
            overlay_path += ".img"

        if os.path.isfile(overlay_path) or os.path.isdir(overlay_path):
            Utils.print_error(f"Path {Utils.blue_text(overlay_path)} already exists.")
            exit(1)

        if args.file:
            if not os.path.isfile(args.file):
                Utils.print_error(f"Conda env file {Utils.blue_text(args.file)} not found.")
                exit(1)

        Utils.print_message(f"Creating{overlay_adj}overlay at {Utils.blue_text(overlay_path)} with size {Utils.yellow_text(str(size_mib) + ' MiB')}...")
        cmd_overlay = [
            Config.SYSTEM_APPTAINER_BIN, "overlay", "create",
            "--size", str(size_mib),
            *fakeroot_arg, *sparse_arg,
            overlay_path
        ]

        try:
            subprocess.run(cmd_overlay, check=True)
            Utils.share_to_ugo_recursive(overlay_path)
            Utils.print_success(f"Overlay image created at {Utils.blue_text(overlay_path)}.")
        except subprocess.CalledProcessError:
            Utils.print_error("Failed to create overlay image.")
            exit(1)

        CondaTainer_Exec.is_img_writable = True
        if args.file:
            Utils.print_message(f"Initializing conda environment using {os.path.abspath(args.file)}...")
            if CondaTainer_Exec.exec_command([overlay_path], ["mm-create", "-f", os.path.abspath(args.file), "-y"], is_fakeroot=is_fakeroot, capture_output=True):
                CondaTainer_Exec.exec_command([overlay_path], ["mm-clean", "-a", "-y"], is_fakeroot=is_fakeroot, capture_output=True)
                Utils.print_success(f"Conda env is created inside {Utils.blue_text(overlay_path)}.")
            else:
                Utils.print_error(f"Failed to create conda env inside {Utils.blue_text(overlay_path)}.")
                exit(1)
        else:
            Utils.print_message("Initializing minimal conda environment with small package (zlib)...")
            if CondaTainer_Exec.exec_command([overlay_path], ["mm-create", "zlib", "-y"], is_fakeroot=is_fakeroot, capture_output=True):
                CondaTainer_Exec.exec_command([overlay_path], ["mm-clean", "-a", "-y"], is_fakeroot=is_fakeroot, capture_output=True)
                Utils.print_success(f"Conda env is created inside {Utils.blue_text(overlay_path)}.")
            else:
                Utils.print_error(f"Failed to create conda env inside {Utils.blue_text(overlay_path)}.")
                exit(1)

    @staticmethod
    def run_chown(args):
        """Use debugfs to recursively chown files inside an ext3 overlay image"""
        CondaTainer.ensure_base_image()
        overlay_path = os.path.abspath(args.image)

        if not os.path.isfile(overlay_path):
            Utils.print_error(f"Overlay file {Utils.blue_text(overlay_path)} not found.")
            return

        target_uid = args.uid
        target_gid = args.gid

        if args.root:
            target_uid = 0
            target_gid = 0

        # 1. Translate Logical Path to Internal Path
        #    /       -> /upper
        #    /opt    -> /upper/opt
        user_path = args.path.strip()
        internal_target_path = os.path.normpath(
            os.path.join("/upper", user_path.lstrip(os.sep))
        )

        debugfs_bin = shutil.which("debugfs")
        if not debugfs_bin:
            for fallback in ["/sbin/debugfs", "/usr/sbin/debugfs"]:
                if os.path.exists(fallback):
                    debugfs_bin = fallback
                    break

        if not debugfs_bin:
             Utils.print_error("Cannot fix permissions: 'debugfs' not found in PATH.")
             return

        Utils.print_message(f"Mapping inodes in {Utils.blue_text(os.path.basename(overlay_path))} starting at {Utils.blue_text(internal_target_path)}...")

        try:
            # --- PHASE 1: RECURSIVE INODE DISCOVERY ---
            inodes_to_chown = set()
            dirs_to_visit = []

            # A. Get the starting inode of the target path
            cmd_root = [debugfs_bin, "-R", f"stat {internal_target_path}", overlay_path]
            proc_root = subprocess.run(cmd_root, capture_output=True, text=True)

            if proc_root.returncode != 0:
                Utils.print_error(f"Path {internal_target_path} not found in image.")
                return

            match = re.search(r"Inode:\s+(\d+)", proc_root.stdout)
            if match:
                start_inode = match.group(1)
                dirs_to_visit.append(start_inode)
                inodes_to_chown.add(start_inode)
            else:
                Utils.print_error("Could not parse start inode.")
                return

            # B. Walk the tree
            Utils.print_message("Scanning directory tree (this may take a moment)...")

            visited_dirs = set()
            scanned_count = 0

            while dirs_to_visit:
                current_inode = dirs_to_visit.pop(0)

                if current_inode in visited_dirs:
                    continue
                visited_dirs.add(current_inode)

                # List contents of this inode
                list_cmd = [debugfs_bin, "-R", f"ls -l <{current_inode}>", overlay_path]
                proc = subprocess.run(list_cmd, capture_output=True, text=True)

                for line in proc.stdout.splitlines():
                    parts = line.strip().split()
                    if not parts or not parts[0].isdigit():
                        continue

                    inode = parts[0]
                    mode_octal = parts[1]
                    name = parts[-1]

                    if name in [".", ".."]:
                        continue

                    inodes_to_chown.add(inode)

                    scanned_count += 1
                    if scanned_count % 2000 == 0:
                      print(f"\rScanning... Found {scanned_count} inodes so far...", end="", flush=True)

                    if mode_octal.startswith("4") or mode_octal.startswith("04"):
                        dirs_to_visit.append(inode)

            print(f"\rScanning complete. Found {len(inodes_to_chown)} unique inodes.        ", flush=True)

            # --- PHASE 2: BATCH UPDATE ---
            if not inodes_to_chown:
                 Utils.print_warning("No inodes found.")
                 return

            Utils.print_message(f"Modifying {Utils.magenta_text(len(inodes_to_chown))} inodes: UID={Utils.yellow_text(target_uid)}, GID={Utils.yellow_text(target_gid)}...")

            cmds = []

            # Explicitly fix overlay skeleton
            for path in ["/upper", "/work", "/work/work"]:
                cmds.append(f"sif {path} uid {target_uid}")
                cmds.append(f"sif {path} gid {target_gid}")

            for inode in inodes_to_chown:
                cmds.append(f"sif <{inode}> uid {target_uid}")
                cmds.append(f"sif <{inode}> gid {target_gid}")

            debugfs_script = "\n".join(cmds)

            subprocess.run(
                [debugfs_bin, "-w", overlay_path],
                input=debugfs_script,
                text=True,
                check=True,
                stderr=subprocess.PIPE,
                stdout=subprocess.PIPE
            )

            Utils.print_success(f"{len(inodes_to_chown)} inodes chowned via debugfs.")

        except Exception as e:
            Utils.print_error(f"Debugfs recursive chown failed: {e}")

    @staticmethod
    def run_resize(args):
        if not shutil.which("resize2fs") or not shutil.which("e2fsck"):
            Utils.print_error("Requires 'resize2fs' and 'e2fsck'.")
            exit(1)

        target = os.path.abspath(args.image)
        if not os.path.isfile(target):
            Utils.print_error(f"Image {target} not found.")
            exit(1)

        try:
            size_mib = Utils.parse_size_to_mb(args.size)
        except ValueError as ve:
            Utils.print_error(str(ve))
            exit(1)

        Utils.print_message(f"Resizing {Utils.blue_text(os.path.basename(target))} to {Utils.yellow_text(str(size_mib) + ' MiB')}...")
        new_size_bytes = size_mib * 1024 * 1024
        current_size = os.path.getsize(target)

        if new_size_bytes == current_size:
            Utils.print_message("Size unchanged.")
            return

        Utils.print_message("Checking filesystem integrity before resizing...")
        try:
            subprocess.run(["e2fsck", "-p", "-f", target], check=True, stdout=subprocess.DEVNULL)
            if new_size_bytes < current_size:
                Utils.print_message("Shrinking overlay image...")
                subprocess.run(["resize2fs", "-p", target, f"{size_mib}M"], check=True)
                with open(target, "a") as f:
                    f.truncate(new_size_bytes)
            else:
                Utils.print_message("Expanding overlay image...")
                with open(target, "a") as f:
                    f.truncate(new_size_bytes)
                subprocess.run(["resize2fs", "-p", target], check=True)
            subprocess.run(["e2fsck", "-p", "-f", target], check=True, stdout=subprocess.DEVNULL)
            Utils.print_success("Overlay image resized.")
        except subprocess.CalledProcessError:
            Utils.print_error("Failed to resize overlay image")
            exit(1)

class CondaTainer_Update:
    @staticmethod
    def add_parser_arguments(parser):
        CondaTainer_Update.parser_update = parser.add_parser("self-update", help="Update CondaTainer to the latest version")
        CondaTainer_Update.parser_update.add_argument(
            "-y", "--yes", action="store_true",
            help="Automatically confirm update")

    @staticmethod
    def parse_update_args(args):
        if not args.yes:
            Utils.print_message("Are you sure to download and replace the current script from GitHub? [y/N]: ", end="", flush=True)
            confirm = input()
            if confirm.lower() != 'y':
                Utils.print_message("Update cancelled by user.")
                return

        Utils.print_message("Downloading the latest CondaTainer script...")
        if Utils.download_executable(Config.CONDATAINER_URL, Config.SCRIPT_PATH + ".tmp"):
            os.chmod(Config.SCRIPT_PATH + ".tmp", 0o775)
            shutil.move(Config.SCRIPT_PATH + ".tmp", Config.SCRIPT_PATH)
            Utils.print_success("CondaTainer updated.")
        else:
            Utils.print_error("Failed to download the latest CondaTainer script.")
            exit(1)

class CondaTainer_Completion:
    """Generates shell completion scripts for Bash and Zsh. (Gemini Generated)"""

    # Auto-detect shell from environment
    _detected_shell = "zsh" if "zsh" in os.environ.get("SHELL", "") else "bash"

    @staticmethod
    def add_parser_arguments(parser):
        sub = parser.add_parser("completion", help=f"Generate shell completion script 'source <({Config.SCRIPT_NAME} completion)'")
        sub.add_argument("shell", choices=["bash", "zsh"], default=CondaTainer_Completion._detected_shell, nargs="?", help=f"Shell type (default: {CondaTainer_Completion._detected_shell})")

    @staticmethod
    def parse_completion_args(args):
        script_name = Config.SCRIPT_NAME
        target_shell = args.shell

        # Regex for installed system images (no extension in name)
        ext_regex = r"[.](sqf|sqsh|squashfs|img)$"

        if target_shell == "bash":
            completion_code = f"""
_{script_name}_completion() {{
    local cur prev opts
    COMPREPLY=()
    cur="${{COMP_WORDS[COMP_CWORD]}}"
    prev="${{COMP_WORDS[COMP_CWORD-1]}}"

    local subcommands="create install i avail av list ls remove rm delete exec e check run info helper self-update completion overlay o"
    local global_opts="--debug --local -v --version -h --help"

    if [[ ${{COMP_CWORD}} -eq 1 ]]; then
        if [[ "${{cur}}" == -* ]]; then
            COMPREPLY=( $(compgen -W "${{global_opts}}" -- "${{cur}}") )
        else
            COMPREPLY=( $(compgen -W "${{subcommands}}" -- "${{cur}}") )
        fi
        return 0
    fi

    local subcommand="${{COMP_WORDS[1]}}"

    # Usage: _list_overlays <include_app> <include_data>
    _list_overlays() {{
        local include_app=$1
        local include_data=$2
        local img_dir="{Config.IMAGES_DIR}"
        local ref_dir="{Config.REF_IMAGES_DIR}"
        local files=""

        # App Overlays
        if [[ "$include_app" == "true" && -d "$img_dir" ]]; then
            local sys_imgs=$(ls -1 "$img_dir" 2>/dev/null | grep -E '{ext_regex}' | sed 's/\\.[^.]*$//' | sed 's/--/\\//g')
            files="$files $sys_imgs"
        fi

        # Data Overlays
        if [[ "$include_data" == "true" && -d "$ref_dir" ]]; then
            local ref_imgs=$(ls -1 "$ref_dir" 2>/dev/null | grep -E '{ext_regex}' | sed 's/\\.[^.]*$//' | sed 's/--/\\//g')
            files="$files $ref_imgs"
        fi

        echo "$files"
    }}

    case "${{subcommand}}" in
        overlay)
            if [[ ${{COMP_CWORD}} -eq 2 ]]; then
                COMPREPLY=( $(compgen -W "create chown resize" -- "${{cur}}") )
            elif [[ "${{COMP_WORDS[2]}}" == "chown" ]]; then
                if [[ "${{cur}}" == -* ]]; then
                    COMPREPLY=( $(compgen -W "-u --uid -g --gid -p --path --root" -- "${{cur}}") )
                else
                    local local_files=$(compgen -f -- "${{cur}}" | grep -E '\\.(sqf|img)$')
                    local sys_files=$(_list_overlays true true)
                    COMPREPLY=( $(compgen -W "$local_files $sys_files" -- "${{cur}}") )
                fi
            elif [[ "${{COMP_WORDS[2]}}" == "resize" ]]; then
                if [[ "${{cur}}" == -* ]]; then
                    COMPREPLY=( $(compgen -W "-s --size" -- "${{cur}}") )
                else
                    local local_files=$(compgen -f -- "${{cur}}" | grep -E '\\.(sqf|img)$')
                    COMPREPLY=( $(compgen -W "$local_files" -- "${{cur}}") )
                fi
            elif [[ "${{COMP_WORDS[2]}}" == "create" ]]; then
                if [[ "${{cur}}" == -* ]]; then
                    COMPREPLY=( $(compgen -W "-s --size -f --file --fakeroot --sparse" -- "${{cur}}") )
                elif [[ "${{prev}}" == "-f" || "${{prev}}" == "--file" ]]; then
                    COMPREPLY=( $(compgen -f -- "${{cur}}" | grep -E '\\.(def|sh|yaml|yml)$') )
                else
                    COMPREPLY=( $(compgen -f -- "${{cur}}") )
                fi
            fi
            return 0
            ;;
        o)
             if [[ "${{cur}}" == -* ]]; then
                 COMPREPLY=( $(compgen -W "-s --size -f --file --fakeroot --sparse" -- "${{cur}}") )
             elif [[ "${{prev}}" == "-f" || "${{prev}}" == "--file" ]]; then
                 COMPREPLY=( $(compgen -f -- "${{cur}}" | grep -E '\\.(def|sh|yaml|yml)$') )
             else
                 COMPREPLY=( $(compgen -f -- "${{cur}}") )
             fi
             return 0
             ;;
        helper)
             if [[ "${{cur}}" == -* ]]; then
                 COMPREPLY=( $(compgen -W "-u --update -p --path" -- "${{cur}}") )
             else
                 # List scripts in helper-scripts folder
                 local helper_dir="{os.path.join(Config.CONDATINER_DIR, "helper-scripts")}"
                 if [[ -d "$helper_dir" ]]; then
                     local scripts=$(ls -1 "$helper_dir" 2>/dev/null)
                     COMPREPLY=( $(compgen -W "$scripts" -- "${{cur}}") )
                 fi
             fi
             return 0
             ;;
        create|install|i)
            if [[ "${{cur}}" == -* ]]; then
                local opts="-n --name -p --prefix -f --file -b --base-image -s --source --temp-size --zstd --zstd-fast --zstd-medium --zstd-high --gzip --lz4"
                COMPREPLY=( $(compgen -W "${{opts}}" -- "${{cur}}") )
            elif [[ "${{prev}}" == "-f" || "${{prev}}" == "--file" ]]; then
                 COMPREPLY=( $(compgen -f -- "${{cur}}" | grep -E '\\.(def|sh|yaml|yml)$') )
            else
                 COMPREPLY=( $(compgen -f -- "${{cur}}") )
            fi
            return 0
            ;;
        exec)
            if [[ "${{prev}}" == "-o" || "${{prev}}" == "--overlay" ]]; then
                local local_files=$(compgen -f -- "${{cur}}" | grep -E '\\.(sqf|img)$')
                local sys_files=$(_list_overlays true true)
                COMPREPLY=( $(compgen -W "$local_files $sys_files" -- "${{cur}}") )

            elif [[ "${{prev}}" == "-b" || "${{prev}}" == "--base-image" ]]; then
                local local_files=$(compgen -f -- "${{cur}}" | grep -E '\\.(sqf|img|sif)$')
                local sys_files=$(_list_overlays true false)
                COMPREPLY=( $(compgen -W "$local_files $sys_files" -- "${{cur}}") )

            else
                local opts="-o --overlay -k --keep -w --writable-img --env --bind --fakeroot -b --base-image"
                if [[ "${{cur}}" == -* ]]; then
                    COMPREPLY=( $(compgen -W "${{opts}}" -- "${{cur}}") )
                else
                    COMPREPLY=( $(compgen -f -- "${{cur}}") )
                fi
            fi
            return 0
            ;;
        check)
            if [[ "${{cur}}" == -* ]]; then
                COMPREPLY=( $(compgen -W "-a --auto-install -i --install" -- "${{cur}}") )
            else
                COMPREPLY=( $(compgen -f -- "${{cur}}") )
            fi
            return 0
            ;;
        run)
            if [[ "${{cur}}" == -* ]]; then
                COMPREPLY=( $(compgen -W "-w --writable-img -a --auto-install -i --install -b --base-image" -- "${{cur}}") )
            elif [[ "${{prev}}" == "-b" || "${{prev}}" == "--base-image" ]]; then
                local local_files=$(compgen -f -- "${{cur}}" | grep -E '\\.(sqf|img|sif)$')
                local sys_files=$(_list_overlays true false)
                COMPREPLY=( $(compgen -W "$local_files $sys_files" -- "${{cur}}") )
            else
                COMPREPLY=( $(compgen -f -- "${{cur}}") )
            fi
            return 0
            ;;
        avail|av)
            if [[ "${{cur}}" == -* ]]; then
                COMPREPLY=( $(compgen -W "-i --install -a --add" -- "${{cur}}") )
            fi
            return 0
            ;;
        list|ls)
            if [[ "${{cur}}" == -* ]]; then
                COMPREPLY=( $(compgen -W "-d --delete -r --remove" -- "${{cur}}") )
            fi
            return 0
            ;;
        self-update)
            if [[ "${{cur}}" == -* ]]; then
                COMPREPLY=( $(compgen -W "-y --yes" -- "${{cur}}") )
            fi
            return 0
            ;;
        completion)
            COMPREPLY=( $(compgen -W "bash zsh" -- "${{cur}}") )
            return 0
            ;;
        remove|rm|delete)
            local sys_files=$(_list_overlays true true)
            COMPREPLY=( $(compgen -W "$sys_files" -- "${{cur}}") )
            return 0
            ;;
        e)
            if [[ "${{cur}}" == -* ]]; then
                 COMPREPLY=( $(compgen -W "-r --read-only -n --no-autoload --fakeroot -b --base-image" -- "${{cur}}") )
            elif [[ "${{prev}}" == "-b" || "${{prev}}" == "--base-image" ]]; then
                 local local_files=$(compgen -f -- "${{cur}}" | grep -E '\\.(sqf|img|sif)$')
                 local sys_files=$(_list_overlays true false)
                 COMPREPLY=( $(compgen -W "$local_files $sys_files" -- "${{cur}}") )
            else
                 local local_files=$(compgen -f -- "${{cur}}" | grep -E '\\.(sqf|img)$')
                 local sys_files=$(_list_overlays true true)
                 COMPREPLY=( $(compgen -W "$local_files $sys_files" -- "${{cur}}") )
            fi
            return 0
            ;;
        info)
            local local_files=$(compgen -f -- "${{cur}}" | grep -E '\\.(sqf|img)$')
            local sys_files=$(_list_overlays true true)
            COMPREPLY=( $(compgen -W "$local_files $sys_files" -- "${{cur}}") )
            return 0
            ;;
        *)
            COMPREPLY=( $(compgen -f -- "${{cur}}") )
            return 0
            ;;
    esac
}}
complete -F _{script_name}_completion {script_name}
"""
        elif target_shell == "zsh":
            completion_code = f"""
#compdef {script_name}

_{script_name}_completion() {{
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \\
        '(-v --version)'{{-v,--version}}'[Show version]' \\
        '(-h --help)'{{-h,--help}}'[Show help]' \\
        '--debug[Enable debug mode]' \\
        '--local[Run operations locally (disable job submission)]' \\
        '1: :->command' \\
        '*:: :->args'

    case $state in
        command)
            local subcmds=(
                'create:Create a new SquashFS overlay'
                'install:Alias for create'
                'i:Alias for create'
                'avail:Check available build scripts'
                'av:Alias for avail'
                'list:List installed overlays'
                'ls:Alias for list'
                'remove:Remove installed overlays'
                'rm:Alias for remove'
                'delete:Alias for remove'
                'exec:Execute a command using overlays'
                'e:Run bash using writable overlays'
                'check:Check script dependencies'
                'run:Run a script with auto-solving deps'
                'helper:Run or update helper scripts'
                'info:Show overlay information'
                'self-update:Update CondaTainer'
                'completion:Generate shell completion'
                'overlay:Manage overlay images (img)'
                'o:Alias for overlay create'
            )
            _describe -t commands 'subcommands' subcmds
            ;;
        args)
            local subcommand="${{words[1]}}"

            _installed_overlays() {{
                local include_app=$1
                local include_data=$2
                local img_dir="{Config.IMAGES_DIR}"
                local ref_dir="{Config.REF_IMAGES_DIR}"
                local -a overlays

                if [[ "$include_app" == "true" && -d "$img_dir" ]]; then
                     local sys_found=$(ls -1 "$img_dir" 2>/dev/null | grep -E '{ext_regex}' | sed 's/\\.[^.]*$//' | sed 's/--/\\//g')
                     [[ -n "$sys_found" ]] && overlays+=(${{(f)sys_found}})
                fi
                if [[ "$include_data" == "true" && -d "$ref_dir" ]]; then
                     local ref_found=$(ls -1 "$ref_dir" 2>/dev/null | grep -E '{ext_regex}' | sed 's/\\.[^.]*$//' | sed 's/--/\\//g')
                     [[ -n "$ref_found" ]] && overlays+=(${{(f)ref_found}})
                fi

                if [[ ${{#overlays}} -gt 0 ]]; then
                    _describe -t overlays 'installed overlays' overlays
                fi
            }}

            case $subcommand in
                overlay)
                    local overlay_cmds=(
                        'create:Create a new empty overlay image'
                        'chown:Change ownership of files inside an overlay'
                        'resize:Resize an existing overlay in-place'
                    )
                    _arguments \\
                        '1: :_describe -t commands "overlay commands" overlay_cmds' \\
                        '*:: :->overlay_args'

                    case $state in
                        overlay_args)
                            case ${{words[1]}} in
                                create)
                                    _arguments \\
                                        '(-s --size)'{{-s,--size}}'[Size in MiB]:size' \\
                                        '(-f --file)'{{-f,--file}}'[Conda env file]:file:_files -g "*.def *.sh *.yaml *.yml"' \\
                                        '--fakeroot[Fakeroot overlay]' \\
                                        '--sparse[Create sparse overlay]' \\
                                        ':image:_files'
                                    ;;
                                chown)
                                    _arguments \\
                                        '(-u --uid)'{{-u,--uid}}'[User ID]:uid' \\
                                        '(-g --gid)'{{-g,--gid}}'[Group ID]:gid' \\
                                        '(-p --path)'{{-p,--path}}'[Path inside overlay]:path' \\
                                        '--root[Set UID/GID to 0]' \\
                                        ':overlay:_alternative "files:file:_files -g \\"*.sqf *.img\\"" "ovs:installed:_ov 1 1"'
                                    ;;
                                resize)
                                    _arguments \\
                                        '(-s --size)'{{-s,--size}}'[New size in MiB]:size' \\
                                        ':image:_files -g "*.sqf *.img"'
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                o)
                    _arguments \\
                        '(-s --size)'{{-s,--size}}'[Size in MiB]:size' \\
                        '(-f --file)'{{-f,--file}}'[Conda env file]:file:_files -g "*.def *.sh *.yaml *.yml"' \\
                        '--fakeroot[Fakeroot overlay]' \\
                        '--sparse[Create sparse overlay]' \\
                        ':image:_files'
                    ;;
                create|install|i)
                    _arguments \\
                        '(-n --name)'{{-n,--name}}'[Custom name for overlay]:name' \\
                        '(-p --prefix)'{{-p,--prefix}}'[Custom prefix path]:prefix:_files' \\
                        '(-f --file)'{{-f,--file}}'[Conda env file]:file:_files -g "*.def *.sh *.yaml *.yml"' \\
                        '(-b --base-image)'{{-b,--base-image}}'[Base image]: :_alternative "files:file:_files -g \\"*.sqf *.img *.sif\\"" "overlays:installed:_installed_overlays true false"' \\
                        '(-s --source)'{{-s,--source}}'[Remote source (docker://...)]:source' \\
                        '--temp-size[Temp overlay size]:size' \\
                        '--zstd[ZSTD level 14]' \\
                        '--zstd-fast[ZSTD level 3]' \\
                        '--zstd-medium[ZSTD level 8]' \\
                        '--zstd-high[ZSTD level 19]' \\
                        '--gzip[GZIP]' \\
                        '--lz4[LZ4]' \\
                        '*:package:_files'
                    ;;
                exec)
                    _arguments \\
                        '*(-o --overlay)'{{-o,--overlay}}'[Mount overlay]: :_alternative "files:file:_files -g \\"*.sqf *.img\\"" "overlays:installed:_installed_overlays true true"' \\
                        '(-k --keep)'{{-k,--keep}}'[Do not parse command to installed overlays]' \\
                        '(-w --writable-img)'{{-w,--writable-img}}'[Make .img overlays writable]' \\
                        '--fakeroot[Run with fake root]' \\
                        '(-b --base-image)'{{-b,--base-image}}'[Base image]: :_alternative "files:file:_files -g \\"*.sqf *.img *.sif\\"" "overlays:installed:_installed_overlays true false"' \\
                        '*--env[Env setting KEY=VALUE]:env' \\
                        '*--bind[Bind path HOST:CONTAINER]:bind' \\
                        '*:command:_files'
                    ;;
                e)
                    _arguments \\
                        '(-r --read-only)'{{-r,--read-only}}'[Mount read-only]' \\
                        '(-n --no-autoload)'{{-n,--no-autoload}}'[No autoload env.img]' \\
                        '--fakeroot[Run with fake root]' \\
                        '(-b --base-image)'{{-b,--base-image}}'[Base image]: :_alternative "files:file:_files -g \\"*.sqf *.img *.sif\\"" "overlays:installed:_installed_overlays true false"' \\
                        '*:overlay: :_alternative "files:file:_files -g \\"*.sqf *.img\\"" "overlays:installed:_installed_overlays true true"'
                    ;;
                check)
                    _arguments \\
                        '(-a --auto-install -i --install)'{{-a,-i,--auto-install,--install}}'[Auto install deps]' \\
                        ':script:_files'
                    ;;
                run)
                    _arguments \\
                        '(-w --writable-img)'{{-w,--writable-img}}'[Make .img writable]' \\
                        '(-a --auto-install -i --install)'{{-a,-i,--auto-install,--install}}'[Auto install deps]' \\
                        '(-b --base-image)'{{-b,--base-image}}'[Base image]: :_alternative "files:file:_files -g \\"*.sqf *.img *.sif\\"" "overlays:installed:_installed_overlays true false"' \\
                        ':script:_files'
                    ;;
                helper)
                    _arguments \\
                        '(-u --update)'{{-u,--update}}'[Update helper scripts]' \\
                        '(-p --path)'{{-p,--path}}'[Print path]' \
                        '*:script:_files'
                    ;;
                avail|av)
                    _arguments \\
                        '(-i --install -a --add)'{{-i,-a,--install,--add}}'[Install selected]' \\
                        '*:term'
                    ;;
                list|ls)
                    _arguments \\
                        '(-d --delete -r --remove)'{{-d,-r,--delete,--remove}}'[Delete listed]' \\
                        '*:term'
                    ;;
                self-update)
                    _arguments \\
                        '(-y --yes)'{{-y,--yes}}'[Confirm]'
                    ;;
                completion)
                    _arguments ':shell:(bash zsh)'
                    ;;
                remove|rm|delete)
                    _installed_overlays true true
                    ;;
                info)
                    _arguments \\
                        ':overlay: :_alternative "files:file:_files -g \\"*.sqf *.img\\"" "overlays:installed:_installed_overlays true true"'
                    ;;
                *)
                    _files
                    ;;
            esac
            ;;
    esac
}}

_{script_name}_completion "$@"
"""
        else:
            completion_code = ""
        print(completion_code.strip())

if __name__ == "__main__":
    try:
        main()
    except RuntimeError as rte:
        Utils.print_error(str(rte))
        sys.exit(1)
    except ValueError as ve:
        Utils.print_error(str(ve))
        sys.exit(1)
    except KeyboardInterrupt:
        sys.exit(1)
